<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Malware Detection Evasion Techniques - The Red Teamers Bible</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/mdbook-admonish.css">
        <link rel="stylesheet" href="src/custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Red Teamers Bible</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="malware-detection-evasion-techniques"><a class="header" href="#malware-detection-evasion-techniques">Malware Detection Evasion Techniques</a></h1>
<p>Modern Computer Systems come preloaded with a number of security mechanisms to combat the basic methods of exploitation, privilege escalation, and persistence we have reviewed so far. Without modification, these techniques would immediately be identified and mitigated before the attacker could perform any part of their operation. But although they likely won't work on their own, with some additional consideration these techniques can still be useful for exploiting weaknesses in security systems. In this section, we will review some methods for writing strong malware payloads that avoid detection and circumvent many of the obstacles that would otherwise prevent a payload from ever executing on a secure system.</p>
<h2 id="anti-debugging-tricks"><a class="header" href="#anti-debugging-tricks">Anti-Debugging Tricks</a></h2>
<p>Preventing malware from being analyzed, or at the very least making analysis extremely difficult, ultimately gives it a quality of ambiguity, so that its functions and mechanisms cannot be determined. There are numerous debugging detection techniques, and here we will review a few as well as some methods for identifying new ones. Although a capable analyst will be capaable of mitigating any of them, introducing complexit at least makes their job a lot harder.</p>
<h3 id="detecting-debugger-presence"><a class="header" href="#detecting-debugger-presence">Detecting Debugger Presence</a></h3>
<p>The first step in anti-debugging is determining whether or not the application is being run with a debugger attached. It is possible to ask the operating system using the <code>IsDebuggerPresent</code> function.</p>
<pre><code class="language-C">BOOL WINAPI IsDebuggerPresent(void);
</code></pre>
<ul>
<li>
<p>The <code>IsDebuggerPresent</code> function takes no parameters. It simply checks whether the <code>BeingDebugged</code> flag is set in the <strong>Process Environment Block</strong> (PEB)/</p>
<pre><code class="language-C">struct _PEB{
  UCHAR InheritedAddressSpace;
  UCHAR ReadImageFileExecOptions;
  UCHAR BeingDebugged;
  [...trunc...]
};
</code></pre>
<ul>
<li>
<p>The flag is specifically designed to detect user-mode debuggers. When a debugger is used to attach to an active process:</p>
<ol>
<li>The debugger calls the Win32 API <code>DebugActiveProcess</code></li>
<li><code>DebugActiveProcess</code> triggers a call to <code>NtDebugActiveProcess</code> in the kernel.</li>
<li>The kernel involves an internal function, typically <code>DbgkpSetProcessDebugObject</code>, which assigns a debug object to the process.</li>
<li>The kernel updates the <code>BeingDebugged</code> attribute in the <code>PEB</code>, setting it to <code>TRUE</code> so that any further calls to <code>IsDebuggerPresent</code> will indicate that there is an active debugging session.</li>
</ol>
</li>
<li>
<p>When a debugger is used to launch a new process:</p>
<ol>
<li>The debugger calls the <code>CreateProcess</code> API (or <code>CreateProcessAsUser</code>\<code>WithToken</code>) with the <code>dwCreationFlags</code> parameter set to <code>DEBUG_PROCESS</code> or <code>DEBUG_ONLY_THIS_PROCESS</code>.</li>
<li>Whichever API call is used eventually causes the <strong>Process Manager</strong> (PS Subsystem) to call <code>PspAllocateProcess</code>, which is responsible for creating and initializing a new process object, <code>_EPROCESS</code> during process creation and recognizes that the debug flag has been set. Successively, Windows Executive components (i.e., <code>The Object Manager</code> and <code>The Process Manager</code>) become responsible for creating a <strong>Debug Object</strong> and setting the <code>DebugPort</code> attribute of the <code>_EPROCESS</code> object to point to said Debug Object.</li>
</ol>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note"></a>
</div>
<div>
<p>The <strong>Debug Object</strong> is a communication channel used by the debugger and the kernel to manage the creation and execution of debug events. When something important happens inside of a debugged process, such as process/thread creation, DLL loading/unloading, breakpoints, exceptions, etc., a debug event is created and stored in the <code>EventList</code> of the <code>_DEBUG_OBJECT</code>, then the</p>
<pre><code class="language-C">typedef struct _DEBUG_OBJECT
{
    KEVENT Event;                // 0x00  (0x18 bytes)
    FAST_MUTEX Mutex;           // 0x18  (0x28 bytes)
    LIST_ENTRY MessageList;     // 0x38  Debug events queue
    LARGE_INTEGER CreateTime;   // 0x48
    LIST_ENTRY ProcessList;     // 0x50  Attached processes
    union
    {
        ULONG Flags;            // 0x60
        ULONG RefCount;
    };
    ULONG Padding;              // 0x64
    // Possibly more WER/telemetry fields after
} DEBUG_OBJECT, *PDEBUG_OBJECT;
</code></pre>
<blockquote>
<p>Manually discerned using WinDbg. Look at <a href="./Reversing.html">Appendix X: Reversing the _DEBUG_OBJECT with WinDBG</a> for more details.</p>
</blockquote>
</div>
</div>
</li>
</ul>
</li>
</ul>
<p>Malware developers may want their programs to behave differently if a debugger is active. For instance, consider the following program:</p>
<pre><code class="language-C">// debugger_here.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;windows.h&gt;

bool hack(){
  MessageBox(NULL, "You Have Been Hacked!", "&gt;;-)", MB_OK);
}

int main(){
  if(IsDebuggerPresent()){
    MessageBox(NULL, "debugger detected! exiting...\n", "RUNNING IN DEBUGGER", MB_OK);
    return 1;
  }
  hack();
  return 0;
}
</code></pre>
<p>After compiling the program, it can be run on a Windows system like any other program:
<img src="img/debugger_exp_run_nrml.png" alt="image" /></p>
<p>We can see that when it runs, the <code>hack()</code> function is executed and a <code>MessageBox</code> shows the message <code>You Have Been Hacked!</code>. However, if it is launched in a debugger, a different message is shown:
<img src="img/debugger_exp_run_dbg.png" alt="image" /></p>
<p>So, depending on the context that the program is running in, it will demonstrate different behaviors. This technique is usesful for malicious program that want to avoid being dynamically analyzed.</p>
<h3 id="detecting-breakpoints"><a class="header" href="#detecting-breakpoints">Detecting Breakpoints</a></h3>
<p>Software debuggers allow operators to set <strong>breakpoints</strong>, which are places within a program where the debugger will pause execution, allowing analysts to observe the programs state. When a software breakpoint is set at a particular memory address, the debugger reads the first instruction byte of the target, saves it in an internal lookup table, then replaces it with the value <code>0xCC</code>, the <code>INT 3</code> x86 instruction, designed to throw a <code>EXCEPTION_BREAKPOINT</code>. When the debuggee program is executed, it eventually encounters the interrupt instruction. Now, the program doesn't know that it has encountered a breakpoint, it just knows that it hit a software interrupt. The CPU throws the interrupt and the kernel verifies that the program is being debugged. Then, it pauses execution of the target thread and sends a <code>DEBUG_EVENT</code> to the debugger. When execution is resumed, the original bytes are retrieved from the internal lookup table and replaced to the location set by the breakpoint.</p>
<p>A basic way to determine whether a debugger has set breakpoints during execution is to calculate a <strong>checksum</strong> for the targeted region before the program is compiled. A checksum is a value which helps measure whether any minor changes have been made to a data set. Passing the data through a function produces a relatively unique number. In the event any minor changes are made to the data, the resulting checksum value will be different, indicating some form of data corruption.</p>
<p>By isolating the region within the code where the checksum should be applied, it can be pre-calculated, then hardcoded into the program. The checksum recalculation should occur before any critical sections within the program, where breakpoints should not be allowed.</p>
<p>Here is an example:</p>
<pre><code class="language-C">// breakpoints.exe
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

DWORD CalcFuncChecksum(PUCHAR funcBegin, PUCHAR funcEnd) {
  DWORD chksm = 0;
  for (; funcBegin &lt; funcEnd; ++funcBegin) {
    chksm += *funcBegin;
  }
  return chksm;
}

VOID Debuggee() {
  int x;
  long y;
  char name[20];
  union location{
    int list_num;
    long longitude;
    char str_name[20];
  };
}

VOID DebuggeeEnd() {};

DWORD checksum = 0x741;

int main() {
  DWORD recalc = CalcFuncChecksum((PUCHAR)Debuggee, (PUCHAR)DebuggeeEnd);
  if (checksum != recalc) {
    char str[20];
    snprintf(str, sizeof(str), "%d", recalc);
    MessageBox(NULL, "Debugger!", str, MB_OK);
    return -1;
  }
  MessageBox(NULL, "I Hate Being Debugged!", "&gt;:-(", MB_OK);
  return 0;
}
</code></pre>
<p>First, we define a function <code>CalcFuncChecksum</code>, which calculates a checksum value for all the data between two memory addresses. In this case, the protected code is within the <code>Debuggee</code> function. <code>DebuggeeEnd</code> is created as an in scope address we can refer to as the end of our <code>Debuggee</code> function. Since the checksum value is not known until the program is run at least once, call <code>CalcFuncChecksum</code> in <code>main</code>, set the return value equal to some <code>DWORD</code>, and print it to stdout using <code>printf</code>. This value should be set equal to <code>checksum</code>. Everytime the program runs, it should start by calculating the checksum for the protected region and comparing it to the hardcoded <code>checksum</code> value. This makes it that much harder for the program to be dynamically analyzed.</p>
<p><img src="img/breakpoints_exp_run_nrml.png" alt="image" /></p>
<blockquote>
<p>Normal execution of <code>breakpoints.exe</code></p>
</blockquote>
<p><img src="img/breakpoints_exp_run_dbg.png" alt="image" /></p>
<blockquote>
<p>Debugger execution of <code>breakpoints.exe</code> with breakpoints set</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Escalation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Command.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Escalation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Command.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
