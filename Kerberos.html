<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Appendix C: A Primer on Kerberos - The Red Teamers Bible</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/mdbook-admonish.css">
        <link rel="stylesheet" href="src/custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Red Teamers Bible</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="appendix-c-a-primer-on-kerberos"><a class="header" href="#appendix-c-a-primer-on-kerberos">Appendix C: A Primer on Kerberos</a></h1>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it Works</a></h2>
<p><strong>Kerberos</strong> replaces the <strong>New Technology LAN Manager</strong> (<code>NTLM</code>) as the default domain authentication protocol since Windows 2000. It works on a system of <strong>ticets</strong>, where principals (users and computers) are authenticated by a central, trusted server, granting them access to services without needing to provide their password over and over again. Kerberos doesn't require that end services know the principal's password. It assumes that there is no transport encryption on the network and that packets can be read/modified/replayed. Therefore, it relies on shared-secret cryptography to establish a trust relationship with clients.</p>
<p>The <strong>Key Distribution Center</strong> (<code>KDC</code>) is the trusted source for kerberos authentication that consists of three sub components:</p>
<ul>
<li>A database of all principals and their associated secrets (i.e., password hashed)</li>
<li>An <strong>Authentication Server</strong> (<code>AS</code>)</li>
<li>A <strong>Ticket Granting Server</strong> (<code>TGS</code>)</li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note"></a>
</div>
<div>
<p>In a Windows domain, it's the domain controllers that act as the KDC, as every principal and their password hashes are stored in <strong>Active Directory</strong>.</p>
</div>
</div>
<p>A <strong>Ticket Granting Ticket</strong> (<code>TGT</code>) is provided to a principal after their identity has been verified by the <code>AS</code>. It is used in lieu of a principal having to provide their password every time they want to use a service. Each service can be identified by a forest unique <strong>Service Principal Name</strong> (<code>SPN</code>), which should be in the following format:</p>
<pre><code class="language-C">&lt;service class&gt;/&lt;host&gt;:&lt;port&gt;/&lt;service name&gt;
</code></pre>
<p>The <strong><service class></strong> describes the general type of the service. For instance, whether it is a <code>SqlServer</code>, <code>www</code> for a web server, or <code>ldap</code> for a <strong>Lightweight Database Access Protocol</strong> server. The <strong><host>:<port></strong> is simply the <strong>FQDNS</strong> or <strong>NetBios</strong> name, followed by the port that the server is running on. Finally, the <strong><service name></strong> is an optional distinguished name, objectGUID, or DNS Name that helps to further distinguish a service within a domain/forest. It can be ommitted for host-based services.</p>
<p>A <strong>service ticket</strong> is a component returned from the <strong>TGS</strong> in response to a request to access a service using kerberos authentication. A TGT is sent to the KDC as evidence that their identity has been verified.</p>
<p>A <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/21181737-74fd-492c-bfbd-0322993a9061"><strong>Privileged Attribute Certificate</strong></a> is a structure that can be attached to a ticket, which contains additional information about a principal. When a ticket is issued from a Windows Domain Controller, it will populate the <strong>PAC</strong> with information about the principal from Active Directory. This can include their:</p>
<ul>
<li><strong>Relative Identifiers</strong> (<code>RID</code>)</li>
<li><strong>Security Identifiers</strong> (<code>SID</code>)</li>
<li><strong>Domain Group Membership</strong></li>
<li><strong>User Account Control</strong> Information</li>
</ul>
<p>When presenting a service ticket to a service, the service is able to inspect the PAC to determine the user's privileges without having to query it from AD.</p>
<p><img src="img/kerberos.png" alt="image" /></p>
<blockquote>
<p><strong>Kerberos Authentication</strong> Overview</p>
</blockquote>
<p>Basically, Kerberos Authentication can be broken up into 3 phases:</p>
<h3 id="phase-1-authentication"><a class="header" href="#phase-1-authentication">Phase 1: Authentication</a></h3>
<ol>
<li>
<p><strong>AS-REQ</strong> (Authentication Service Request)
The Client sends a message to the KDC saying, "I am User X, and I want to log in." This request is partially encrypted using a hash of the user's password.</p>
</li>
<li>
<p><strong>AS-REP</strong> (Authentication Service Replay)
The KDC verifies the user's identity. If successful, it sends back a TGT. The TGT is encrypted with the KDC's own secret key (so the client cannot tamper with it). The client now has proof of identity that it can use for the rest of the session.</p>
</li>
</ol>
<h3 id="phase-2-authorization"><a class="header" href="#phase-2-authorization">Phase 2: Authorization</a></h3>
<ol start="3">
<li>
<p><strong>TGS-REQ</strong> (Ticket Granting Service Request)
At this point, the Client wants to access a specific Service. It sends the TGT back to the KDC, authenticating itself and requesting access to that specific Service.</p>
</li>
<li>
<p><strong>TGS-REP</strong> (Ticket Granting Service Replay)
The KDC validates the TGT. If valid, it issues a Service Ticket. This ticket is encrypted using the Service's secret key. The Client cannot read it, but the Service will be able to.</p>
</li>
</ol>
<h3 id="phase-3-service-access"><a class="header" href="#phase-3-service-access">Phase 3: Service Access</a></h3>
<ol start="5">
<li>
<p><strong>AP-REQ</strong> (Application Request)
The client sends the Service Ticket to the Service to request access. The Service decrypts the ticket using its own secret key to verify the user's identity.</p>
<p>5.5 <strong>Optional PAC Validation</strong>
The Service asks the KDC to verify the PAC in order to ensure it's authenticity and prevent privilege escalation attacks using forged PAC.</p>
</li>
<li>
<p><strong>AP-REP</strong> (Application Replay)
The Service confirms the connection to the Client. This completes the Mutual Authentication. The Client knows the Service is real, and the Service knows the Client is real, establishing the connection.</p>
</li>
</ol>
<h2 id="delegation"><a class="header" href="#delegation">Delegation</a></h2>
<p>Sometimes, services need to act on behalf or a user to interact with other back end resources. <strong>Delegation</strong> describes the method used to facilitate this type of interaction. There are two types. When <strong>Unconstrained Delegation</strong> is implemented, the server receives the ticket, extracts the user's TGT, and caches it in its memory (<code>LSASS</code>). The server can now use that TGT to impersonate the user to any service on the network. If an attacker compromises a server with Unconstrained Delegation, they can dump the memory to steal the TGTs of any administrator who connects to it (i.e., a Domain Admin performs maintenance on the box -&gt; Attacker steads DA TGT -&gt; Attacker owns the domain). This is considered highly insecure today.
The more secure method, <strong>Constrained Delegation</strong>, was introduced in Windows Server 2003 to fix the security risks of Unconstrained Delegation. The service is strictly limited in where it can send the user's credentials. The Domain Admin specifies exactly which SPNs the middle-tier server is allowed to access on behalf of the user.</p>
<p>When a user authenticates to a service with <strong>Constrained Delegation</strong> enabled, the user gets a Kerberos TGT and the Service receives a forwardable ticket. With this, the service can request service tickets from allowed SPNs.</p>
<p>Services with Constrained Delegation enabled can implements additional extensions. For instance, <strong>S4U2Self</strong> (<code>Service-for-User-to-Self</code>) allows the configured service to ask for a ticket to itself on behalf of the client, even if the user did not authenticate using Kerberos. Essentially, this allows services to grant trusted users access to to themselves by performing a <strong>Protocol Transition</strong>, converting a non Kerberos authentication into a valid Kerberos ticket. Another example is <strong>S4U2Proxy</strong> (<code>Service-for-User-To-Proxy</code>), which allows the service to use a <code>S4U2Self</code> ticket to access another service as the user. On services with <strong>Constrained Delegation</strong> enabled, the KDC will verify whether the <code>S4U2Proxy</code> service is allowed to delegate users to the requested service and whether the provided ticket is authentic. If it is, a new ticket is granted allowing the original service to act as a proxy for the authenticated user on the secondary service. Finally, the <strong>U2U</strong> (<code>User-to-User</code>) extension allows a user to request a service ticket that is encrypted using a session ticket provided by the user, as opposed to one with the service account's password hash/key.</p>
<h2 id="attacking-kerberos"><a class="header" href="#attacking-kerberos">Attacking Kerberos</a></h2>
<p>Attackers may attempt to exploit Kerberos to obtain account credentials, impersonate legitimate users, move laterally, elevate priviliges and establish persistence within a domain. Here, we will review a few techniques which accomplish this end, and where possible, discuss how they are mitigated.</p>
<h3 id="as-rep-roasting"><a class="header" href="#as-rep-roasting">AS-REP Roasting</a></h3>
<p>As previously disscussed, in order for a user to authenticate to Kerberos, they must send an <code>AS-REQ</code>. This request packet, in plaintext, resembles the following form:</p>
<pre><code class="language-C">Kerberos AS-REQ
  pvno: 5
  msg-type: 10 (AS-REQ)
  cname: alice
  realm: EXAMPLE.COM
  sname: krbtgt/EXAMPLE.COM
  etype: aes256-cts-hmac-sha1-96
  nonce: 92348123
  PA-DATA: PA-ENC-TIMESTAMP (Encrypted) (Optional, based on RFC4120)
</code></pre>
<p>The <code>PA-DATA</code> field contains a timestamp, encrypted with the user's password hash. On modern Kerberos systems, this is a required field, used to verify that the user is who they say they are. Systems that require this field have enabled <strong>Pre-Authentication</strong>. Without it, users are authenticated and receive an <code>AS-REP</code>, but there is no guarantee that the user is who they say they are. Adversaries can send an <code>AS-REQ</code> packet for a legitimate user and receive an <code>AS-REP</code> packet back. <code>AS-REP</code> packets are highly structured, they typically use <code>AES</code> or <code>RC4</code> encryption, and the protocol is standardized. This allows adversaries an opportunity to brute-force the password offline, exposing the user credentials. This technique is called <strong>AS-REP Roasting</strong>, and it is commonly mitigated by enabling <strong>Pre-Authentication</strong>.</p>
<h3 id="kerberoasting"><a class="header" href="#kerberoasting">Kerberoasting</a></h3>
<p>In practice, a valid TGT allows an authenticated user to request a Service Ticket for any valid SPN from a domain controller. Kerberos requires each SPN be associated with at least one service account for authentication. The account's password NTLM hash or AES key may be used as the private key to encrypt the Service Ticket portion of the SPN's TGS-REP. If an adversary is able to obtain a valid TGT, they can request valid Service Tickets, take them offline, and brute-force the system account's credentials. This is known as <strong>Kerberoasting</strong>. It can be mitigated by configuring service accounts with long passwords (&gt;32 characters long), making it computationally infeasible to brute-force the password.</p>
<h3 id="pass-the-ticket"><a class="header" href="#pass-the-ticket">Pass-the-Ticket</a></h3>
<p>If an adversary is able to capture a TGT or ST, they can use it to impersonate the target user across the domain, for the lifetime of the ticket. This grants them access to whatever resources the user can access. An ST grants access to whatever service on the domain it is assigned to, so a TGT is ideal for further compromise. This allows the adversary to create new STs for any SPN the DC will authorize for the account.</p>
<h3 id="silver-tickets"><a class="header" href="#silver-tickets">Silver Tickets</a></h3>
<p>A <strong>Silver Ticket</strong> is a forged <strong>Service Ticket</strong>. This allows an attacker to authenticate directly to a given service, without authenticating with the <strong>Domain Controller</strong>. The attacker needs the password hash (<code>NTLM</code> hash or <code>AES</code> key) of the <strong>Service Account</strong> responsible for launching the target service. This grants access only to the target service, so it is pretty limited. However it can be very difficult to detect because the KDC is never contacted.</p>
<p>In plaintext, service tickets resemble the following form:</p>
<pre><code class="language-C">EncTicketPart:
  flags:                  forwardable renewable pre_authent name-canonicalize renewable_ok
  key:                    enctype: 18 (aes256-cts-hmac-sha1-96)
                          key value: [32-byte AES key bytes, e.g. 0xF7A2...]
  crealm:                 CONTOSO.COM
  cname:                  [type: NT-PRINCIPAL, name: 'jsmith']
  transited:              (empty or path of realms if cross-realm)
  authtime:               2026-02-09 18:45:12Z
  starttime:              2026-02-09 18:45:12Z
  endtime:                2026-02-10 04:45:12Z
  renew-till:             2026-02-16 18:45:12Z (if renewable)
  caddr:                  (optional: IP_list)
  authorization-data:     [usually contains the Privilege Attribute Certificate / PAC]
                          - PAC_VERSION
                          - PAC_CLIENT_INFO (user SID, logon time)
                          - PAC_PRIVSVR_CHECKSUM
                          - PAC_KDC_CHECKSUM
                          - PAC_CREDENTIALS_INFO (if delegation)
                          - Group memberships, resource groups, extra SIDs, etc.
</code></pre>
<blockquote>
<p>Structure of Kerberos Tickets, as defined by <a href="https://datatracker.ietf.org/doc/html/rfc4120">RFC4120</a></p>
</blockquote>
<p>A Silver Ticket modifies the <code>PAC</code> inside the ticket to impersonate a specific user type within the context of the target service, then uses the service's hash/key to encrypt the forged packet. If the timestamps, encryption, and PAC are all valid, the service trusts the ticket and grants the attacker access. Persistence can be granted if the lifetime of the forged ticket is extended (i.e., <code>10 years</code>), and its <code>renew-till</code> value is set to <code>True</code>. Silver Tickets can be mitigated by enabling <strong>PAC Validation</strong>.</p>
<h3 id="golden-tickets"><a class="header" href="#golden-tickets">Golden Tickets</a></h3>
<p>A <strong>Golden Ticket</strong> is a forged <strong>Ticket Granting Ticket</strong> (<code>TGT</code>). Generally, it requires full domain compromise, allowing adversaries to obtain the <code>krbtgt</code> account's hash or password. This is crucial, as the password hash/account key is used to sign legitimate TGTs. Once the <code>krbtgt</code> account is compromised, an adversary can forge TGTs for any user on the Domain, granting them access to various services on the domain, as if they are the user represented in the ticket.</p>
<p>Golden Tickets can be difficult to detect, but some key indications include:</p>
<ul>
<li>The existence of TGT without TGT requests</li>
<li>Anomalous Kerberos Ticket lifetimes</li>
<li>Unexpected encryption types</li>
<li>Malformed fields in logon/logoff events</li>
</ul>
<p>They can be mitigated by resetting the <code>krbtgt</code> account password twice, since both the current and previous account passwords are saved. This will invalidate any existing golden tickets.</p>
<h3 id="diamond-tickets"><a class="header" href="#diamond-tickets">Diamond Tickets</a></h3>
<p><strong>Diamond Tickets</strong> are an evolution of <strong>Golden Tickets</strong>. Defenders can identify Golden Tickets by looking for TGTs that have no corresponding TGT requests or unexpected encryption types. Diamond Tickets are created by requesting a legitimate TGT from the KDC, then decrypting it using the stolen <code>krbtgt</code> account hash/key. New tickets are forged by modifying the PAC inside the original packet to impersonate another user, add group memberships, alter privileges, etc. Then, they recalculate the PAC signatures/checksums using the <code>krbtgt</code> hash/key and re-encrypt the ticket. The result is an illegitimate TGT that looks almost indistinguishable from a legitimate one. They can still be identified by additional group permissions and added privileges within the PAC.</p>
<h3 id="sapphire-tickets"><a class="header" href="#sapphire-tickets">Sapphire Tickets</a></h3>
<p><strong>Sapphire Tickets</strong> is very similar to a <strong>Diamond Ticket</strong>, but it utilizes the <code>S4U2Self</code> + <code>U2U</code> Kerberos extensions to provide additional stealth. Rather than modifying the PAC within the TGT, Sapphire Tickets replace it with a legitimate, KDC signed PAC from a high privileged user. An adversary with a standard, low-privileged account (which must be a service or have an <code>SPN</code>) and the <code>krbtgt</code> hash/key creates a TGT and sends a <code>TGS-REQ</code> to the KDC with additional Kerberos Extensions. The <code>S4U2Self</code> extension prompts a victim user (defined by the <code>PA-FOR-USER</code> structure containing the <strong>username</strong> and <strong>realm</strong> of the victim) to communicate with the adversaries "service" and the <code>U2U</code> extension causes the resulting service ticket to be signed using a session ticket provided by the adversary from their own TGT, as opposed to their service's hash/key. The resulting <code>TGS-REP</code> contains the PAC of the high privileged victim, which can then be used to forge a TGT which appears legitimate, since the PAC privileges are legitimate.</p>
<p>These tickets are extremely difficult to identify. Microsoft PAC Enforcement Patch (CVE-2021-42287 / KB5008380), released in 2021 adds two additional attributes to PACs in TGTs: <code>PAC_REQUESTOR</code> and <code>PAC_ATTRIBUTES_INFO</code>. These are not included in Service Tickets, so if they are copied into a TGT by an adversary, the missing attributes cause the KDC to reject the <code>KDC_ERR_TGT_REVOKED</code> error. These values are very difficult to forge, making duplication very easy to detect.</p>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<p>More information about <strong>Kerberos</strong> can be found from <a href="https://learn.microsoft.com/en-us/windows/win32/ad/mutual-authentication-using-kerberos">Microsoft</a>, <a href="https://kerberos.org/software/tutorial.html">Kerberos</a>, or the <a href="https://datatracker.ietf.org/doc/html/rfc4120">IETF</a>.</p>
<p>To Learn more about <strong>Delegation</strong>, visit this link <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94">here</a>.</p>
<p>You can find threat intelligence on attacking kerberos, visit the following links on Mitre:</p>
<ul>
<li><a href="https://attack.mitre.org/techniques/T1558/004/">AS-REP Roasting</a></li>
<li><a href="https://attack.mitre.org/techniques/T1558/003/">Kerberoasting</a></li>
<li><a href="https://attack.mitre.org/techniques/T1558/002/">Silver Tickets</a></li>
<li><a href="https://attack.mitre.org/techniques/T1558/001/">Golden Tickets</a></li>
</ul>
<p>More information on Diamond Tickets can be found <a href="https://trustedsec.com/blog/a-diamond-in-the-ruff">here</a>.
More information on Sapphire Tickets can be found <a href="https://pgj11.com/posts/Diamond-And-Sapphire-Tickets/#sapphire-ticket">here</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Shellcode.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Reversing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Shellcode.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Reversing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
