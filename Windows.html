<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Windows Fundamentals - The Red Teamers Bible</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/mdbook-admonish.css">
        <link rel="stylesheet" href="src/custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Red Teamers Bible</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="windows-fundamentals"><a class="header" href="#windows-fundamentals">Windows Fundamentals</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Programs are tightly integrated with operating systems. Identifying and understanding the bridging points between application programs and the operating system is critical to identifying and exploiting vulnerabilities. Microsoft Windows is the largest desktop OS and is the largest target for malicious attacks. The goal of this chapter is to establish how Windows works in order to inform the more practical work that we will engage later on.</p>
<h2 id="components-and-basic-architecture"><a class="header" href="#components-and-basic-architecture">Components and Basic Architecture</a></h2>
<p><code>Microsoft Windows</code> is a family of proprietary Operating Systems developed and sold by Microsoft. It runs on many computing platforms, and is responsible for managing hardware and software resources, providing a graphical user interface, and supplying built-in apps and services for file management, computer networking, security, and running third-party apps. Windows is made up of a few, key features and components:</p>
<ul>
<li><code>64-bit Architecture</code>: Modern Windows operating systems, including Windows 10 and 11, are designed as pure 64-bit environments. This allows them to optimally use modern, 64-bit processors designed by companies such as Intel, AMD, and Qualcomm.</li>
<li><code>Supports Virtual Memory</code>: Virtual memory allows the system to use disk space as if it were additional RAM, managing memory efficiently and enabling the execution of multiple applications, even when physical memory is low.</li>
<li><code>Portable</code>: Modern Windows is a highly portable operating system, written primarily in C and C++. This allows it to run on a variety of processor architectures, including x86-64 and ARM. The systems <code>Hardware Abstraction Layer</code> (HAL) isolates the OS from the physical hardware, making it easier to adapt to new hardware platforms and drivers.</li>
<li><code>Multithreaded</code>: Windows is a fully preemptive, multi-threaded operating system. The kernel and its core components are designed to handle multiple tasks concurrently, providing a responsive and fluid user experience. This allows modern applications to run smoothly and simultaneously, without one task monopolizing system resources.</li>
<li><code>Multi-processor Capable</code>: The Windows kernel is highly multi-processor capable, designed to efficiently utilize multiple CPU cores. This makes the operating system well suited for high-performance computing tasks from data center servers to high-end gaming and content creation applications.</li>
<li><code>Secure</code>: Security is a core design principle of modern Windows. Every object has an <code>Access Control List</code> (ACL) that specifies user permissions, and the <code>NT File System</code> (NTFS) supports ACLs on individual files and folders. Modern versions also include built-in encryption features, such as <code>BitLocker</code>, and continuous support for security features and other upgrades to protect against modern threats.</li>
<li><code>Compatible</code>: Windows 10 and 11 offer excellent backward compatibility. They can run a wide range of older applications, including those from previous Windows versions. The OS uses special isolation techniques to run legacy applications safely, preventing them from destabilizing the rest of the system.</li>
</ul>
<p>As we can see, Windows provides a number of features to provide a secure, easy, and reliable system for users to conduct a number of computer based activities. The remainder of this chapter will explore the more explicit details of how Windows is implemented.</p>
<h2 id="the-windows-executive"><a class="header" href="#the-windows-executive">The Windows Executive</a></h2>
<p>The <strong>Windows Executive</strong> is the core, kernel-mode layer of Windows that provides the fundamental operating-system services used by all programs and subsystems. It sits above the hardware-specific kernel layer and below user-mode code, acting as the main "engine" of the OS.</p>
<p>The Window Executive implements high-level OS services such as:</p>
<ul>
<li>Process and Thread Management</li>
<li>Memory Management</li>
<li>I/O and Device Management</li>
<li>Security and Access Control</li>
<li>Inter-Process Communication</li>
</ul>
<p>It is made up of many components, all kernel-mode subsystems, mostly implemented in <code>ntoskrnl.exe</code>:</p>
<ul>
<li><strong>The Object Manager</strong></li>
<li><strong>The Security Reference Monitor</strong> (SRM)</li>
<li><strong>The Process Manager</strong></li>
<li><strong>The Memory Manager</strong></li>
<li><strong>The I/O Manager</strong></li>
<li><strong>The Cache Manager</strong></li>
<li><strong>The Configuration Manager</strong></li>
<li><strong>The Plug And Play Manager</strong> (PnP)</li>
<li><strong>The Virtual Memory Manager</strong></li>
</ul>
<p>The function of these subsystems will be elaborated on as they come up.</p>
<p>User-Mode applications use the Win32 APIs to interact with the Windows Executive. This provides abstraction from hardware, enforces security and isolation, enables multitasking and stability, and makes Windows a hybrid-kernel not a microkernel since the kernel is not monolithic.</p>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<h3 id="virtual-memory-and-paging"><a class="header" href="#virtual-memory-and-paging">Virtual Memory and Paging</a></h3>
<p><code>Virtual Memory</code> is a memory management technique used by operating systems to provide the illusion of a much larger, contiguous block of main memory than is physically available, by using a portion of the secondary storage as an extension of the physical memory. It allows programs to run, even if they are larger than the available physical memory by mapping a program's virtual addresses to physical addresses in RAM.</p>
<p>Virtual Memory offers several key benefits:</p>
<ul>
<li><code>Multitasking</code>: more apps can run than RAM alone could allow</li>
<li><code>Memory Abstraction</code>: No need for developers to worry about memory size or fragmentation</li>
<li><code>Security</code>: Prevents apps from overwriting memory space that is not their own through isolation.</li>
</ul>
<p><code>Paging</code> is the most common memory management scheme used to implement virtual memory.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note"></a>
</div>
<div>
<ol>
<li><code>Fixed-size Blocks</code>: Both physical and virtual memory are divided into fixed-size blocks (pages for virtual, frames for physical).</li>
<li><code>Page Table</code>: A data structure managed by the operating system that keeps track of the mapping between a programs virtual pages and the physical frames where they are stored. Each process has its own Page Table, and each Page Table is stored in physical memory.</li>
<li><code>Page Faults</code>: Occurs when a program tries to access a virtual address that doesn't have a corresponding physical frame in RAM (because the page is currently stored on the disk)</li>
<li><code>Swapping</code>: When a page fault occurs, the operating system finds the required page in the paging file (<code>pagefile.sys</code> on Windows), loads it into an available physical frame, updates the page table, then allows the program to continue its execution. If no frames are free, an old one is paged into the paging file to make space.</li>
</ol>
</div>
</div>
<p><img src="https://hackmd.io/_uploads/rytLz9F6xg.png" alt="image" /></p>
<blockquote>
<p>Diagram of Virtual Memory and Paging</p>
</blockquote>
<h3 id="working-sets"><a class="header" href="#working-sets">Working Sets</a></h3>
<p><code>Working Set</code>: The set of pages that a process has recently referenced and currently reside in physical memory (<code>RAM</code>).</p>
<p>The working set of a process is used to determine said process's active use of physical memory and which pages have not been accessed in a while. Such pages can then be paged out to disk (<code>pagefile.sys</code>) and removed from the process's working set.</p>
<h3 id="section-objects"><a class="header" href="#section-objects">Section Objects</a></h3>
<p>A <code>Section Object</code> is a kernel object, which represents a region of memory that can be shared between multiple processes. They can be mapped to multiple places, making them a convenient tool for applications to share memory between them. In fact, the system uses section objects to share memory between the kernel and user-mode processes. A section is mapped into both the kernel address space and one or more user-mode address spaces.</p>
<p>There are two basic types of section object:</p>
<ul>
<li><code>Pagefile-Backed</code>: An empty section of virtual memory that can be used for temporary storage of information and is usually created to share data between two processes or between applications and the kernel.</li>
<li><code>File-Backed</code>: A region of virtual memory directly associated with a specific file on disk ,used as a convenient way of accessing a file using a pointer, rather that APIs, such as <code>ReadFile</code> and <code>WriteFile</code>.
<ul>
<li>Systems use file-backed section objects for a variety of purposes, including the loading of executable images.</li>
</ul>
</li>
</ul>
<p>Sometimes, a <code>Section Object</code> is referred to as a <strong>File Mapping Object</strong>. They are created for a number of reasons, including:</p>
<ul>
<li><code>Image Loading</code>: When a new process is created, it must allocate space within virtual memory for the contents of the main executable file (<code>.exe</code>) and any shared libraries it uses (<code>.dll</code>). A section object is created for each of these files, so that the actual <code>.exe</code> or <code>.dll</code> does not have to be accessed directly, using the <code>ReadFile</code> and <code>WriteFile</code> Win32 API functions.</li>
<li><code>Inter-Process Communication</code>(IPC): Pagefile-backed section objects provide an inexpensive way for processes to share information with one another, without frequently transitioning to kernel-mode.</li>
<li><code>Anonymous Memory Allocation</code>: When a process uses a function, like <code>VirtualAlloc</code> for anonymous memory, Windows typically backs it with an unnamed, pagefile-backed section object.</li>
</ul>
<h3 id="kernel-memory-and-user-memory"><a class="header" href="#kernel-memory-and-user-memory">Kernel Memory and User Memory</a></h3>
<p>The principle of separating <code>kernel memory</code> and <code>user memory</code> is a cornerstone of modern operating systems. This distinction ensures stability, security, and integrity for the system. By preventing user-mode applications from directly accessing the core data structures of the OS, we protect the system from bugs and malicious software that could otherwise cause crashes or grant unauthorized control of the system.</p>
<p>Modern, 64-bit Windows systems have a vastly different memory architecture than their predecessors, as their 64-bit system offers a theoretical address space of 2⁶⁴ bytes. The total virtual address space is logically divided into two distinct regions:</p>
<ul>
<li><code>User-Mode Memory</code>: The memory space allocated for each individual process.
<ul>
<li>Every process has its own isolated, private user-mode address space, making it so that a bug in one app's memory will not affect other apps, or the operating system itself.</li>
</ul>
</li>
<li><code>Kernel-Mode Memory</code>: Memory space reserved for the operating system, kernel, device drivers, and other system-level components.</li>
</ul>
<p>Modern processors and operating systems support a very large virtual address space, typically up to 128 TB for user-mode applications and 128 TB for kernel-mode components.</p>
<p>The separation of these two regions ensures that the kernels critical functions and data structures are always secure and available. The kernel code and data are always mapped into the support portion of every process's address space. This allows the OS to handle system calls and interrupts efficiently, without having to switch memory contexts.</p>
<h4 id="the-kernel-memory-space"><a class="header" href="#the-kernel-memory-space">The Kernel Memory Space</a></h4>
<p>The 128 TB allocated for kernel mode components is not statically allocated, as most components have a dynamic size that can be determined in runtime based on the physical memory available and the many user-configurable registry keys that are needed. Some of these components include:</p>
<ul>
<li><code>Paged Pool</code>: Kernel memory pool used to store data structures which can be paged out if the system is under memory pressure, including:
<ul>
<li>Object Handles</li>
<li>Registry Hives</li>
<li>System Driver Data</li>
</ul>
</li>
<li><code>Nonpaged Pool</code>: Kernel memory pool used to store data structures which must remain in physical RAM for as long as they are allocated.
<ul>
<li>This section is used for data, which must be accessible at all times, including:
<ul>
<li>Interrupt Service Routines (<code>ISRs</code>) and Deferred Procedure Calls (<code>DPCs</code>)
<ul>
<li>These structures cannot handle page faults</li>
</ul>
</li>
<li>Thread and Process Objects</li>
<li>I/O Request Packets (<code>IRPs</code>)</li>
<li>Synchronization Objects (<code>events</code>, <code>mutexes</code>, <code>semaphores</code>, etc.)</li>
</ul>
</li>
</ul>
</li>
<li><code>System Cache</code>: The section of kernel-memory used to cache file data from the disk. When an application reads from a file, the memory manager may copy the file data into the system cache to speed up subsequent reads by the same or other applications.</li>
<li><code>Terminal Services Session Space</code>: In a multi-user environment (like Remote Desktop Services), each user session has its own isolated session space in kernel memory. This space contains session-specific data ns for components which require isolation between user actions, such as <code>win32k.sys</code>, which manages the graphical user interface.</li>
<li><code>Page Tables</code>: A mapping to kernel-managed data structures stored in physical memory that describe how each process’s virtual addresses are translated into physical memory addresses. On modern 64-bit architectures, these tables are organized hierarchically (e.g., multi-level page tables) to efficiently represent large address spaces while conserving memory.</li>
<li><code>Hyper Space</code>: A small reserved, process-private region of the kernel's address space used to map pages on a temporary basis. For example, during page fault handling, this space is used to move data between the paging file and physical memory.</li>
<li><code>System Working Set</code>: The pages of the kernel and its components that are in RAM.</li>
<li><code>System Page-Table Entries (PTEs)</code>: Entries within page tables that contain the mapping from a virtual page to a physical frame.</li>
</ul>
<h5 id="vads-and-vad-trees"><a class="header" href="#vads-and-vad-trees">VADs and VAD Trees</a></h5>
<p>A <code>Virtual Address Descriptor</code> is a kernel data structure that describes a contiguous region of memory within a process's virtual address space. Each one is represented by a <code>_MMVAD</code> structure, which is used by the Windows Memory Manager to keep track of every reserved or committed range of virtual memory within a process's address space.</p>
<p>A <code>VAD Tree</code> describes the collection of all <code>_MMVAD</code> structures within a process, organized into a self-balancing binary search tree. It makes it possible to quickly identify a specific virtual memory address within a process's virtual memory space.</p>
<p>The <code>_MMVAD</code> structure is not officially documented, but it has been reverse engineered, with a set of particularly useful versions being published through the Vergilius Project. The <code>Vergilius Project</code> provides information about kernel structures, unions, and enumerations from publicly available Program Database (<code>.pdb</code>) files, most of which are not officially documented and cannot be found in the Windows Driver Kit (<code>WDK</code>) headers.</p>
<p>Here is the <code>Windows 11 23H2 (Nickel R2)</code> version of the <code>_MMVAD</code> structure's signature:</p>
<pre><code class="language-C">typedef struct _MMVAD
{
    struct _MMVAD_SHORT Core;
    struct _MMVAD_FLAGS2 VadFlags2;
    struct _SUBSECTION* Subsection;
    struct _MMPTE* FirstPrototypePte;
    struct _MMPTE* LastContiguousPte;
    struct _LIST_ENTRY ViewLinks;
    struct _EPROCESS* VadsProcess;
    union
    {
        struct _MI_VAD_SEQUENTIAL_INFO SequentialVa;
        struct _MMEXTEND_INFO* ExtendedInfo;
    } u4;
    struct _FILE_OBJECT* FileObject;
};
</code></pre>
<p>Every part of the <code>_MMVAD</code> structure is not relevant to our discussion here, but some parts of interest include:</p>
<ul>
<li><code>typedef struct</code>: a combination of <code>C</code> keywords, which define an alias for an existing type, then join a set of variables under that new name.</li>
</ul>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-1"></a>
</div>
<div>
<p><strong>Using <code>typedef struct</code></strong>
In <code>C</code>, a <code>struct</code> lets you group different variables under one name, like so:</p>
<pre><code class="language-C">struct Point {
    int x;
    int y;
};
</code></pre>
<p>You can then create instances of the structure, <code>Point</code>, as follows:</p>
<pre><code class="language-C">struct Point p1;
p1.x = 1;
p1.y = 2;
</code></pre>
<p>By including <code>typedef</code>, you can create new instances by simply providing the structure's alias, like so:</p>
<pre><code class="language-C">typedef struct Point {...};
Point p2;
p2.x = 1;
p2.y = 2;
</code></pre>
</div>
</div>
<ul>
<li><code>_MMVAD_SHORT</code>: A critical, embedded structure which contains the essential components of the VAD. More on this later.</li>
<li><code>_MMVAD_FLAGS2</code>: A 32-bit set of field flags used to control and track the VAD's state.</li>
<li><code>_SUBSECTION</code>: A pointer to the Subsection structure, which describes how the memory region is backed by a Section Object and, ultimately, a file on disk.
<ul>
<li>If this pointer is NULL, the memory is typically backed by the page file.</li>
</ul>
</li>
<li><code>_MMPTE</code>: (Memory Manager Page Table Entry) A Windows kernel structure that represents a single page table entry (PTE) used by the Memory Manager (MM) to describe if or how a virtual page is mapped to physical memory.
<ul>
<li><code>FirstPrototypePte</code> and <code>LastContiguousPte</code> contain pointers which define the start and end of the <code>Prototype Page Table Entries</code> list. This list tells the Memory Manager where to find the content for every page within the VADs <code>Virtual Page Number</code> (<strong>VPN</strong>) range.</li>
</ul>
</li>
<li><code>union {...} u4;</code>: A C language construct, which declares an anonymous union type, then defines a variable or field named u4 of that type.
<ul>
<li><code>VadsProcess</code> is the <code>_EPROCESS</code> kernel object that the VAD belongs to.</li>
</ul>
</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-2"></a>
</div>
<div>
<p>A <code>union {...} name;</code> is a special data structure, which allows a developer to store different data types within the same memory location. This means that the <code>union</code> construct is only as large as its largest member.</p>
<p>For example:</p>
<pre><code class="language-C">union {
    int IntegerValue;
    float FloatValue;
    char Bytes[10];
} age;
</code></pre>
<p>Creates an anonymous union construct, which can be either an <code>Integer</code>, a <code>Float</code>, or a <code>Character String</code> (up to 4-bytes). This construct is then assigned to a variable, <code>age</code></p>
<p>You can set the value of a union construct like so:</p>
<pre><code class="language-C">...
age.IntegerValue = 20;
age.FloatValue = 20.0;
strcpy(age.Bytes, "twenty");
</code></pre>
<p>But, <strong>only one member should be set and read at a time</strong>. Reading a different member than the one that was last written will read the memory space of the <code>union</code> construct as the data type of the member you attempted to read:</p>
<pre><code class="language-C">...
printf("The value of union is %i", age.IntegerValue);
// This will output "1852143476", since it is equivalent to "twen" in decimal
</code></pre>
<p>You can also create named unions and use <code>typedef</code> to streamline their creation:</p>
<pre><code class="language-C">union Age{
    unsigned int IntegerValue;
    float FloatValue;
    char Bytes[10];
};

union Age a;
a.IntegerValue = 20;

typedef union Year{
    UINT IntegerValue;
    ULONG LongValue;
    char Bytes[30];
}

Year y;
strcpy(y.Bytes, "two-thousand twenty-five");
</code></pre>
</div>
</div>
<ul>
<li><code>_EPROCESS*</code>: a pointer to a Windows kernel structure, which represents a process.</li>
<li><code>_FILE_OBJECT*</code>: a pointer to a Windows kernel object that represents an open file or device.
<ul>
<li><code>FileObject</code> is a pointer to the kernel object that represents the file on disk representing that particular VAD. <code>NULL</code> if the VAD is private (pagefile-backed or physical memory only).</li>
</ul>
</li>
</ul>
<p>The core components of <code>_MMVAD</code> are housed in it's <code>Core</code> attribute, which is a <code>_MMVAD_SHORT</code> type structure. <code>_MMVAD_SHORT</code> is essential for maintaining the VAD Tree and describing the memory regions basic properties.</p>
<p>Here is the <code>Windows 11 23H2 (Nickel R2)</code> version of the <code>_MMVAD_SHORT</code> structure's signature:</p>
<pre><code class="language-C">typedef struct _MMVAD_SHORT
{
    union
    {
        struct
        {
            struct _MMVAD_SHORT* NextVad;
            VOID* ExtraCreateInfo;
        };
        struct _RTL_BALANCED_NODE VadNode;
    };
    ULONG StartingVpn;
    ULONG EndingVpn;
    UCHAR StartingVpnHigh;
    UCHAR EndingVpnHigh;
    UCHAR CommitChargeHigh;
    UCHAR SpareNT64VadUChar;
    volatile LONG ReferenceCount;
    struct _EX_PUSH_LOCK PushLock;
    union
    {
        ULONG LongFlags;
        struct _MMVAD_FLAGS VadFlags;
        struct _MM_PRIVATE_VAD_FLAGS PrivateVadFlags;
        struct _MM_GRAPHICS_VAD_FLAGS GraphicsVadFlags;
        struct _MM_SHARED_VAD_FLAGS SharedVadFlags;
        volatile ULONG VolatileVadLong;
    } u;
    ULONG CommitCharge;
    union
    {
        struct _MI_VAD_EVENT_BLOCK* EventList;
    } u5;
};
</code></pre>
<p>Every part of the <code>_MMVAD_SHORT</code> structure is not relevant to our discussion here, but some parts of interest include:</p>
<ul>
<li>
<p><code>VOID*</code>: A void pointer to memory address for some data with no defined data type. * <code>ExtraCreateInfo</code> is used to temporarily store metadata about the VAD while it is being created.</p>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-3"></a>
</div>
<div>
<p><code>_MMVAD_SHORT.NextVad</code> and <code>_MMVAD_SHORT.CreateExtraInfo</code> are typically <strong>used when a batch of related VADs need to be created, split, or merged all at once</strong>. Instead of manipulating the VAD tree directly, <strong>it is easier to link the VADs in question together in a simple, temporary linked list</strong>.</p>
</div>
</div>
</li>
<li>
<p><code>_RTL_BALANCED_NODE</code>: A Windows Kernel Data Structure that represents a node in a balanced binary tree. More on this later.</p>
</li>
<li>
<p><code>ULONG</code>: Initializes an unsigned long integer value. A <code>typedef</code> alias for the standard C <code>unsigned long int</code> data type.</p>
<ul>
<li><code>StartingVpn</code> contains the first <strong>Virtual Page Number</strong> (<code>VPN</code>) in the memory region described by the VAD.</li>
<li><code>EndingVpn</code> contains the last <code>VPN</code> in that region.</li>
<li><code>CommitCharge</code> represents the number of <strong>committed</strong> pages within the address space described by the VAD.</li>
</ul>
</li>
<li>
<p><code>UCHAR</code>: Initializes an unsigned character value. A <code>typedef</code> alias for the standard C <code>unsigned char</code> data type. An <code>unsigned char</code> allows you to deal with the raw bytes of the memory region, avoiding negative values (i.e., <code>0xFF</code> should be <code>255</code>, not <code>-1</code>).</p>
<ul>
<li><code>StartingVpnHigh</code> contains the upper bits of <code>StartingVpn</code> for 64-bit addresses.</li>
<li><code>EndingVpnHigh</code> contains the upper bits of <code>EndingVpn</code> for 64-bit addresses</li>
<li><code>CommitChargeHigh</code> contains the upper bits of the <code>CommitCharge</code> value to form a 64-bit Commit Charge value.</li>
<li><code>SpareNT64VadUChar</code> contains a single byte, reserved for future use.</li>
</ul>
</li>
<li>
<p><code>volatile</code>: A type qualifier that notifies the compiler that the defined memory region may be accessed at any time outside of the program's control and access to it should not be optimized.</p>
</li>
</ul>
<p><code>_MMVAD</code> represents a single node in a VAD Tree and <code>_MMVAD_SHORE</code> initializes the core components of that node, but <code>_RTL_BALANCED_NODE</code> is responsible for adding the VAD Tree node in the correct place and maintaining the balance of the tree.</p>
<p>Here is the <code>Windows 11 24H2 (Germanium)</code> version of the structure:</p>
<pre><code class="language-C">struct _RTL_BALANCED_NODE
{
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];                             //0x0
        struct
        {
            struct _RTL_BALANCED_NODE* Left;                                //0x0
            struct _RTL_BALANCED_NODE* Right;                               //0x8
        };
    };
    union
    {
        struct
        {
            UCHAR Red:1;                                                    //0x10
            UCHAR Balance:2;                                                //0x10
        };
        ULONGLONG ParentValue;                                              //0x10
    };
};
</code></pre>
<p>Each process, <code>EPROCESS</code> contains a pointer to the root of it's VAD Tree object. Using <code>Runtime Library</code>(<strong>RTL</strong>), tree helper functions (i.e., <code>RtlInitializeGenericTable()</code>, <code>RtlRbInsertNodeEx()</code>, and <code>RtlIsRoot()</code>), the kernel is able to navigate, manipulate, and delete the VAD Tree.</p>
<h4 id="user-mode-vs-kernel-mode-memory-space"><a class="header" href="#user-mode-vs-kernel-mode-memory-space">User-Mode vs. Kernel Mode Memory Space</a></h4>
<ul>
<li><code>User-Mode Memory Space</code>:
_ <code>Location</code>: The user-mode memory occupies the lower half of the virtual address space. This is typically from <code>0x00000000'00000000</code> to <code>0x00007fff'ffffffff</code> on a 64-bit system.
_ <code>Isolation</code>: Each process has its own unique, private user-mode address space. The memory manager uses page tables to map the virtual addresses of a process to physical frames in RAM. * <code>Protection</code>: The Memory Management Unit (MMU) is configured to prevent a user-mode process from accessing any address in the kernel-mode region.</li>
</ul>
<div id="admonition-note-4" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-4-title">
<div class="admonition-title">
<div id="admonition-note-4-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-4"></a>
</div>
<div>
<p>The <strong>Memory Management Unit</strong> (MMU) is the hardware subsystem of the CPU responsible for:</p>
<ul>
<li>Translating virtual addresses into physical addresses</li>
<li>Enforcing memory protection and access rights</li>
<li>Managing caching and paging mechanisms used by the operating system.</li>
</ul>
<p>All under the supervision of the Windows kernel’s Memory Manager component.</p>
</div>
</div>
<ul>
<li><code>Kernel-Mode Memory Space</code>:
<ul>
<li><code>Location</code>: The kernel-mode memory space occupies the upper half of the virtual address space. This typically extends from <code>0xFFFF8000'00000000</code> to <code>0xFFFFFFFF'FFFFFFFF</code>.</li>
<li><code>Shared</code>: Kernel-mode virtual address space is shared by all processes. No matter which user-mode process is currently running, the kernel's code, data, and device drivers are always mapped into it's virtual address space at the same logical location.</li>
<li><code>Protected</code>: Even though this address space is shared, it is not accessible to user-mode code. The CPU's ring-based protection model ensures that only code running in kernel mode (<code>ring 0</code>) can access these addresses. User-mode code (<code>ring 3</code>) is explicitly denied access.</li>
</ul>
</li>
</ul>
<p>Every process has a set of page tables that map its virtual address space to physical memory. Importantly, these page tables are stored in kernel-mode memory. While the user-mode entries in these page tables are unique, the kernel-mode addresses are the same for all processes. When a new process is created, its page tables are initialized with a copy of the kernel's page table entries, ensuring the kernel is always mapped.</p>
<p>Current x64 CPUs only implement a subset of the total 64-bits for virtual memory addresses (typically 48 or 57 bits). For a 48-bit implementation, the user-mode addresses are canonical addresses where the 47th bit is 0, so all bits from 48-63 are also 0. Kernel-mode addresses are canonical addresses where the 47th bit is 1, so all bits from 48 to 63 are also 1.</p>
<p>The space between user-mode and kernel-mode memory regions is a non-canonical address space. This space is intentionally left empty and any attempt to access it triggers an exception, typically resulting in process termination.</p>
<h4 id="the-user-memory-space"><a class="header" href="#the-user-memory-space">The User Memory Space</a></h4>
<p>Every application is different, but they are basically using memory in the following forms:</p>
<ul>
<li><code>Private Allocations</code>: Occur when an application requests a memory block using the <code>VirtualAlloc</code> Win32 API. Allocates whole pages and nothing smaller.</li>
<li><code>Heap Allocations</code>: Allocated using a runtime library function such as <code>malloc</code> or by calling a system heap API such as <code>HeapAlloc</code>. Allocates multiple, variable-sized blocks as required for ad-hoc memory needs.
<ul>
<li>An application may implement its own heaps by directly allocating private blocks using <code>VirtualAlloc</code>.</li>
</ul>
</li>
<li><code>Stack Allocations</code>: FIFO memory allocations. Generally contains function parameters, the return address, the base stack address (for previous stack frames), and local variables.
<ul>
<li>Automatically allocated by the system for every thread while it's being created.</li>
</ul>
</li>
<li><code>Executables</code>: The mapped executable's location in memory.</li>
<li><code>Mapped Views</code>(<strong>Sections</strong>): Section Objects
<ul>
<li>Used to share memory between two or more programs.</li>
</ul>
</li>
</ul>
<h2 id="memory-management-apis"><a class="header" href="#memory-management-apis">Memory Management APIs</a></h2>
<p>The Windows Virtual Memory Manager is accessible to application programs using a set of <strong>Win32 APIs</strong> that can directly allocate and free memory blocks in user-mode address space.</p>
<p>Some of the most used <code>Win32</code> low-level memory management APIs are:</p>
<ul>
<li><code>VirtualAlloc</code>/<code>VirtualAllocEx</code>: Used to allocate private memory blocks within a process's user-mode address space.
<ul>
<li>The size of the allocation must be a multiple of the system's page size (typically <code>4KB</code> or larger).</li>
<li>Can be used to either reserve a range of virtual addresses or to commit that range to physical storage.</li>
<li>The <code>Ex</code> variant allows a privileged process to operate on the address space of another process.</li>
</ul>
</li>
<li><code>VirtualProtect</code>/<code>VirtualProtectEx</code>: Sets a memory region's protection attributes (<code>RWX</code>). Modern processes support a <code>No-Execute</code>(<code>NX</code>) bit, which the OS uses to prevent the execution of code from the <code>.data</code> section.
<ul>
<li>The <code>Ex</code> variant allows a process to modify the permissions of another process's memory space.</li>
</ul>
</li>
<li><strong>Cross-Process Memory Access</strong>: Windows provides a set of APIs for privileged processes to read or write to the address space of another process.
<ul>
<li><code>ReadProcessMemory</code></li>
<li><code>WriteProcessMemory</code></li>
</ul>
</li>
<li><strong>Section Object APIs</strong>:
<ul>
<li><code>CreateFileMapping</code>: Creates a section object, which can be pagefile or file backed for shared memory.</li>
<li><code>MapViewOfFile/MapViewOfFileEx</code>: Allows you to take a section object and map it into the address space the calling process.</li>
<li><code>UnmapViewOfFile</code>: Unmaps a previously mapped view, freeing up the virtual address range.</li>
</ul>
</li>
</ul>
<h2 id="object-handle"><a class="header" href="#object-handle">Object Handle</a></h2>
<p>The <code>Object Manager</code> is a windows kernel component responsible for creating, managing, naming, referencing, and deleting all kernel objects (such as sections, file and device objects, synchronization objects, processes and threads) in a centralized location. An <code>Object Handle</code> is a process specific identifier used by user-mode applications to reference objects.</p>
<p>When an application requests a new object (i.e., creating a new thread) the Object Manager returns a <strong>handle</strong>, which is an index into the process's private <strong>handle table</strong>. Each entry in the handle table contains a pointer to the actual underlying kernel object and an associated access mask, which defines the operations the process is able to perform on the object with that specific handle (<strong>RWX</strong>).</p>
<p>Objects themselves are data structures store in the non-paged pool of kernel memory. Every kernel object has:</p>
<ul>
<li>a standardized header that contains basic properties, including:
_ the reference count
_ the handle count
<blockquote>
<p>An object is only deleted when its reference count and handle count both drop to zero.</p>
</blockquote>
</li>
</ul>
<p>Kernel programs can directly access kernel objects using pointers, but user-mode applications must always use handles.</p>
<p><img src="https://hackmd.io/_uploads/Hyf81xXRgx.png" alt="image" /></p>
<blockquote>
<p>Diagram of <code>Process Handle Table</code> and <code>Object Manager Objects</code></p>
</blockquote>
<h2 id="named-objects"><a class="header" href="#named-objects">Named Objects</a></h2>
<p>Some kernel objects can be named, providing a way to uniquely identify them across a system. For instance, when creating a mutex object, an app can assign it a name, If another app attempts to create a mutex with the same name, the kernel will locate the existing object instead of creating a new one, ensuring both processes are referencing the same object.</p>
<p>Named Objects are arranged in virtual memory as hierarchical directories, but the Win32 API restricts user-mode applications' access to these directories.</p>
<p>Some of the most interesting directories are:</p>
<ul>
<li>
<p><code>\BaseNameObjects</code>: Where all conventional Win32 named objects, such as mutexes, are stored. When applications need to synchronize their actions or share data, they create or open named objects in this directory.</p>
</li>
<li>
<p><code>\Devices</code>: A logical representation of all active system devices, whether they are physical (like a hard drive) or logical (like a network card or a console session)</p>
</li>
<li>
<p><code>Global</code> (prev.<code>Global??</code>): The symbolic link directory. Critical for how user-mode applications access devices and other named objects. The symbolic link serves as a high-level, human readable alias for a kernel object's real name.</p>
<div id="admonition-note-5" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-5-title">
<div class="admonition-title">
<div id="admonition-note-5-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-5"></a>
</div>
<div>
<p><strong>For Example</strong>:
When an application tries to access <code>C:</code>, the Windows subsystem (i.e., <code>NTDLL</code>) resolved this symbolic link to its target in the <code>\Device</code> directory (i.e., the hard drive).</p>
</div>
</div>
</li>
</ul>
<p>Some kernel objects, (like threads) are unnamed and can only be identified by their handles or kernel object pointers.</p>
<h2 id="processes-and-threads"><a class="header" href="#processes-and-threads">Processes and Threads</a></h2>
<p>A <strong>Process</strong> is many things, but predominantly it is an isolated memory address space that can be used for running a program. These address spaces are created for each program in order to make sure they run in their own address space. In order to run a program, a process must have at least one thread.</p>
<p>A process also represents a running application, and is a protected, isolated container. It is given its own isolated virtual address space that is mapped to a specific executable image. Essentially, it is a resource container, owning resources such as handles, files, synchronization objects, and thread. It does nothing, it is simply a container.</p>
<p>A <strong>Thread</strong> is a primitive execution unit. It is a data structure that has a<code>context</code> data structure, which tells the system the state of the processor when the thread last ran, combined with one or two memory blocks that are used for stack space. The physical processor switches between multiple virtual processes, and always starts execution from the threads current context information using the threads stack.</p>
<p>The thread does work within a process and therefore a process needs at least one, but can have multiple. All threads within a single process share a virtual address space, but each thread has its own <code>CONTEXT</code>, including its own stack and CPU registers.</p>
<p><strong>Context Switching</strong> is the mechanism by which the Windows Scheduler interrupts a running thread and saves its state so that another thread can run. This happens very rapidly to create the illusion of concurrency/parallelism.</p>
<p>The following steps are performed:</p>
<ol>
<li><strong>Save the State</strong>: The CPU's registers, the stack, and the instruction pointer of the running process are saved within the Threa's <code>CONTEXT</code> block.</li>
<li><strong>Restore the State</strong>: The saved state of another thread, which the scheduler has chosen to run next, is loaded into the CPU's registers.</li>
<li><strong>Resume Execution</strong>: The new thread begins execution at the saved instruction pointer (where it left off previously).</li>
</ol>
<p>Context switching happens frequently and sometimes a thread will relinquish control voluntarily. For instance, when a program calls the <code>GetMessage</code> Win32 API, <code>GetMessage</code> will access a message queue and extract the next event to determine if the user has generated any new input events. If there aren't any new events, <code>GetMessage</code> enters a waiting state and doesn't return until a new input event comes in. When <code>GetMessage</code> enters a waiting state, the CPU will switch context.</p>
<p>Context switching also happens by default due to preemptive scheduling. Threads are given a limited amount of time to execute before they are interrupted. Every thread is assigned a <strong>quantum</strong>, which is the maximum amount of time a thread is allowed to run continuously. A low-level hardware timer is used to monitor how long the thread has been running. Once the quantum has expired, the thread is temporarily interrupted to allow other threads to execute. If no other threads need to execute, the interrupted thread immediately resumes execution.</p>
<h3 id="a-low-level-look-at-process-objects"><a class="header" href="#a-low-level-look-at-process-objects">A Low-Level Look at Process Objects</a></h3>
<p>A developer can reference a process by its name, its PID or its handle. Ultimately, the handle is translated by the owning process's Process Handle Table into a pointer value for the referenced process's kernel object. This object, known as an <code>_EPROCESS</code> object, takes on the following form:</p>
<pre><code class="language-C">typedef struct _EPROCESS {
    struct _KPROCESS Pcb;
    struct _EX_PUSH_LOCK ProcessLock;
    VOID* UniqueProcessId;
    struct _LIST_ENTRY ActiveProcessLinks;
    union _LARGE_INTEGER CreateTime;
    struct _LIST_ENTRY SessionProcessLinks;
    struct _PEB* Peb;
    struct _HANDLE_TABLE* ObjectTable;
    struct _FILE_OBJECT* ImageFilePointer;
    VOID* DebugPort;
    UCHAR ImageFileName[15];
    struct _LIST_ENTRY ThreadListHead;
    volatile ULONG ActiveThreads;
    union _LARGE_INTEGER ReadOperationCount;
    union _LARGE_INTEGER WriteOperationCount;
    union _LARGE_INTEGER OtherOperationCount;
    struct _RTL_AVL_TREE VadRoot;
    struct _PS_PROTECTION Protection;
    union _PROCESS_EXECUTION Execution;
} EPROCESS, *PEPROCESS;
</code></pre>
<blockquote>
<p>This is a truncated version of the object. Full object details can be found here: <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_EPROCESS">Vergilus Project: _EPROCESS Object Windows 11 25H2</a></p>
</blockquote>
<p>Here is a breakdown of what's happening:</p>
<ul>
<li><code>_KPROCESS Pcb</code>: The Kernel Process Block, which is responsible for the scheduler related portion of the process. It gives the Windows Dispatcher the information it needs to know which threads can run and under what conditions. This includes:
<ul>
<li>CPU‑affinity mask (which cores the process may run on)</li>
<li>Quantum (time‑slice) value for the process’s threads</li>
<li>Links that place the process’s threads on the per‑CPU ready queues</li>
</ul>
</li>
<li><code>_EX_PUSH_LOCK ProcessLock</code>: A synchronization object used to manage access to the <code>_EPROCESS</code> object.</li>
<li><code>VOID* UniqueProcessId</code>: The <strong>PID</strong> value</li>
<li><code>_LIST_ENTRY ActiveProcessLinks</code>: Links the current process into the system wide <strong>process-list</strong>, which keeps track of all live (non-terminated) processes in a doubly-linked list.</li>
<li><code>_LARGE_INTEGER CreateTime</code>: The time the process was created.</li>
<li><code>_LIST_ENTRY SessionProcessLinks</code>: Links the current process into the logon-session wide process-list, which keeps track of all live (non-terminated) processes spawned within the same logon-session in a doubly-linked list.</li>
<li><code>_PEB* Peb</code>: A pointer to a user-mode data structure, which contains data about environment variables, loaded modules, command-line arguments, and other usefule information that the application can access directly.</li>
<li><code>_HANDLE_TABLE* ObjectTable</code>: A pointer to the process's Process Handle Table.</li>
<li><code>VOID* DebugPort</code>: A pointer used to track whether a process is being debugged, and if so which kernel debugging object it is attached to.</li>
<li><code>_FILE_OBJECT* ImageFilePointer</code>: A pointer to the kernel FILE_OBJECT for the executable image.</li>
<li><code>UCHAR ImageFileName[15]</code>: The executable's filename.</li>
<li><code>_LIST_ENTRY ThreadListHead</code>: The head of the linked list containing all <code>_ETHREAD</code> objects belonging to this process.</li>
<li><code>volatile ULONG ActiveThreads</code>: The total number of running threads.</li>
<li><code>_LARGE_INTEGER [...]OperationCount</code>: The total number of (read/write/other) I/O operations.</li>
<li><code>_RTL_AVL_TREE VadRoot</code>: The root of the VAD Tree.</li>
<li><code>_PS_PROTECTION Protection</code>: The protection level of the process (more on this later)</li>
<li><code>_PROCESS_EXECUTION Execution</code>: The execution-state hub of <code>_EPROCESS</code> that informs the kernel whether the process may run, how long it has run, whether it is currently frozen, and whether special execution‑related attributes (debugged, protected, etc.) apply.</li>
</ul>
<p>In reality, the <code>_EPROCESS</code> object is much larger, but this truncated version covers the details that are most important to us currently.</p>
<h3 id="a-low-level-look-at-thread-objects"><a class="header" href="#a-low-level-look-at-thread-objects">A Low-Level Look at Thread Objects</a></h3>
<p>One such detail is the <code>_LIST_ENTRY ThreadListHead</code> attribute, which is the head of a circular doubly-linked list of <code>_ETHREAD</code> kernel objects belonging to the process. This object takes on the following form:</p>
<pre><code class="language-C">typedef struct _ETHREAD {
    struct _KTHREAD Tcb;
    union _LARGE_INTEGER CreateTime;
    union {
        struct _KSEMAPHORE KeyedWaitSemaphore;
        struct _KSEMAPHORE AlpcWaitSemaphore;
    };
    VOID* Win32StartAddress;
    struct _LIST_ENTRY ThreadListEntry;
    struct _CONTEXT* SetContextState;
} ETHREAD, *PETHREAD;
</code></pre>
<p>Here is a breakdown of what's happening:</p>
<ul>
<li>
<p><code>_KTHREAD Tcb</code>: The Kernel Thread Block, which is a low-level scheduling block containing priority, scheduler information, and the saved register state.</p>
</li>
<li>
<p><code>_LARGE_INTEGER CreateTime</code>: The time the thread was created.</p>
</li>
<li>
<p><code>_KSEMAPHORE [...]WaitSemaphore</code>: Part of a Union for specialized waiting mechanisms (Keyed Events and Advanced Local Procedure Call Semaphores).</p>
</li>
<li>
<p><code>VOID* Win32StartAddress</code>: Address of the thread’s start routine as supplied by the creating process (e.g., the function passed to <code>CreateThread</code> or the entry point of a newly created process).</p>
</li>
<li>
<p><code>_LIST_ENTRY ThreadListEntry</code>: allows the thread object to be linked into various kernel‑maintained thread lists.</p>
</li>
<li>
<p><code>_CONTEXT* SetContextState</code>: Pointer to the <code>CONTEXT</code> structure used to save/restore the thread's state during context switching (e.g., suspension, context switch, APC delivery)</p>
<div id="admonition-note-6" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-6-title">
<div class="admonition-title">
<div id="admonition-note-6-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-6"></a>
</div>
<div>
<p>To see what is saved as part of <code>CONTEXT</code>, take a look at the full object, <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/24h2/_CONTEXT">here</a>.</p>
</div>
</div>
</li>
</ul>
<h2 id="synchronization-objects"><a class="header" href="#synchronization-objects">Synchronization Objects</a></h2>
<p>Without a way to coordinate resource access amongst multiple threads, a system may be vulnerable to race conditions and data corruption. A <strong>Synchronization Object</strong> is a kernel object designed to help threads coordinate access to shared resources. There are 4 primary types:</p>
<ul>
<li><code>Mutexes</code>(<strong>Mutual Exclusions</strong>): A resource obtained to gain access to a shared resource, which can only be obtained by one thread at a time.
<ul>
<li>In practice, a thread will attempt to acquire the mutex for some shared resource. If it is already owned, the thread waits in a queue until the owning thread releases ownership.</li>
</ul>
</li>
<li><code>Events</code>: A type of synchronization object that can be set to either a signaled (<code>True</code>) state or a non-signaled (<code>False</code>) state.
<ul>
<li>In practice, a thread can wait on an event, which will cause it to pause until another thread sets the event to the signaled state.</li>
</ul>
</li>
<li><code>Semaphores</code>: A type of synchronization object that allows multiple threads to access a shared resource at a time. It maintains a counter which decrements when a thread acquires access to the resource and increments when a thread relinquishes access to the resource.
<ul>
<li>A semaphore with a maximum count of one is functionally the same as a mutex.</li>
<li>Once the count is 0, a thread requesting the protected resource will enter a wait state until the semaphore count is &gt;=1.</li>
</ul>
</li>
<li><code>Critical Sections</code>: A simplified, user-mode version of a mutex.
<ul>
<li>In practice, they are faster than a mutex because they do not require a switch to kernel-mode unless the resource is contested.</li>
</ul>
</li>
</ul>
<h2 id="the-process-initialization-sequence"><a class="header" href="#the-process-initialization-sequence">The Process Initialization Sequence</a></h2>
<p>The creation of a new process involves a series of steps to set up its virtual address space and load the necessary code. It generally operates as follows:</p>
<ol>
<li><strong>Create Address Space</strong>: Creates a new, fundamental, and isolated virtual address space for the new process. This is the first thing to happen after a process calls <code>CreateProcess</code>.</li>
<li><strong>Load <code>NTDLL.DLL</code></strong>: <code>CreateProcess</code> maps <code>NTDLL.DLL</code>, the operating system's core library, into the newly created address space, along with the main executable (<code>.exe</code>) file.</li>
<li><strong>Create Primary Thread</strong>: <code>CreateProcess</code> creates the process's first thread and allocates stack space for it.</li>
<li><strong>Execute <code>LdprInitialize</code></strong>: When the primary thread begins execution, it calls the <code>LdrpInitialize</code> from <code>NTDLL.DLL</code>.
<ul>
<li><code>LDRPInitialize</code>: (<strong>LoaDeR Private</strong>) Used to prepare a program to run by loading and initializing various components.</li>
</ul>
</li>
<li><strong>Load Dependencies</strong>: <code>LdrpInitialize</code> recursively traverses the import tables of the primary executable and its loaded DLLs, then maps all required DLLs into the process's virtual address space.</li>
<li><strong>Call Initialization Routines</strong>:Control is passed to <code>LdrpRunInitializeRoutines</code>
<ul>
<li><code>LdrpRunInitializeRoutines</code>: initializes all static DLLs, which are currently loaded into the address space.</li>
<li>The initialization process consists of calling each DLL's entry point with the <code>DLL_PROCESS_ATTACH</code> constant set for <code>DWORD fdwReason</code> (more on this in <code>Malware Essentials</code>)</li>
</ul>
</li>
<li><strong>Transfer to Executable's Entry Point</strong>: Once all the DLLs are initialized, <code>LdrpInitialize</code> calls the thread's initialization process, which is the <code>BaseProcessorStart</code> function from <code>kernel32.dll</code>
<ul>
<li><code>kernel32.dll</code> calls the primary executable's <code>WinMain</code> entry point, completing the initialization process.</li>
</ul>
</li>
</ol>
<h2 id="application-programming-interfaces"><a class="header" href="#application-programming-interfaces">Application Programming Interfaces</a></h2>
<p>An <strong>Application Programming Interface</strong> (<code>API</code>) is a set of functions that the operating system makes available to application programs for communicating with the operating system. Here, we will review 3 APIs that are crucial to facilitating normal operations on modern Windows devices, <code>Win32</code>, <code>DirectX</code>, and <code>WinRt</code>.</p>
<h3 id="the-win32-api"><a class="header" href="#the-win32-api">The Win32 API</a></h3>
<p>The <code>Win32</code> API is the high-level, documented, and officially supported API that most application programmers use at some level. It is a very large set of functions that make up the official, low-level programming interface for Windows applications. It provides access to the features of Windows, including memory management, process and thread management, and GUI operations.</p>
<p>Typically, <code>Win32</code> is not used directly by programmers anymore, as simpler, higher-level interfaces have been developed that expose most of the features offered by the <code>Win32</code> API, such as:</p>
<ul>
<li><code>Microsoft Foundation Classes</code>(Legacy)(<strong>MFC</strong>): An object oriented wrapper over the <code>Win32</code> API implemented in C++. It simplifies GUI and message handling for native apps.</li>
<li><code>.NET Framework</code>: A managed framework with access to Windows Functionality via <code>P/Invoke</code> or <code>COM Interop</code>. Uses the <code>System</code> class for accessing operating system services.
<ul>
<li><code>System</code> is an interface into the <code>Win32</code> API.</li>
</ul>
</li>
</ul>
<p>Applications that use <code>Win32</code> are generally portable across different versions of Windows. We have reviewed a few functions in this API, including <code>CreateProcess</code>, <code>WriteProcessMemory</code>, and <code>VirtualAlloc</code>. Others include:</p>
<ul>
<li><code>LoadLibrary</code>: Maps a library into the virtual memory space of a process.</li>
<li><code>GetProcAddress</code>: Looks up the virtual address of a particular function within a loaded library/module.</li>
<li><code>GetModuleHandle</code>: retrieves a handle (<code>HMODULE</code>) to a module that is already loaded in the calling process’s address space.</li>
</ul>
<p>Most higher-level interfaces an application will employ use <code>Win32</code> for communicating with the Operating System. Some applications will use the low-level <code>Native</code> API, but this is rare.</p>
<p>There are thousands of APIs within the Core Win32 API, divided into many categories:</p>
<div class="table-wrapper"><table><thead><tr><th>Library/Subsystem</th><th>Approx. # of Functions</th></tr></thead><tbody>
<tr><td><code>kernel32.dll</code>: system core, memory, threads, files</td><td>~700-800</td></tr>
<tr><td><code>user32.dll</code>: windows, messages, UI controls</td><td>~500-600</td></tr>
<tr><td><code>gdi32.dll</code>: graphics</td><td>~400-500</td></tr>
<tr><td><code>advapi32.dll</code>: security, registry, services</td><td>~300-400</td></tr>
<tr><td><code>comdlg32.dll</code>: Common Dialogs</td><td>~100-200</td></tr>
<tr><td><code>shell32.dll</code>: shell, file operations</td><td>~300-400</td></tr>
<tr><td><code>ole32.dll</code>: COM runtime helpers, Marshaling</td><td>~200-300</td></tr>
</tbody></table>
</div>
<p>We will focus on 3 of these: <code>User</code>, <code>Kernel</code>, and <code>GDI</code>.</p>
<h4 id="kernel-apis"><a class="header" href="#kernel-apis">Kernel APIs</a></h4>
<p><code>Kernel</code> APIs are implemented in the <code>kernel32.dll</code> module and they include all non-GUI related services, such as file I/O, memory management, object management, process and thread management, etc.</p>
<p>Kernel APIs are used for creating and working with Kernel-level objects such as files, synchronization objects, etc. which are implemented in the systems object manager. <code>kernel32.dll</code> typically calls low-level Native APIs from <code>ntdll.dll</code> to implement various services, such as:</p>
<ul>
<li><strong>File Management</strong>: <code>CreateFile()</code></li>
<li><strong>Process Management</strong>: <code>CreateProcess()</code></li>
<li><strong>Memory Management</strong>: <code>VirtualAllocEx()</code></li>
<li><strong>Security &amp; Access Control</strong>: <code>GetTokenInformation()</code></li>
<li><strong>Miscellaneous</strong>: <code>GetEnvironmentVariable()</code></li>
</ul>
<h4 id="gdi-apis"><a class="header" href="#gdi-apis">GDI APIs</a></h4>
<p><code>GDI</code> APIs are implemented in the <code>gdi32.dll</code> module. They include low-level 2D graphics services such as:</p>
<ul>
<li><strong>Drawing a line</strong>: <code>LineTo()</code></li>
<li><strong>Displaying a Bitmap</strong>: <code>CreateBitmap()</code></li>
<li><strong>Creates/Ends Print Jobs</strong>: <code>StartDoc()</code>/<code>EndDoc()</code></li>
<li><strong>Device Contexts</strong>: <code>CreateDC()</code></li>
<li><strong>Brushes</strong>: <code>CreateSolidBrush()</code></li>
<li><strong>Pens</strong>: <code>CreatePen()</code></li>
</ul>
<p>The objects are managed by <code>win32k.sys</code> object managers, not the main kernel object manager.</p>
<div id="admonition-note-7" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-7-title">
<div class="admonition-title">
<div id="admonition-note-7-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-7"></a>
</div>
<div>
<p><code>win32k.sys</code> is a critical system driver responsible for managing core graphical and user interface functions for legacy programs. It can generally be found at: <code>C:\Windows\System32\drivers\win32k.sys</code></p>
<p>It is part of a larger family of <code>win32k</code> API's which made the function of the <code>win32k.sys</code> driver modular in Windows 10+. Other members of this family include:
<code>win32kbase.sys</code>: The base driver where all GDI requests are sent to. Capable of handling basic window management and input tasks.
<code>win32kfull.sys</code>: The full implementation of the GDI code base. Handles tasks that cannot be completed by <code>win32kbase.sys</code> alone, such as font rasterization, print rendering, and complex drawing.</p>
<p>They can be found at <code>C:\Windows\System32\win32kbase.sys</code> and <code>C:\Windows\System32\win32kfull.sys</code> respectively.</p>
</div>
</div>
<h4 id="user-apis"><a class="header" href="#user-apis">User APIs</a></h4>
<p><code>User</code> APIs are implemented in the <code>user32.dll</code> module and include all higher-level GUI-related services such as:</p>
<ul>
<li><strong>Window Management</strong>: <code>CreateWindow()</code></li>
<li><strong>Menus</strong>: <code>CreatePopupMenu()</code></li>
<li><strong>Dialog Boxes</strong>: <code>CreateDialogParam()</code></li>
<li><strong>UI Controls</strong>: <code>SetScrollInfo()</code></li>
</ul>
<div id="admonition-note-8" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-8-title">
<div class="admonition-title">
<div id="admonition-note-8-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-8"></a>
</div>
<div>
<p>All GUI objects are drawn by <code>USER</code> APIs using <code>GDI</code> API calls to perform the actual drawing.</p>
</div>
</div>
<div id="admonition-note-9" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-9-title">
<div class="admonition-title">
<div id="admonition-note-9-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-9"></a>
</div>
<div>
<p>On modern systems, while the <code>Win32k</code> family is used to handle basic 2D-rendering tasks, other APIs have taken on much of its responsibility. For instance, the DirectX API is used for more graphically intensive tasks.</p>
</div>
</div>
<h4 id="the-api-call-sequence"><a class="header" href="#the-api-call-sequence">The API Call Sequence</a></h4>
<p>When a user-mode application makes a <code>Win32</code> API call, a sequence of events occur to get the request to the kernel:</p>
<ol>
<li>An application module makes a call to a function in a <code>Win32</code> DLL (i.e., <code>kernel32.dll</code>, <code>user32.dll</code>, <code>gdi32.dll</code>)</li>
<li>The Win32 DLL then calls the corresponding function in the Native API interface, <code>ntdll.dll</code></li>
<li><code>ntdll.dll</code> uses a low-level instruction, such as a <code>syscall</code> to transition from user-mode to kernel-mode</li>
<li>The kernel then runs a service dispatch routine that looks up the requested function in the <code>ntoskrnl.exe</code> or <code>win32k.sys</code> service dispatch table and executes the corresponding kernel-mode code.</li>
</ol>
<p><img src="https://hackmd.io/_uploads/Sy9mcJtAxe.png" alt="image" /></p>
<blockquote>
<p>Diagram of <code>Win32</code> APIs relative to the Windows Kernel, <code>ntoskrnl.exe</code></p>
</blockquote>
<h3 id="the-directx-api"><a class="header" href="#the-directx-api">The DirectX API</a></h3>
<p>The <code>DirectX</code> API is a set of high-performance, low-level APIs specifically designed for gaming and multimedia applications. It provides tools for high-fidelity graphics and audio rendering. <code>DirectX</code> is a specialized API suite that is distinct from the general-purpose <code>Win32</code> API (specifically from <code>user32.dll</code> and <code>gdi32.dll</code>) as it provides a more direct path for applications to communicate with the GPU and sound hardware and abstracts the complexities of different hardware architectures, allowing developers to write code that works across a wide range of video and sound cards.</p>
<p>Some of the key APIs within <code>DirectX</code> are:</p>
<ul>
<li><code>Direct3D</code>: The API used for rendering 3D graphics.
<ul>
<li><code>Direct3D</code> provides a low-level interface to the graphics hardware, giving developers explicit control over the GPU pipeline for maximum performance.</li>
<li><strong>Key Concepts</strong>
<ul>
<li><code>Device Cteation</code>: Functions like <code>D3D12CreateDevice</code> are used to initialize the graphics device and get a handle to the GPU, setting the stage for all subsequent rendering operations.</li>
<li><code>Resource Management</code>: Direct3D manages various resources, such as vertex buffers (to store 3D model geometry) and textures (to apply images to surfaces).
<ul>
<li>Ex: <code>ID3D12GraphicsCommandList::IASetVertexBuffers()</code> is a function used to bind geometry data to the rendering pipeline</li>
</ul>
</li>
<li><code>Drawing Commands</code>: The core of Direct3D is its ability to issue drawing commands.</li>
</ul>
</li>
<li><code>Direct3D</code> can be found at <code>C:\Windows\System32\d3d12.dll</code> (previously <code>d3d11.dll</code> and <code>d3d9.dll</code>)</li>
</ul>
</li>
<li><code>Direct 2D</code>: The API for high-performance, hardware-accelerated 2D graphics.
<ul>
<li><code>Direct2D</code> is an evolution of <code>GDI</code>, designed for modern applications that need to render high-quality, scalable 2D content efficiently.</li>
<li><strong>Key Concepts</strong>
<ul>
<li><code>Factory Creation</code>: The first step in using <code>Direct2D</code> is to create a factory, using functions like <code>D2D1CreateFactory</code>. The <code>factory</code> is the starting point for creating all other <code>Direct2D</code> resources.</li>
<li><code>Render Target</code>: The <code>ID2D1HwndRenderTarget</code> interface represents the surface you want do draw on, such as a window. You use a function like <code>ID2D1Factory::CreateHwndRenderTarget()</code> to create it.</li>
<li><code>Drawing Operations</code>: Once a render target is created, yo ucan use its methods to draw. <code>ID2D1HwndRenderTarget::DrawRectange()</code> is a single example for rendering a rectangle.</li>
</ul>
</li>
<li><code>Direct2D</code> can be found at <code>C:\Windows\System32\d2d1.dll</code></li>
</ul>
</li>
<li><code>DirectWrite</code>: The API for High-Quality test rendering, designed to work seamlessly with Direct3D and Direct2D.
<ul>
<li><code>DirectWrite</code> provides advanced features for text layout, font management, and glyph rendering.</li>
<li><code>Key Concepts</code>
<ul>
<li><code>Text Formatting</code>: <code>DirectWrite</code> allows you to define the format of text. A function like <code>IDWriteTextFormat()</code> lets you specify the font, size, and style.</li>
<li><code>Text Layout</code>: To arrange text on the screen, you use a text layout object. The <code>IDWriteTextLayout</code> interface allows you to specify a text string and a format, and it handles the layout. This is crucial for handling complex scripts, wrapping text, and aligning content.</li>
<li><code>Rendering</code>: While <code>DirectWrite</code> handles the layout, the actual rendering is often done within <code>Direct2D</code>. You pass the text layout to a <code>Direct2D</code> drawing function to render it to the screen with hardware acceleration.</li>
</ul>
</li>
<li><code>Direct3D</code> can be found at <code>C:\Windows\System32\dwrite.dll</code></li>
</ul>
</li>
</ul>
<h4 id="the-api-call-sequence-1"><a class="header" href="#the-api-call-sequence-1">The API Call Sequence</a></h4>
<p>WHen a user-mode application makes a <code>DirectX</code> API call, a sequence of events occurs to get the request to the kernel and eventually, the GPU:</p>
<ol>
<li>A user-mode app makes a call to a <code>DirectX</code> API (<code>d3d12.dll</code>, <code>d2d1.dll</code>, <code>dwrite.dll</code>, etc.)</li>
<li>The <code>DirectX</code> API prepares the necessary data and commands in user mode. It then makes a system call to the kernel</li>
<li>The system call enters the kernel and is handled by the <code>DirectX</code> Graphics Kernel Subsystem <code>dxgkrnl.sys</code>
<ul>
<li><code>ntoskrnl.exe</code> receives the <code>syscall</code>, looks up the service number in it's dispatch table, then immediately hands off the request to <code>dxgkrnl.sys</code></li>
<li><code>dxgkrnl.sys</code> handles all GP-related tasks, but will make its own direct function calls to <code>ntoskrnl.exe</code> for foundational services, such as allocating memory in kernel space for GPU resources.</li>
</ul>
</li>
<li><code>dxgkrnl.sys</code> handles the core management tasks, such as scheduling GP work, allocating video memory (<code>VRAM</code>) and providing security and isolation.</li>
<li><code>dxgkrnl.sys</code> then passes the prepared commands to the hardware specific graphics driver (i.e., <code>nvlddmkm.sys</code> for nvidia). This driver is another kernel-mode component.</li>
<li>The hardware specific driver translates the commands into a format the GPU can understand and sends them directly to the GPU hardware.</li>
</ol>
<h3 id="the-windows-runtime-winrt-api"><a class="header" href="#the-windows-runtime-winrt-api">The Windows Runtime (WinRT) API</a></h3>
<p><code>Windows Runtime</code>(<strong>WinRT</strong>) is the modern, class-based API set created to be the foundation of the Universal WIndows Platform (<strong>UWP</strong>). It is designed to provide a secure, modern and language agnostic way for developers to build applications for a variety of Windows devices and built on the principles of the Component Object Model (<strong>COM</strong>)</p>
<p><code>WinRT</code> can be modeled by 4 layers:</p>
<ol>
<li><strong>The Metadata Layer</strong>: Binary metadata files that serve as a blueprint, containing a complete description of all the <code>WinRT</code> APIs, including their classes, methods, and properties.</li>
<li><strong>The Language Protection Layer</strong>: Enables the language agnostic nature of WinRT. A language's runtime (i.e., <code>C++/WinRT</code> Libraries) read the <code>.winmd</code> files and automatically generate "proxy" code, which translates the developers calls in their chosen language into low-level <strong>COM</strong> calls.</li>
<li><strong>The WinRT Implementation Layer</strong>: Contains the actual executable code, which is provided by Windows itself and located in user-mode DLLs (i.e., <code>Windows.Globalization.dll</code>)</li>
<li><strong>The Kernel Layer</strong>: When a <code>WinRT</code> API call requires a privileged operation, the <code>WinRT</code> implementation in user-mode makes a system call to the Windows kernel. The communication to the kernel is handled via the Native API interface (<code>ntdll.dll</code>)</li>
</ol>
<p>A few examples of <code>WinRT</code> APIs include:</p>
<ul>
<li><code>Windows.UI.Xaml.Controls.Button</code>: Creates a button in a modern UI. Code is run by <code>Windows.UI.XAML.dll</code></li>
<li><code>Windows.Web.HTTP.HttpClient</code>: Makes HTTP requests over the network. Code run by <code>Windows.Web.Http.dll</code></li>
<li><code>Windows.Devices.Geolocation.Geoloader</code>: Used to get location data from a devices GPS or other sensors. Code run by <code>WIndows.Devices.dll</code></li>
</ul>
<p>The system file we have discussed, including the core DLLs and drivers, are generally located in <code>C:\Windows\System32</code> on a standard Windows installation</p>
<h2 id="the-native-api"><a class="header" href="#the-native-api">The Native API</a></h2>
<p>The <code>Native</code> API is the low-level interface to the Windows kernel. <code>C:\Windows\System32\ntdll.dll</code> is an interface for the API and <code>C:\Windows\System32\ntoskrnl.exe</code> is the actual implementation in kernel-mode. Most high-level <code>Win32</code>, <code>DirectX</code>, and <code>WinRt</code> APIs serve as documented wrappers around these <code>Native</code> API functions. APIs in the <code>Native</code> API always start with one of two prefixes: <code>Nt</code> or <code>Zw</code>.</p>
<h3 id="the-nt-apis-ntxxx"><a class="header" href="#the-nt-apis-ntxxx">The NT APIs (<code>NtXxx</code>)</a></h3>
<p><code>Nt</code> is short for <strong>New Technology</strong>. APIs with this prefix are located in <code>ntdll.dll</code>, a user-mode library. By default, user-mode applications are considered untrusted, so <code>Nt</code> functions perform extensive parameter validation before transitioning into the kernel. They check for valid memory addresses, proper data types, and sufficient permissions. This is a critical security measure to prevent a user-mode program from passing a malicious or invalid value that could cause a crash in the privileged kernel space. If an invalid call is made, the call will fail gracefully, returning an error code, not causing a system crash.</p>
<p>For example: A user-mode program calls <code>NtCreateFile</code> fro <code>ntdll.dll</code>.</p>
<ol>
<li>The function validates the path to the file, the permissions and other parameters.</li>
<li>If the path is invalid the function returns an error, without ever entering the kernel.</li>
<li>If the parameters are valid, the function prepares a <code>syscall</code> to the kernel.</li>
</ol>
<h3 id="the-zw-api-zwxxx"><a class="header" href="#the-zw-api-zwxxx">The ZW API (<code>ZwXxx</code>)</a></h3>
<p><code>Zw</code> is rumored to be named after Gary Zwicky, a former Microsoft Engineer. These functions are located and implemented within the kernel-mode file, <code>ntoskrnl.exe</code>. The <code>Zw</code> API is designed to be called by kernel-mode components, primarily device drivers. <code>Zw</code> functions are considered trusted. They assume that the caller has already validated the parameters. For performance reasons, they do not perform a second round of validation. A call from a kernel-mode driver with ain invalid pointer or corrupted data can lead to a severe error, often resulting in a <strong>Blue Screen of Death</strong> (BSOD).</p>
<p>For example: A device driver needs to vreate a file</p>
<ol>
<li>Since the kernel-mode code is trusted, the driver calls <code>ZwCreateFile</code> directly.</li>
<li>If there is an error, it is handled ungracefully, likely resulting in BSOD.</li>
<li>If the parameters are valid, <code>ZwCreateFile</code> executes without issue, and allows access to the file from a given address.</li>
</ol>
<h3 id="the-link-between-nt-and-zw"><a class="header" href="#the-link-between-nt-and-zw">The Link Between <code>Nt</code> and <code>Zw</code></a></h3>
<p>When a user-mode application calls an <code>Nt</code> function, a few things occur:</p>
<ol>
<li>The <code>Nt</code> function performs its validation checks in user-mode.</li>
<li>It loads the system call number and parameters into the appropriate registers.</li>
<li>It executes the system call instruction, which transfers control to the kernel.</li>
<li>The kernel's <strong>System Service Dispather</strong> receives the system call and routes the request to the corresponding kernel-mode routine.</li>
<li>The kernel-mode routine is, in many cases, the <code>Zw</code> version of the function. For example, a <code>syscall</code> for <code>NtCreateFile</code> is dispatched to the core <code>ZwCreateFile</code> routine in <code>ntoskrnl.exe</code>.</li>
</ol>
<h2 id="the-system-calling-mechanism"><a class="header" href="#the-system-calling-mechanism">The System Calling Mechanism</a></h2>
<p>A <strong>system call</strong> is the process by which a user-mode thread requests a service from the operating system kernel. The user-mode side prepares the request by setting up registers according to a specific calling convention. A special instruction (<code>syscall</code> or <code>int 0x2e</code>) then triggers a direct, privileged transition into kernel-mode.</p>
<h3 id="the-64-bit-system-call-process"><a class="header" href="#the-64-bit-system-call-process">The 64-bit System Call Process</a></h3>
<ol>
<li><strong>Loading the System Call Number</strong>: A number representing the specific service requested from the kernel is loaded into the <code>rax</code> register.</li>
<li><strong>Passing the Parameters</strong>: The parameters for the system call are passed to the kernel using registers:
<ul>
<li><strong>1st Parameter</strong>: <code>rcx</code></li>
<li><strong>2nd</strong>: <code>rdx</code></li>
<li><strong>3rd</strong>: <code>r8</code></li>
<li><strong>4th</strong>: <code>r9</code></li>
<li>Additional parameters are pushed onto the <code>stack</code></li>
</ul>
</li>
<li><code>syscall</code>: Once the registers are populated, the <code>syscall</code> instruction is executed.</li>
<li><strong>Execution to Kernel Mode</strong>: The <code>syscall</code> instruction causes the CPU to trap into kernel mode at a pre-defined entry point. The kernel then uses the system call number in <code>rax</code> to lookup the correct handler function in the <strong>System Service Dispatch Table</strong>. 5) <strong>Execution and Return</strong>: The kernel-mode handler executes the requested service. Upon completion, the kernel restores the user-mode state and uses the <code>ret</code> instruction to return control to the user-mode application.</li>
</ol>
<pre><code class="language-asm64">; 64-bit Intel Assembly
mov rax, 0x1A            ; System Call number for `NtClose` is 0x1A
mov rcx, &lt;Handle&gt;        ; First parameter (handle) is in `rcx`
syscall                  ; Execute the system call
ret                      ; Return from the function
</code></pre>
<h3 id="the-32-bit-system-call-process"><a class="header" href="#the-32-bit-system-call-process">The 32-bit System Call Process</a></h3>
<ol>
<li><strong>Loading the System Call Number</strong>: The system call number is saved to <code>eax</code>.</li>
<li><strong>Passing the Parameters</strong>: The parameters for the function are passed onto the stack. The caller is responsible for pushing the parameters reverse order (right to left).</li>
<li><code>int 0x2e</code>: The system call instruction is called by generating a software interrupt, causing an immediate, privileged transition from the user-mode execution context into the kernel-mode interrupt handler.</li>
<li><strong>Transition to Kernel Mode</strong>: When the <code>int 0x2e</code> instruction is executed, the CPUs <strong>Interrupt Descriptor Table</strong> is used to find the corresponding kernel-mode interrupt handler for interrupt <code>0x2e</code>. The handler takes control, then uses the value in <code>eax</code> to identify the requested service. The handler then reads the parameters from the user-mode stack. The requested kernel function is executed with the provided parameters.</li>
<li><strong>Execution and Return</strong>: Once the operation is complete, the kernel restores the user-mode context and returns control to the application, often via a <code>ret</code> instruction.</li>
</ol>
<pre><code class="language-asm32">; 32-bit Intel Assembly
push eax            ; save reister value
push [esp+8]        ; Push the handle to the stack
mov eax, 0x12       ; System call number for NtClose is 0x12
int 0x2e            ; execute the system call
pop eax             ; restore the register
ret 4
</code></pre>
<h3 id="win32-api-as-a-wrapper"><a class="header" href="#win32-api-as-a-wrapper">Win32 API as a Wrapper</a></h3>
<p>The user-facing <code>Win32</code> AP wraps low-level calls. For instance, the <code>CloseHandle</code> function from <code>kernel32.dll</code> is implemented by making a call to <code>ntdll.dll</code>, which then executes the system call.</p>
<pre><code class="language-asm64">; Disassembly of CloseHandle in kernel32.dll
; CloseHandle(Handle hObject)
lea r11, [rip+&lt;some_offset&gt;]    ; Get a pointer to the NtClose stub in nt.dll
jmp r11                         ; Jump to the NtClose function
</code></pre>
<h3 id="the-kisystemservice-function"><a class="header" href="#the-kisystemservice-function">The <code>KiSystemService()</code> Function</a></h3>
<p><code>KiSystemService</code> is the single, privileged entry point into the Windows kernel for all user-mode system call requests. It is a highly optimized internal kernel function that is executed immediately after the <code>syscall</code> instruction is issued by the CPU. It is primarily used as the secure gatekeeper between user-mode and kernel-mode. When a <code>syscall</code> occurs, the CPU's privilege level is raised, and execution is transferred to <code>KiSystemService</code>, which will retrieve the system call number and parameters from the registers/stack, save the user execution context and set up the kernel context, and use the system call number to look up the execution function from <code>KiServiceTable</code>.</p>
<div id="admonition-note-10" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-10-title">
<div class="admonition-title">
<div id="admonition-note-10-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-10"></a>
</div>
<div>
<p><strong>KiServiceTable</strong>
<strong>Ki</strong> stands for "kernel internal". <code>KiServiceTable</code> is an array of function pointers responsible for mapping a system call number to the memory address of the corresponding kernel function. This is also referred to as the <code>SystemServiceDispatchTable</code>.</p>
<p>The <code>KiServiceTable</code> is a acmomon target for malware and rootkids. By modifying a pointer in this table, an attacker can "hook" a system call, redirecting it to their own malicious code. This is referred to as <strong>System Service Dispatch Table Hooking</strong> (SSDT Hooking).</p>
</div>
</div>
<h3 id="the-system-call-dispatch-process"><a class="header" href="#the-system-call-dispatch-process">The System Call Dispatch Process</a></h3>
<p>The System Call Dispatch Process can be broken into 10 steps:</p>
<ol>
<li>A user-mode application calls a function (i.e., <code>NtClose</code>), which requires interaction with kernel-mode components. The <code>ntdll.dll</code> library handles this call.</li>
<li><code>ntdll.dll</code> places the system call number for the function (i.e., <code>0x1A</code> for <code>NtClose</code>) into the <code>rax</code> register and the function's other parameters into their respective registers/stack positions.</li>
<li>The <code>syscall</code> instruction is executed.</li>
<li>The CPU transitions to kernel-mode and begins executing the code for <code>KiSystemService</code>.</li>
<li><code>KiSystemService</code> reads the value from <code>rax</code>.</li>
<li><code>KiSystemService</code> uses the value in <code>rax (i.e., </code>0x1A<code>) as an index into the </code>KiServiceTable`.</li>
<li>The entry at <code>KiServiceTable[rax]</code> contains a pointer to the appropriate function. For example, <code>KiServiceTable[0x1A]</code> contains a pointer to <code>ZwClose</code>.</li>
<li><code>KiSystemService</code> jumps to the memory address stored in that table entry, transferring execution to the <code>ZwClose</code>. function.</li>
<li>The kernel function executes, performs the requested operation on kernel memory, and returns to <code>KiSystemService</code>.</li>
<li><code>KiSystemService</code> handles the cleanup and returns control securely to the user-mode application.</li>
</ol>
<h2 id="the-amended-process-initialization-sequence"><a class="header" href="#the-amended-process-initialization-sequence">The Amended Process Initialization Sequence</a></h2>
<p>With this new information, we can add some additional information to the process initialization sequence we went over previously.</p>
<ol>
<li><strong>User-Mode Initiation with <code>CreateProcess</code></strong>
<ul>
<li>The initialization sequence begins when a user-mode application calls a high-level <code>CreateProcess</code> API
<ul>
<li><code>CreateProcess</code> is a fundamental part of the <code>Win32</code> API, that is primarily responsible for validating a user's request to create a new process, gathering all of the necessary information (i.e., the executable path, command-line arguments, and environment variables) and preparing said information for Step 2</li>
</ul>
</li>
</ul>
</li>
<li><strong>The <code>ntdll.dll</code> Native API Bridge</strong>
<ul>
<li><code>CreateProcess</code> makes an internal, private call to a function within 'ntdll.dll', such as <code>NtCreateUserProcess</code>, which receives the prepared request and sets up the parameters and the system call number in the appropriate CPU registers.</li>
</ul>
</li>
<li><strong>The <code>syscall</code> and Kernel-Mode Transition</strong>
<ul>
<li>The <code>ntdll.dll</code> function executes the <code>syscall</code> instruction, which crucially changes the CPU's privilege level. from user-mode (Ring 3) to kernel-mode (Ring 0) (More on Ring Levels Later). At Ring 3, the operating system's kernel takes over, and control is transferred to the system call dispatcher, typically <code>KiSystemService</code>.</li>
</ul>
</li>
<li><strong>Kernel Object Creation (<code>NtCreateProcessEx</code> &amp; <code>NtCreateThreadEx</code>)</strong>
<ul>
<li><code>KiSystemService</code> looks up the correct kernel function address in the <code>KiServiceTable</code> using the system call number as an index. <code>KiSystemService</code> dispatches the request to the core process creation routines, typically <code>NtCreateProcessEx</code> and <code>NtCreateThreadEx</code> . The kernel's Object Manager creates a Process object and a Thread object, which are privileged data structures that reside in kernel-mode memory. These are the kernel's internal representation of the new process and its initial thread. The initial thread is created in a suspended state, to prevent the thread from executing any code until the kernel is ready.</li>
</ul>
</li>
<li><strong>Creating the Process Handle</strong>
<ul>
<li>After creating the kernel objects, the kernel creates a small unique integer value (the Handle), which is added to the new process's private <strong>Process Handle Table</strong>. The kernel also returns the handle to the original user-mode application, allowing it to interact with the new process in a controlled and secure manner.</li>
</ul>
</li>
<li><strong>The Two-Phase User-Mode Loader</strong>
<ul>
<li>Here, the kernel hands off execution to the user-mode code. The kernel sets the initial thread's instruction pointer to <code>LdrInitializeThunk</code>, a function in <code>ntdll.dll</code>, then resumes its execution
<ul>
<li><code>LdrInitializeThunk</code> is the process's first user-mode code to run, and it performs a two-phase loading and initialization process:
<ol>
<li><strong>Dependency Resolution</strong>(LdrpInitialize): A deep, recursive traversal of the executable's import address table and all of its dependencies. The loader checks for required DLLs and if a DLL is not yet loaded, it calls the Memory Manager to map the DLL's image from disk into the process's virtual address space. The loader then recursively processes the new DLL's dependencies, ensuring the entire dependency tree is mapped.</li>
<li><strong>Initialization Routines</strong> (LdrpRunInitializeRoutines): After all dependencies are mapped, this phase focuses on initialization. The loader iterates through the newly added DLLs and for each DLL, it calls the <code>DllMain</code> function with the <code>DLL_PROCESS_ATTACH</code> notification set for <code>fdwReason</code>. This gives each DLL a chance to initialize its own internal state, allocate resources, and prepare for use before the main executable is run.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>The Final Handoff to the Application</strong>
<ul>
<li>Once the loading phases have completed, <code>LdrInitializeThunk</code> makes a final jump, transferring control to the application's designated entry point (typically <code>main</code> or <code>WinMain</code>). Here, the application's code begins to execute, and the process is fully initialized and ready to go.</li>
</ul>
</li>
</ol>
<h2 id="executable-format"><a class="header" href="#executable-format">Executable Format</a></h2>
<p>The Windows Executable File Format is called a <code>Portable Executable</code>(<strong>PE</strong>). <strong>PE</strong> files are relocatable, meaning they can be loaded at different virtual addresses each time they are loaded. In this section, we will elaborate on how executables are loaded into virtual memory, the various section of the executable, and some of the security measures put in place to protect data and code within these sections.</p>
<h3 id="base-address-and-rva"><a class="header" href="#base-address-and-rva">Base Address and RVA</a></h3>
<p>The <strong>Base Address</strong> is the preferred virtual memory address where a module is compiled to be loaded. It is used by the linker as a reference point for all internal addressing.</p>
<p>On 32-bit (x86) Windows, the virtual address space is limited to 4GB and the preferred base address for an executable is <code>0x00400000</code>. If a <code>DLL</code> is compiled to be loaded at this address, and an executable is already there, a collision occurs.</p>
<p>On 64-bit (x86-64) Windows, the virtual address space is theoretically 15 exabytes (2⁶⁴ bytes) large in volume. A preferred base address for an executable is <code>0x0000000140000000</code>.</p>
<p>In order to make code flexible and independent of its final load address, all internal pointers and jump targets are stored as an offset from the module's preferred base address, being the <strong>Relative Virtual Address</strong>(RVA). The final, absolute virtual address of any object in a module is always calculated at runtime:</p>
<pre><code>Absolute Virtual Address = Module Load Address + RVA
</code></pre>
<h3 id="image-sections"><a class="header" href="#image-sections">Image Sections</a></h3>
<p>PE files are highly structured and composed of distinct Image Sections, each with a specific purpose and its own set of memory permissions. Common sections include:</p>
<ul>
<li><code>.text</code> or <code>CODE</code>: Contains the executable machine code. Has Read and Execute (RX) permissions</li>
<li><code>.rdata</code>: Contains read-only data, such as constant strings and the import address table. This section has Read-Only (R) permissions.</li>
<li><code>.data</code>: Contains initialized global and static variables, Has RW permissions.</li>
<li><code>.reloc</code>: Contains the Base Relocation Table, used by the OS loader to fix absolute pointers.</li>
</ul>
<p>The RVA of an object is always an offset within its section, and the OS loader uses the PE headers section table to map this RVA to the correct virtual memory location.</p>
<h4 id="section-alignment"><a class="header" href="#section-alignment">Section Alignment</a></h4>
<p>The file has a different alignment on disk than it does when loaded into memory, a design choice made to optimize for both the disk space and memory usage. There are two primary alignment values found in the PE header:</p>
<ul>
<li>
<p><code>FileAlignment</code>: This value dictates how each section is aligned on disk. Typically, this is a small numeric value, which is also a power of 2 (i.e., 512 bytes (0x200))</p>
<ul>
<li>For instance, if a section's raw size is 1200 bytes, it will be padded to 1536 bytes (the next multiple of 512). The OS loader reads the file from disk using these alignments.</li>
</ul>
</li>
<li>
<p><code>SectionAlignment</code>:This value dictates how each section is aligned in virtual memory. Typically, this is a large numeric value, whcih is a power of 2 (i.e. 4096 bytes (0x1000)). When the sections are mapped into cirtual memory by the OS, each section must begin on a page boundary.</p>
<ul>
<li>For instance, if a section's size in memory is 5000 bytes, it will occupy two pages (8192 bytes), even if it only uses a small portion of the second page.</li>
</ul>
</li>
</ul>
<p>The distinct alignments between the disk and virtual memory allow the PE file to be compact on disk (saving storage and download. time) while ensuring that, once loaded, its sections are perfectly aligned with the memory manager's page-based system. An OS's memory manager works with memory pages, not individual bytes, so aligning sections to page boundaries makes it highly efficient to apply memory permissions (<code>R</code>/<code>W</code>/<code>X</code>) to each section. Also consider, when statically analyzing a file, the RVA is determined by the Section Alignment of the executable, not the File Alignment.</p>
<h4 id="the-critical-role-of-relocations"><a class="header" href="#the-critical-role-of-relocations">The Critical Role of Relocations</a></h4>
<p>The need for relocations is driven by two primary reasons:</p>
<ol>
<li><strong>Reason 1: Avoiding DLL Collisions</strong> (Primarily 32-bit)
In the early days of Windows, DLLs were often compiled with a preferred base address. When two different DLLs had the same preferred address, a <strong>DLL Collision</strong> occured. The OS loader was then forced to find a new, available virtual memory space for one of them. Since the code in the relocated DLL was compiled with absolute addresses that are now wrong, a relocation was necessary to fix all internal pointers.</li>
<li><strong>Reason 2: Enabling ASLR and Security</strong> (Primarily 64-bit)
Address Space Layout Randomization (ASLR) is a security feature that randomizes the base address of every module each time a program runs. The randomness makes it impossible for an attacker to reliably predict the location of code or data before runtime. ASLR requires every single module to go through the relocation process, fixing all of its internal absolute pointers to point to the correct, randomly located targets.</li>
</ol>
<pre><code class="language-C">#include &lt;iostream&gt;

// Assume this program is compiled with a preferred base address of 0x00400000

// This is a global variable. It resides in the '.data' section
int global_data = 100;

// This pointer will be initialized with the ABSOLUTE dadress
// of 'global_data'. It will need to be fixed at runtime
int* global_data_pointer = &amp;global_data

int main(){
    // The linker has hardcoded the virtual address of 'global_data'
    // into the 'global_data_pointer' variable. If the program is
    // loaded at a different address (due to relocation), this pointer's
    // value will be wrong.

    // The OS loader will find this pointer's location in
    // the '.reloc' section and fix its value at runtime before
    // the 'main' function starts.

    // Let's assume the program's preferred base address is `0x00400000` and
    // 'global_data' has an RVA of '0x1000'.
    // The linker will initialize 'global_data_pointer' to '0x00401000'

    // When the program is loaded at a random base addres, say '0x7b000000',
    // the loader will 'relocate' the pointers value
    // New Value = 0x7b000000 + (0x00401000 - 0x00400000) = 0x7b001000

    // The loader will change the value stored in 'global_data_pointer' to
    // 0x7b001000 before the program starts executing 'main()'

    // The program can now safely dereference the pointer
    std::cout &lt;&lt; "The value pointed to by global_data_pointer is: " &lt;&lt; *global_data_pointer &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<div id="admonition-note-11" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-11-title">
<div class="admonition-title">
<div id="admonition-note-11-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-11"></a>
</div>
<div>
<p><strong>*</strong> and <strong>&amp;</strong>
In C-like languages:</p>
<p><code>*</code> is the dereference operator. It gets the value stored at the address a pointer is referencing.</p>
<p><code>&amp;</code> is the "address of" operator. It gets the address of some variable stored in memory.</p>
</div>
</div>
<h3 id="sections-of-an-image"><a class="header" href="#sections-of-an-image">Sections of an Image</a></h3>
<h4 id="dos-header"><a class="header" href="#dos-header">DOS Header</a></h4>
<p>The <strong>DOS Header</strong> ensures backward compatibility and a graceful error message system on systems that don't support the PE format, "This program cannot be run in DOS mode".</p>
<pre><code class="language-C">typedef struct _IMAGE_DOS_HEADER{
    WORD e_magic;     // Magic number: "MZ"
    [...trunc...]
    LONG e_lfanew;    // File address of the new PE header
}IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER
</code></pre>
<p>The most important fields of the <code>DOS Header</code> are:</p>
<ul>
<li><code>e_magic</code>: the first two bytes of the DOS header, which must equal <code>MZ</code> (0x5A4D)</li>
<li><code>e_lfanew</code>: A pointer to the start of the <code>IMAGE_NT_HEADERS</code> structure (the PE Headers)</li>
</ul>
<h4 id="pe-header"><a class="header" href="#pe-header">PE Header</a></h4>
<p>The <strong>PE Header</strong> is composed of metadata at the beginning of Windows programs which provides information about the file's contents, architecture, required libraries, and entry point for the operating system to load and run the program. The PE Header is composed of a signature, a <code>FileHeader</code> and an <code>Optional Header</code>. The <code>IMAGE_NT_HEADERS</code> structure serves as the main header, and its C structure is defined to accommodate both 32-bit and 64-bit systems:</p>
<pre><code class="language-C">typedef struct _IMAGE_NT_HEADERS64{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
}IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
}IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
</code></pre>
<p>The <code>_IMAGE_NT_HEADERS*</code> structure references two data structures which contain the actual PE header, being <code>IMAGE_FILE_HEADER</code> and <code>IMAGE_OPTIONAL_HEADER*</code>:</p>
<pre><code class="language-C">typedef struct _IMGAE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    [...trunc...]
}IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD Magic;
    [...trunc...]
    DWORD NumberofRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
}IMAGE_OPTIONAAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
</code></pre>
<p><strong>DataDirectory</strong> is an array of additional data structures that are stored inside the PE header including <code>Export Table</code>, <code>Resource Table</code>, <code>Thread Local Storage Table</code>, and more. It is due to this critical data structure that the <strong>Optional Headers</strong> are not optional for Windows <strong>PE</strong> files. More on this later.</p>
<h4 id="imports-and-exports"><a class="header" href="#imports-and-exports">Imports and Exports</a></h4>
<p><strong>Dynamic Link Libraries</strong> are a repository of executable code and data that can be shared among multiple programs. They can either be <strong>statically</strong> or <strong>dynamically</strong> linked to a compiled program. When <strong>statically linking</strong>, all required library code is copied directly into the final executable at compile time. When <strong>dynamically linking</strong>, the compiler includes only import information in the executable's PE header. The required DLLs are then loaded by the OS loader at runtime.</p>
<p><strong>Imports</strong> and <strong>Exports</strong> are the mechanisms that enable the dynamic linking process of executables.</p>
<p>For instance, consider an executable that references functions in other executables while it is being compiled and linked:
<img src="https://hackmd.io/_uploads/r1spBhvAgl.png" alt="image" /></p>
<blockquote>
<p>Diagram of the C/C++ Compilation Process
<strong>preprocessing</strong> -&gt; <strong>compiling</strong> -&gt; <strong>assembling</strong> -&gt; <strong>linking</strong></p>
</blockquote>
<p>The compiler and linker have no idea of the imported functions' actual addresses. These are determined at runtime. To address this problem, the linker creates a special import table that lists all the functions imported by the current module, by their names. The <code>import table</code> contains a list of modules that a module utilizes and the list of functions called within each of those modules. When the current module is loaded, the loader loads every module listed in the import table and identifies the address of each function listed. These addresses are found by going over the imported module's export table, which contains the names and RVAs of every exported function.</p>
<p>When the current module needs to call into an imported function, the call typically looks like this:</p>
<pre><code class="language-asm64">call [Some Address]
</code></pre>
<p>Where <code>SomeAddress</code> is a pointer into the executable import address table (IAT). When the module is linked, the IAT is nothing but a list of empty values. When the module is loaded, the linker resolved each entry in the IAT to point to the actual function in the imported module.</p>
<p><img src="https://hackmd.io/_uploads/BkprThPAlg.png" alt="image" /></p>
<blockquote>
<p>Diagram of PE Imports and Exports</p>
</blockquote>
<h3 id="pe-file-directories"><a class="header" href="#pe-file-directories">PE File Directories</a></h3>
<p>As discussed before, <strong>DataDirectory</strong> is a data structure stored in the <code>IMAGE_OPTIONAL_HEADER</code> section of the PE. This is a crucial structure that the OS loader uses to find essential information.</p>
<p>Here is a breakdown of key PE file directories:</p>
<ul>
<li><code>Export Table</code>: A list of names and RVAs for all exported functions in the current module.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_EXPORT_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_EXPORT[0]</code></li>
</ul>
</li>
<li><code>Import Table</code>: A list of the names of modules and the functions used within those modules by the current module.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_IMPORT_DESCRIPTOR</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_IMPORT[1]</code></li>
</ul>
</li>
<li><code>Resource Table</code>: Points to the executable's resource data, such as icons, images, menus, and cursors.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_RESOURCE_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_RESOURCE[2]</code></li>
</ul>
</li>
<li><code>Base Relocation Table</code>: A list of addresses that must be adjusted in the event of relocation
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_BASE_RELOCATION</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_BASERELOC[5]</code></li>
</ul>
</li>
<li><code>Debugging Information</code>: Debugging info for the executable, often in the form of a link to an external symbol file.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_DEBUG_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_DEBUG[6]</code></li>
</ul>
</li>
<li><code>Thread Local Storage Table</code>: Points to a special section that contains thread-local variables.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_TLS_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_TLS[9]</code></li>
</ul>
</li>
<li><code>Load Configuration Table</code>: Contains configuration elements for special security features that list legitimate exception handlers.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_LOAD_CONFIG_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_LOAD_CONFIG[10]</code></li>
</ul>
</li>
<li><code>Bound Import Table</code>: An import related table used to confirm that pre-resolved addresses into an exporting module are still valid.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT[11]</code></li>
</ul>
</li>
<li><code>Import Address Table</code>: A list of entries for each imported function, which are initialized at load time to the actual addresses of the imported functions.
<ul>
<li><strong>Associated Data Structure</strong>: A List of 32-bit Pointers</li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_IAT</code></li>
</ul>
</li>
</ul>
<h2 id="input-and-output"><a class="header" href="#input-and-output">Input and Output</a></h2>
<p>The <code>I/O</code> System is a combination of kernel components that manage the device drivers running in the system and the communication between applications and device drivers. The design of the system is modular, allowing for immersive flexibility and security.</p>
<p>First, we have the <strong>User-Mode Interface</strong>. At this level, <code>I/O</code> requests are handled by documented APIs. For instance, when a process needs to read from a file, it doesn't directly access the hard drive. Instead, it makes a high-level API call, like <code>ReadFile()</code> or <code>WriteFile()</code>, which in turn, makes a system call to the kernel via <code>ntdll.dll</code> and the <code>KiSystemService</code> trap.</p>
<p>Once the request enters the kernel, control is passed to the I/O manager. The <strong>I/O Manager</strong> is a central component of the Windows kernel that is responsible for all I/O-related operations and acts as a dispatcher, taking a user's request and sending it to the correct device driver. The I/O Manager builds a data structure called an <strong>I/O Request Packet</strong> (IRP). An IRP is a formal request that describes the I/O operation (i.e., read, write), which file to access, and how many bytes to transfer. The I/O Manager creates an IRP and populates it with information form the user-mode request. Then, the IRP is sent down a chain of device drivers known as the <strong>driver stack</strong>. This allows for the modular design. For instance, a request to read from a file on a USB thumb drive would first go to the file system driver (<code>ntfs.sys</code>), then the volume manager driver, and finally to the USB host controller driver. Each driver on the stack handles its part of the request.</p>
<p>There are optional drivers that may sit between other drivers on the driver stack, called <strong>Filter Drivers</strong>. Filter Drivers are inserted in the driver stack to inspect, modify, or block IRPs as they pass through. They can be attached to any part of the driver stack. For instance, an antivirus program may insert a filter driver into the file system driver stack to intercept all IRPs and scan the file contents for malware before allowing the IRP to proceed.</p>
<p>At the bottom of the driver stack is the <strong>bus driver</strong>, which takes the IRP and sends specific commands to the physical hardware to facilitate the request. <strong>Direct Memory Access</strong> (DMA) is a crucial performance optimization method which transfers data directly between the device and the application's memory, without constantly involving the CPU.</p>
<p>When the hardware operation is complete, it generates an interrupt. The I/O Manager processes this interrupt, marks the IRP as complete, and the results are passed back up the driver stack. The IRP is returned to the user-mode application, which can continue its execution.</p>
<h2 id="structured-exception-handling-seh"><a class="header" href="#structured-exception-handling-seh">Structured Exception Handling (SEH)</a></h2>
<p><strong>Structured Exception Handling</strong> is a robust, language-independent mechanism in Windows that allows applications and the operating system itself to gracefully respond to and recover from unexpected events, called <strong>exceptions</strong>. Exceptions can range from hardware-generated faults to software-defined errors. They are events that occur during a programs execution that disrupt the normal flow of instructions.</p>
<ul>
<li><strong>Hardware Exceptions</strong>: Detected by the CPU, including:
<ul>
<li><code>Access Violation</code> (0xC0000005): Attempting to read from or write to an invalid or protected memory address.</li>
<li><code>Divide by Zero</code> (0xC0000094): An arithmetic operation where the divisor is zero.</li>
<li><code>Illegal instruction</code> (0xC000001D): Attempting to execute an invalid CPU instruction.</li>
</ul>
</li>
<li><strong>Software Exceptions</strong>: Explicitly generated by an application or the operating system (i.e., <code>RaiseException()</code> API Call) and can be used for custom error reporting.</li>
</ul>
<h3 id="32-bit-seh"><a class="header" href="#32-bit-seh">32-bit SEH</a></h3>
<p>On 32-bit systems, SEH is implemented on top of a singly linked list of exception handler records that resides directly on each threads' stack. The <strong>Thread Information Block</strong> (TIB) is a per-thread data structure containing vital information about the thread. Typically, the TIB is referenced by some offset of the <code>FS</code> registers. The TIB can be used to reference the address of the head of the Exception Handler List.</p>
<p>The Exception Handler List is a singly linked list of <code>EXCEPTION_REGISTRATION_RECORD</code>s, which are pushed onto the stack by functions that contain SEH blocks (i.e., <code>__try/__except</code>). It takes on the following form:</p>
<pre><code class="language-C">typedef struct _EXCEPTION_REGISTRATION_RECORD {
  struct _EXCEPTION_REGISTRATION_RECORD *Next;
  PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;
</code></pre>
<p>Where:</p>
<ul>
<li><code>Next</code>: A pointer to the previous <code>EXCEPTION_REGISTRATION_RECORD</code> on the stack, forming the chain</li>
<li><code>Handler</code>: A pointer to the specific exception handler function (the code within the <code>__except</code> block) that should be executed if any exception occurs within the associated <code>__try</code> block's scope.</li>
</ul>
<p>When a function containing a <code>__try</code> block is entered, a new <code>EXCEPTION_REGISTRATIN_RECORD</code> is created on the stack, the <code>Next</code> pointer is set to the current value of <code>FS:[0]</code> (which points to the previous handler on the stack), and <code>FS:[0]</code> is updated to point to the new record, making the new record the head of the exception handler chain.</p>
<p>If an exception occurs, the Operating System walks this linked list, starting from the head at <code>FS:[0]</code>, checks each handler to see if it can handle the exception and if a handler is found it is executed. If not, the search continues until the end of the list is reached. This is referred to as <strong>Stack Unwinding</strong>.</p>
<p>This stack-based approach is vulnerable to <strong>buffer overflow attacks</strong> (See <code>Appendix B: Manually Writing Shellcode for Windows</code> for more details). An attacker could overwrite a stack buffer to corrupt the <code>EXCEPTION_REGISTRATION_RECORD</code>, redirecting the <code>Next</code> pointer or the handler address to a malicious location and taking control of the program's execution flow.</p>
<h3 id="64-bit-seh"><a class="header" href="#64-bit-seh">64-bit SEH</a></h3>
<p>64-bit SEH is table based. Instead of using the stack, the compiler generates static, read-only tables that describe the exception handlers and stack unwinding information for each function. These tables are stored in the executable's data sections (<code>.pdata</code> and <code>.xdata</code>).</p>
<p>There is no dynamic linked list and no manipulation of segment registers (i.e., <code>FS</code> or <code>GS</code>). The process of entering a <code>__try</code> block incurs almost no runtime overhead because no data is pushed onto the stack.</p>
<p>When an exception occurs, the operating system's exception dispatcher analyzes the call stack. For each function on the stack, it consults the pre-generated exception tables to determine the function's structure and any associated exception handlers. Then, it unwinds the stack by virtually reversing the function calls, restoring register states and executing the appropriate handler if one is found.</p>
<p>This table-based model provides more security by preventing reads to the tables and only uses computing resources when an exception is thrown.</p>
<p>The <code>GS</code> segment register is used to access per-thread data. The <code>TIB</code>, which is pointed to by <code>GS:[0]</code>, contains a pointer to the <code>PEB</code>.</p>
<h2 id="the-hardware-abstraction-layer"><a class="header" href="#the-hardware-abstraction-layer">The Hardware Abstraction Layer</a></h2>
<p>The <strong>Hardware Abstraction Layer</strong> (HAL) is the kernel-mode component that isolates the operating system from platform-specific hardware details by providing a uniform interface to interrupts, timers, processors, and low-level hardware mechanisms. It can be found at <code>C:\Windows\System32\hal.dll</code>.</p>
<p>Whenever a device raises an interrupt, the following process occurs:</p>
<ol>
<li>
<p><strong>The Hardware Signals the Interrupt Controller</strong></p>
<ul>
<li>When a device (like the keyboard or network card) has data ready, it sends an electrical signal to the <strong>Interrupt Controller</strong> (usually the <strong>APIC</strong> - Advanced Programmable Interrupt Controller). The hardware doesn't know what Windows or drivers are. It only knows how to pulse a wire or send a message over the <strong>PCIe</strong> (Peripheral Component Interconnect Express). The APIC gathers these physical signals and prioritizes them so that the CPU isn't overwhelmed.</li>
</ul>
</li>
<li>
<p><strong>The HAL Translates It Into a Logical Interrupt</strong></p>
<ul>
<li>Different motherboards use different wiring for interrupts. The HAL maps these physical hardware lines to a <strong>Global System Interrupt</strong> (GSI). This ensures that the Windows kernel doesn't have to be rewritten for every different type of motherboard (Intel, ARM, AMD). Instead, it waits for the HAL to report which interrupts have occurred.</li>
</ul>
</li>
<li>
<p><strong>The Kernel Dispatches the Interrupt</strong></p>
<ul>
<li>Once the HAL identifies the interrupt, the kernel looks up the appropriate function in the <strong>Interrupt Descriptor Table</strong> (IDT). The kernel handles the <strong>Context Switch</strong> as well. It pauses whatever the current user operation is (i.e., browsing the web) and saves whatever work has been done so the CPU can focus on the hardware event. Then, it dispatches control to the specific <strong>Interrupt Service Routine</strong> registered by the device driver.</li>
</ul>
</li>
<li>
<p><strong>The Driver Handles the Device Event</strong></p>
<ul>
<li>The <strong>Device Driver</strong> finally executes, which can be broken up into two functions:
<ul>
<li><strong>The Interrupt Service Routine</strong> (ISR): Acknowledges the hardware and quickly clears the interrupt so the CPU can go back to work.</li>
<li><strong>The Deferred Procedure Call</strong> (DPC): A mechanism that lets high-priority tasks quickly finish their critical work and schedule less urgent tasks for later execution at a lower priority, preventing system stalls and maintaining responsiveness. Ensures the system remains responsive and doesn't lock up while processing one device's data. It is used by driver to handle heavy processing after an interrupt is acknowledged.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="the-boot-up-process"><a class="header" href="#the-boot-up-process">The Boot-Up Process</a></h2>
<h3 id="phase-1-the-hardware-firmware-handshake"><a class="header" href="#phase-1-the-hardware-firmware-handshake">Phase 1: The Hardware-Firmware Handshake</a></h3>
<ol>
<li><strong>Power-On Self-Test</strong> (POST): When the power button is pressed, the computer's motherboard runs a hardware check, the POST, to ensure that components, such as the CPU, RAM, and GPU are functioning.</li>
<li><strong>Firmware Loading</strong>: After the POST, the motherboard's firmware (<code>BIOS</code> or <code>UEFI</code>) takes control. It's main job is to locate and load the first piece of software from the storage device.</li>
<li><strong>Bootloader Execution</strong>: The firmware reads a small, initial program, called the <strong>bootloader</strong>, from a designated sector on your hard drive. The bootloader is the first executable to run on the machine and is primarily responsible for starting the Operating System.</li>
</ol>
<h3 id="phase-2-the-kernel-mode-boot"><a class="header" href="#phase-2-the-kernel-mode-boot">Phase 2: The Kernel-Mode Boot</a></h3>
<ol>
<li><strong>Loading the Kernel</strong>: The bootloader loads the kernel executable (<code>ntoskrnl.exe</code>) into memory and transfers control to it. It is now the only application running on the system.</li>
<li><strong>Kernel initialization</strong>: The kernel begins its own setup, initialinig device drivers, core data structures, and other key components. This includes the:
<ul>
<li><code>Memory Manager</code>: Establishes the physical and virtual memory spaces for the entire system.</li>
<li><code>Object Manager</code>: Creates the initial objects that represent system resources, including the first process objects.</li>
<li><code>Process Manager</code>: Prepares the environment for process creation.</li>
</ul>
</li>
</ol>
<h3 id="phase-3-user-mode-genesis"><a class="header" href="#phase-3-user-mode-genesis">Phase 3: User-Mode Genesis</a></h3>
<ol>
<li><strong>Session Manager (<code>smss.exe</code>) Launch</strong>: The kernel's initialization routine launches the Session Manager Subsystem (<code>smss.exe</code>), the first user-mode process on the entire system, which all other user-mode processes can be traced back to.</li>
<li><strong>Building the First Processes</strong>: As <code>smss.exe</code> launches its child processes, the kernel's subsystem performs a series of operations for each one:
<ul>
<li><code>Object Manager</code>: Creates a new Process Object for each child process (i.e., <code>winlogon.exe</code>, <code>csrss.exe</code>) and gives each process its own dedicated Process Handle Table.</li>
<li><code>Memory Manager</code>: Where the Virtual Address Space is created for each new process. The Memory Manager uses VAD Trees to organize these virtual address spaces. It then maps Virtual Pages to Physical Frames in RAM, creating the process's Working Set. This ensures each process has the memory it needs to run, even though they can't access each other's memory directly.</li>
</ul>
</li>
<li><strong>Connecting to the Kernel</strong>: These initial processes begin making requests to the kernel, via <code>ntdll.dll</code>.</li>
</ol>
<h3 id="phase-4-the-final-steps-to-user-interaction"><a class="header" href="#phase-4-the-final-steps-to-user-interaction">Phase 4: The Final Steps to User Interaction</a></h3>
<ol>
<li><strong>User Login</strong>: <code>winlogon.exe</code> handles the login screen. Once the user successfully authenticates, <code>winlogon.exe</code> starts the user's shell, typically <code>explorer.exe</code>. This is the application that give you your desktop, taskbar, and Start Menu.</li>
<li><strong>The <code>CreateProcess</code> API</strong>: <code>explorer.exe</code>, and many other applications can now use the <code>CreateProcess</code> API to create new processes, initializing the <strong>process initialization sequence</strong>.</li>
</ol>
<h2 id="users-and-privileges"><a class="header" href="#users-and-privileges">Users and Privileges</a></h2>
<p>Operating system authorizations are designed to handle multiple users with multiple roles and permissions. The abstraction of user roles and permissions on a system is set up and facilitated by a system called a <strong>protection ring</strong>, which specifies limits and enforces the functionality of users on a system and their corresponding access to resources.</p>
<p>A <strong>Protection Ring</strong> is a hardware-enforced mechanism on many CPU architectures that provides different levels of access to system resources. The rings are arranged in a hierarchy, with the most privileged level being <code>Ring 0</code> and the least privileged level being <code>Ring 3</code>:
<img src="https://hackmd.io/_uploads/HkBPOJORle.png" alt="image" /></p>
<blockquote>
<p>Diagram of how Protection Rings are organized</p>
</blockquote>
<p><code>Kernel-Mode</code> is synonymous with <code>Ring 0</code>. It is where the core of the OS resides, including <code>ntoskrnl.exe</code>, <code>hal.dll</code> (Hardware Abstraction Layer), and kernel-mode drivers like <code>win32k.sys</code>.</p>
<p><code>User-Mode</code> is synonymous with <code>Ring 3</code>, where user applications and user-mode components (i.e., <code>winlogon.exe</code>) reside. It exists for untrusted processes, which should be strictly regulated by the operating system.</p>
<p>Modern CPUs also support additional execution states, which are unofficially referred to as <code>Ring -1</code> (Hypervisor Mode), <code>Ring -2</code> (System Management Mode), and <code>Ring -3</code> (Platform Security Processor), all of which have greater control of and access to system resources than the installed OS. We touch on this more later.</p>
<h3 id="transitioning-from-ring-3-to-ring-0"><a class="header" href="#transitioning-from-ring-3-to-ring-0">Transitioning from Ring 3 to Ring 0</a></h3>
<p>A program must use a special instruction to <code>trap</code> into the kernel:</p>
<ul>
<li><code>SYSENTER</code> (Newer 32-bit Systems): The modern, fast method for making a system call within a 32-bit application.
<ul>
<li>Before executing <code>SYSENTER</code>, the user-mode code prepares the system call by loading specific registers with data:
<ul>
<li>The system call number is placed into the <code>eax</code> register</li>
<li>The address of the return code is placed into the <code>ecx</code> register</li>
<li>The stack pointer is placed in the <code>edx</code> register</li>
<li>Function arguments will typically be pushed onto the user-mode stack from right to left (standard <code>__stdcall</code> or <code>__cdecl</code> convention used in Windows APIs, though this may vary).</li>
</ul>
</li>
</ul>
</li>
<li><code>SYSCALL</code> (64-bit Systems): The instruction used on modern 64-bit processors.
<ul>
<li>The system call number is placed in the <code>RAX</code> register</li>
<li><code>RCX</code> contains the first parameter to the kernel function</li>
<li><code>RDX</code> contains the second parameter</li>
<li><code>R8</code> and <code>R9</code> contain the 3rd and 4th respectively</li>
<li>Additional parameters are pushed onto the stack, from right to left.</li>
</ul>
</li>
</ul>
<div id="admonition-note-12" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-12-title">
<div class="admonition-title">
<div id="admonition-note-12-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-12"></a>
</div>
<div>
<p><code>SYSCALL</code> adheres to a more optimized calling convention, known as <code>__fastcall</code></p>
</div>
</div>
<ul>
<li><code>INT 0x2E</code> (Older 32-bit systems): Before <code>SYSENTER</code>, the standard method for a system call was a software interrupt instruction. We reviewed this previously.</li>
</ul>
<h3 id="transitioning-from-ring-0-to-ring-3"><a class="header" href="#transitioning-from-ring-0-to-ring-3">Transitioning from Ring 0 to Ring 3</a></h3>
<ul>
<li><code>SYSEXIT</code> (32-bit systems): The counterpart to <code>SYSENTER</code>. It takes a return address and a stack pointer from the specified registers (<code>ecx</code> and <code>edx</code>), and transitions the CPU back to Ring 3, returning control to the user-mode process.</li>
<li><code>SYSRET</code> (64-bit systems): The counterpart to <code>SYSCALL</code>. It loads the return address and stack pointer from saved registers, switches the CPU back to Ring 3, and resumes execution in user mode.</li>
</ul>
<h3 id="protection-rings-and-the-system-call-process"><a class="header" href="#protection-rings-and-the-system-call-process">Protection Rings and the System Call Process</a></h3>
<p>The protection rings are the fundamental enforcer of the System call process, ensuring that the transition is secure and controlled. Here is the process:</p>
<ol>
<li>
<p><strong>User-Mode Preparation and the <code>SYSCALL</code> Trap (Ring 3-&gt;0)</strong>:
A user application calls a high-level API (i.e., <code>CreateFile</code>), which is a wrapper for a low-level Native API function in <code>ntdll.dll</code> (<code>NtCreateFile</code>). This function prepares for the system call by loading the unique system call number into the appropriate register (<code>eax</code>/<code>rax</code>), loading the function parameters into the proper location based on the calling convention (<code>__cdecl</code>/<code>__fastcall</code>), and executing the system call instruction (<code>SYSCALL</code>, <code>SYSENTER</code>, etc.). The system call instruction traps the CPU into <code>Ring 0</code> and transfers control to a predefined entry point in the kernel.</p>
</li>
<li>
<p><strong>The Kernel's System Service Dispatcher (Ring 0)</strong>:
The first piece of kernel code to execute after a <code>SYSCALL</code> trap is a small, highly optimized routine called the <strong>System Service Dispatcher</strong>. On 64-bit and modern 32-bit systems, this is <code>KiSystemCall64</code>. On older 32-bit systems, this was <code>KiSystemService</code> and <code>KiFastSystemCall</code>. The core responsibilities of this dispatcher are to:
_ <strong>Save State</strong>: Create a trap frame on the kernel stack, which saves all of the user-mode register values, including the IP and SP, so the system can return to the exact point in the user application that made the call.
_ <strong>Validate the System Call</strong>: Check the system call number to ensure it is valid and within the expected range. * <strong>Determine the Target Function</strong>: <code>KiSystemCall64</code> uses the system call number to find the address of the actual kernel function to execute, using the <code>KiServiceTable</code>.</p>
</li>
<li>
<p><strong>The <code>KiServiceTable</code> and the System Service Descriptor Table (Ring 0)</strong></p>
</li>
</ol>
<p>The <code>KiServiceTable</code> is the primary System Service Dispatch Table. It is a large array of pointers to actual kernel functions that implement the Native APIs. These functions reside in <code>ntoskrnl.exe</code> and <code>win32k.sys</code>. The system call number passed in the <code>RAX</code>/<code>EAX</code> register is used as an index into this array. The dispatcher uses this number to lookup the correct function pointer in the <code>KiServiceTable</code>.</p>
<p>Previously, the location of the <code>KiServiceTable</code> was accessible through the <code>KeServiceDispatcherTable</code>. When a system call was made, <code>KiFastSystemCall</code> would query <code>KeServiceDispatcher</code> to identify the location of the <code>KiServiceTable</code>, allowing it to index the table and locate the appropriate kernel function in memory. Windows 10+ systems have updated this, and now the location of <code>KiServiceTable</code> is not exposed through any exported data structure. The location is randomized and hidden to prevent easy access from reverse-engineering tools and malware.</p>
<p>So, on modern 64-bit systems, <code>KiSystemCall64</code> uses a System Service Descriptor Table in a random, hidden location to query <code>KiServiceTable</code>, which contains pointers to the memory addresses of the kernel functions. 64-bit systems also implement a <code>KeServiceDescriptorTableShadow</code> file, which is documented, but hidden using <strong>Kernel Address Space Layout Randomization</strong>. It is used primarily for graphical and windowing-related system calls (i.e. from <code>win32k.sys</code>, <code>win32kbase.sys</code> and <code>win32kfull.sys</code>). <code>KeServiceDescriptorTableShadow</code> points to a separate dispatch table, <code>W32pserviceTable</code>, which contains functions implemented in the Win32k family.</p>
<p>In order to determine which dispatch table the system call number indexes, the system call number is analyzed and split into 3 section:</p>
<pre><code>31                             14 13  12 11              0
+--------------------------------+---+--+---------------+
|        Reserved/Ignored        |  TS  | Service Index |
+--------------------------------+---+--+---------------+

 &lt;------------------------------&gt; &lt;----&gt; &lt;--------------&gt;
           ~18 Bits               2 Bits     12 Bits
                               (Bits 12 &amp; 13)
</code></pre>
<ul>
<li><strong>Reserved/Ignored</strong>
<ul>
<li>Bits 14-31 ≈18 bits</li>
<li>Reserved or ignored.</li>
</ul>
</li>
<li><strong>Service Table Index</strong> (TS)
<ul>
<li>Bits 12-13 =2 bits</li>
<li>Selects one of the four possible System Service Dispatcher Tables.
<ul>
<li><code>00</code>: <code>KiServiceTable</code></li>
<li><code>01</code>: <code>W32pServiceTable</code></li>
<li><code>10</code>: <code>Configuration Service Table</code> (a special subset of <code>w32pServiceTable</code>)</li>
<li><code>11</code>: Reserved\Ignored</li>
</ul>
</li>
</ul>
</li>
<li><strong>Service Index</strong> (Func. ID)
<ul>
<li>Bits 0-11 =12 bits</li>
<li>The specific index (function ID) into the chosen service table.</li>
</ul>
</li>
</ul>
<div id="admonition-note-13" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-13-title">
<div class="admonition-title">
<div id="admonition-note-13-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-13"></a>
</div>
<div>
<p><strong>For Example</strong>:
<code>NtCreateFile</code> has a system call number of <code>0x55</code> on Windows 10.</p>
<pre><code>
// In binary, 0x55 is 010100000101b:

31 12 0
+------------------+--+------------+
|000000000000000000|00|010100000101|
+------------------+--+------------+

&lt;----------------&gt; &lt;&gt; &lt;----------&gt;
Reserved TS Call Num

</code></pre>
<p>As we can see, the <code>TS</code> bits are set to <code>0</code>, which informs <code>KiSystemCall64</code> that this system call number is indexed within <code>KiServiceTable</code>.</p>
</div>
</div>
<ol start="4">
<li><strong>Execution and Return (Ring 0-&gt;3)</strong>
Once the System Service Dispatcher (i.e., <code>KiSystemCall64</code>, <code>KiFastSystemCall</code>, etc.) finds the correct pointer, it jumps to the kernel function, executes the service, and returns control back to the System Service Dispatcher, which restores the saved user-mode state from the trap frame, and uses <code>SYSRET</code> or <code>SYSEXIT</code> to transition the CPU back to Ring 3.</li>
</ol>
<h2 id="user-authentication-identification-and-privileges"><a class="header" href="#user-authentication-identification-and-privileges">User Authentication, Identification, and Privileges</a></h2>
<h3 id="user-authentication"><a class="header" href="#user-authentication">User Authentication</a></h3>
<p>User Authentication describes the process of verifying a user is who they claim to be. On Windows, it is a multi-step process involving several key components and protocols:</p>
<ul>
<li><code>winlogon.exe</code>: A critical Windows process responsible for managing the secure attention sequence (<code>Ctrl</code>+<code>Alt</code>+<code>Del</code>) and initiating the user logon process.
<ul>
<li>Presents the user logon interface</li>
<li>Collects the user's credentials (username and password)</li>
<li>Passes the user credentials to the <strong>Local Security Authority Subsystem Service</strong> (LSASS).</li>
<li>Found at <code>C:\Windows\System32\winlogon.exe</code></li>
</ul>
</li>
<li><strong>Local Security Authority Subsystem Service</strong> (LSASS): A protected subsystem that enforces the security policy on Windows systems.
<ul>
<li>When it receives the user's credentials from <code>winlogon.exe</code>, it performs the actual authentication by comparing the provided information against a stored database.</li>
</ul>
</li>
<li><strong>Security Accounts Manager</strong> (SAM): For local accounts, the LSASS service validates the credentials against the <strong>SAM</strong> database, a registry hive (<code>(HKEY_LOCAL_MACHINE\SAM)</code> -&gt; <code>C:\Windows\System32\config\SAM</code>) that stores user account and group information, including password hashes.</li>
<li><strong>Active Directory</strong>: For domain-joined machines, the authentication request is sent to a Domain Controller, which holds the centralized Active Directory database.</li>
</ul>
<h3 id="user-identification"><a class="header" href="#user-identification">User Identification</a></h3>
<p>Once a user is authenticated, the system identifies them using a unique <strong>Security Identifier</strong> (SID). An <strong>SID</strong> is a variable-length, cryptographically unique value that identifies a user, group, or computer account on a Windows system. It is created when the account is first created and exists as a core part of the system's security architecture, used by the operating system for access control decisions.</p>
<p><img src="https://hackmd.io/_uploads/rkvXfVF0el.png" alt="image" /></p>
<blockquote>
<p>Example of an <strong>SID</strong></p>
</blockquote>
<ul>
<li><strong>SID String</strong>: <code>S</code> indicates that the value is an SID.</li>
<li><strong>Revision Level</strong>: Indicates the version of the SID structure. It has been <code>1</code> since <code>Windows NT 3.1</code> in 1993.</li>
<li><strong>Authority ID</strong>: Speficies who created or granted the SID, as follows:
<ul>
<li><code>NULL</code>: 0</li>
<li><code>World Authority</code>: 1</li>
<li><code>Local Authority</code>: 2</li>
<li><code>Creator Authority</code>: 3</li>
<li><code>Non-unique Authority</code>: 4</li>
<li><code>NT Authority</code>: 5</li>
</ul>
</li>
<li><strong>Subauthority Identifier</strong>: A series of values that uniquely identify the account within the authority.</li>
<li><strong>Relative Identifier</strong> (RID): The final part of the SID that makes it unique. Windows will assign the following unique RIDs to specific users:
<ul>
<li><code>Administrator</code>: 500</li>
<li><code>Guest User</code>: 501</li>
<li><code>Domain Administrator</code>: 512</li>
<li><code>Domain Computer</code>: 515</li>
</ul>
</li>
</ul>
<p>You can enumerate the SIDs on a Windows system using:</p>
<pre><code class="language-asm64">$ wmic useraccount get name,sid
</code></pre>
<p>Pay attention to the RIDs, as they can be used to quickly identify administrators and guest accounts.</p>
<h3 id="access-tokens"><a class="header" href="#access-tokens">Access Tokens</a></h3>
<p>After successful authentication, LSASS generates an <strong>Access Token</strong>, which is a kernel object created by the <strong>Security Reference Monitor</strong> (SRM) that represents the security context of a principal. It contains all of the necessary information for the operating system to determine a user's rights and permissions. When a user runs a process, the process is assigned a copy of their access token, the user's SID, the SIDs of all the groups the user is a member of, a list of the user's privileges (i.e., <code>SeShutdownPriilege</code>), their Integrity Level and the <strong>Discretionary Access Control List</strong> (DACL) being used. A lot of the information within the access token can be viewed using the following command:</p>
<pre><code class="language-asm64">$ whoami /all
</code></pre>
<p>All child processes inherit a copy of the access token from their parent process, which is how the security context is maintained throughout a user's session.</p>
<h3 id="authentication-protocols"><a class="header" href="#authentication-protocols">Authentication Protocols</a></h3>
<h4 id="new-technology-lan-manager-ntlm"><a class="header" href="#new-technology-lan-manager-ntlm">New Technology LAN Manager (NTLM)</a></h4>
<ul>
<li><strong>How it Works</strong>:
<ol>
<li>Client sends authentication request to server</li>
<li>Server sends client a challenge (random number)</li>
<li>Client encrypts the challenge using a hash of its password (NT Hash)</li>
<li>Client sends encrypted challenge to server</li>
<li>Server decrypts the response payload using the clients hash and compares the retrieved value with the challenge to verify authenticity.</li>
</ol>
</li>
<li><strong>NTLMv2</strong>: An updated version of NTLM that upgrades security in a number of ways, including stronger cryptographic hashing and a timestamp in the challenge response mechanism to mitigate replay attacks. Still less secure than Kerberos.</li>
</ul>
<h4 id="kerberos"><a class="header" href="#kerberos">Kerberos</a></h4>
<ul>
<li><strong>Kerberos</strong>: The default and preferred authentication protocol for Active Directory environments.</li>
<li><strong>How it Works</strong>:
<ol>
<li>A user authenticates with the <strong>Key Distribution Center</strong> (KDC)</li>
<li>The KDC issues a <strong>ticket-granting ticket</strong> (TGT) to the client to the client.</li>
<li>The user uses the TGT to request <strong>Service Tickets</strong> to access different resources without re-entering their password.</li>
</ol>
</li>
<li>Kerberos uses mutual authentication and tickets are timestamped. More information on Kerberos can be found in <code>Appendix C: A Primer on Kerberos</code>.</li>
</ul>
<h3 id="privileges-granular-control-over-system-operations"><a class="header" href="#privileges-granular-control-over-system-operations">Privileges: Granular Control over System Operations</a></h3>
<p>A <strong>Privilege</strong> represents a specific right that allows a security principal to perform a system-wide operation that goes beyond standard file or object access permissions.</p>
<div id="admonition-note-14" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-14-title">
<div class="admonition-title">
<div id="admonition-note-14-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-14"></a>
</div>
<div>
<p>A <strong>Security Principal</strong> is an identity that can be authenticated and. authorized to access resources. This is someone or something the OS can assign permissions to, including:</p>
<ul>
<li>User Accounts</li>
<li>Groups</li>
<li>Computer Accounts</li>
<li>Service Accounts</li>
<li>Managed Service Accounts
Each security principal has a unique SID and they are represented by access tokens</li>
</ul>
</div>
</div>
<p>Privileges are powerful rights that are distinct from ACL permissions on individual objects. ACLs may dictate who can read/write to a specific file, but a privilege dictates who can perform a broader system action (i.e., loading a driver, shutting down the computer, etc.)</p>
<p>Some common privileges are:</p>
<ul>
<li><code>SeTimeZonePrivilege</code>: Grants a user the right to change the system's time zone</li>
<li><code>SeShutdownPrivilege</code>: Allows a user to shut down or restart the local computer</li>
<li><code>SeDebugPrivilege</code> (Highly Sensitive): Grants the right to debug processes owned by other users or the operating system itself. Often leveraged for privilege escalation.</li>
<li><code>SeTakeOwnershipPrivilege</code> (Highly Sensitive): Allows a user to take ownership of any securable object, regardless of existing ACLs. Can be used to bypass security on files, registry keys, etc.</li>
<li><code>SeRestorePrivilege</code> (Extremely Sensitive): Grants the right to load and unload device drivers. Extremely powerful, as loading a malicious kernel driver grants complete control over the system (Ring 0 access).</li>
<li><code>SeCreateTokenPrivilege</code> (Extremely Sensitive): Allows a process to create a primary token or an impersonation token, effevtively enabling the creation of arbitraty access tokens to impersonate any user with any privilege and any domain group membership. <strong>God-mode</strong> privilege for identity manipulation.</li>
</ul>
<h4 id="enabling-privileges-within-a-processs-access-token"><a class="header" href="#enabling-privileges-within-a-processs-access-token">Enabling Privileges Within a Process's Access Token</a></h4>
<p>Even if a user has been granted a privilege, a process running under that user's context does not automatically use that privilege. By default, most privileges in a process's access token are in the <strong>disabled</strong> state. To use a privilege, a process must explicitly enable it within its own access code, using the <code>AdjustTokenPrivileges()</code> API function:</p>
<ol>
<li><strong>Open Process Token</strong>: The process first needs to open its own access token, using <code>OpenProcessToken</code>.</li>
<li><strong>Lookup Privilege LUID</strong>: The processor needs to find the <strong>Local Unique Identifier</strong> (LUID) for the desired privilege (i.e., <code>SeDebugPrivilege</code>) using <code>LookupPrivilegeValue</code>
<ul>
<li>The <strong>LUID</strong> is a locally unique 64-bit identifier used to refer to a privilege</li>
</ul>
</li>
<li><strong>Adjust Token Privileges</strong>: Finally, the process calls <code>AdjustTokenPrivileges</code>, by passing the LUID and specifying that the privilege should be enabled (<code>SE_PRIVILEGE_ENABLED</code>).</li>
<li><strong>Failure if Not Granted</strong>: If the privilege has bot been granted to the security principal in the first place, <code>AdjustTokenPrivileges</code> will fail, indicating that the process does not have the right to enable it.</li>
</ol>
<h4 id="verifying-privileges"><a class="header" href="#verifying-privileges">Verifying Privileges</a></h4>
<p>When a process attempts to perform a system-related operation that requires a privilege, the operating system (or the specific kernel component handling the request) will verify that the necessary privilege is enabled in the caller's access token. The kernel function that performs the desired operation (i.e., <code>ZwCreateDebugObject</code> for debugging) will check the caller's access token for the appropriate privilege (i.e., <code>SeDebugPrivilege</code>) has the <code>SE_PRIVILEGE_ENABLED</code> flag set.</p>
<h4 id="privilege-data-structures"><a class="header" href="#privilege-data-structures">Privilege Data Structures</a></h4>
<ol>
<li><strong>LUID</strong>
This structure defines a 64-bit value that is guaranteed to be unique on the local system until it is rebooted. It is used to represent privileges internally.</li>
</ol>
<pre><code class="language-C">typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;
</code></pre>
<ol start="2">
<li><strong>LUID_AND_ATTRIBUTES</strong>
This structure specifies a LUID and its attributes (i.e., whether the privilege is enabled or disabled)</li>
</ol>
<pre><code class="language-C">typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES
</code></pre>
<p>Some common <code>Attributes</code> flags are:</p>
<ul>
<li><code>SE_PRIVILEGE_ENABLED</code>: The privilege is enabled</li>
<li><code>SE_PRIVILEGE_REMOVED</code>: The privilege was removed</li>
<li><code>SE_PRIVILEGE_USED_FOR_ACCESS</code>: The privilege was used to gain access</li>
<li><code>SE_PRIVILEGE_ENABLED_BY_DEFAULT</code>: The privilege is enabled by default</li>
</ul>
<ol start="3">
<li><strong>Token_Privileges</strong>
This structure contains an array of <code>LUID_AND_ATTRIBUTES</code> structures, representing a set of privileges with an access token. This is the structure used with <code>AdjustTokenPrivileges</code></li>
</ol>
<pre><code class="language-C">typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
}TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES
</code></pre>
<h4 id="discovering-and-manipulating-user-privileges"><a class="header" href="#discovering-and-manipulating-user-privileges">Discovering and Manipulating User Privileges</a></h4>
<ol>
<li><strong>Viewing Privileges in Your Current Process Token</strong></li>
</ol>
<pre><code class="language-asm64">$ whoami /priv
</code></pre>
<p>This is the easiest way to see what privileges your current user account has been granted and which are currently enabled in your current process's access token. <strong>Enabled</strong> means that the privilege is active and can be used by your process. <strong>Dissabled</strong> means that the privilege has been granted to your account but is not currently active in your process's token. You would need <code>AdjustTokenPrivileges</code> in your code to enable it. If the privilege has not been listed it has not been granted.</p>
<ol start="2">
<li><strong>Listing User Rights Assignments (Privileges) for Accounts</strong>
You can export the entire local security policy, including user rights assignments, using secedit:</li>
</ol>
<pre><code class="language-asm64">$ secedit /export /cfg [save_loc] /areas USER_RIGHTS
</code></pre>
<p>where, <code>save_loc</code> is the location of the saved file + name (i.e, <code>C:\Windows\in\secpol.inf</code>)</p>
<ol start="3">
<li><strong>Manipulating User Rights Assignments</strong>
<code>ntrights.exe</code> is a valuable tool, which can be used to grant a privilege to a user or revoke a privilege from a user, however it is not included .</li>
</ol>
<h2 id="the-windows-registry"><a class="header" href="#the-windows-registry">The Windows Registry</a></h2>
<p>The <strong>Windows Registry</strong> is a centralized, hierarchical database used by the operating system and applications to store configuration settings, user preferences, and a wealth of other information. It plays a vital role in facilitating many aspects of system operation, fro startup to user interaction:</p>
<h3 id="process-initialization-and-executable-loading"><a class="header" href="#process-initialization-and-executable-loading">Process Initialization and Executable Loading</a></h3>
<p>The registry contains keys that dictate which programs and services should run when the system boots or when a user logs on. For instance:</p>
<ul>
<li>
<p><code>Run</code>: Programs registered here will start on every logon. They are persistent until removed manually. They can be found at:
<img src="https://hackmd.io/_uploads/rJjVOw50eg.png" alt="image" />
_ <code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code>
_ <code>HKLM\Software\Microsoft\Windows\CurrentVersion\Run</code></p>
</li>
<li>
<p><code>RunOnce</code>: Programs registered here will start only once at the next logon, and Windows deletes the registry value after execution.
<img src="https://hackmd.io/_uploads/H16Eav9Axe.png" alt="image" />
_ <code>HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>
_ <code>HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></p>
</li>
<li>
<p><code>Userinit</code>: Programs registeredhere tell <code>winlogon.exe</code> to run them after a successful logon. The default is <code>userinit.exe</code>. This happens before <code>Run</code>/<code>RunOnce</code>, which run after <code>explorer.exe</code> is launched.
<img src="https://hackmd.io/_uploads/Bkh3Cvq0gg.png" alt="image" />
_ <code>HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code>
_ <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code></p>
</li>
<li>
<p><strong>DLL Loading</strong>: DLLs are generally searched for by the Windows Loader using a search order (more on this in <code>Malware Essentials: DLL Highjacking</code>). However, in some instances the Windows registry plays a role in how/why DLLs are loaded. For example: * <code>KnownDLLs</code>: A list of DLLs that are always loaded form <code>System32</code> for security and performance (to prevent DLL preloading attacks. Located at <code>HKLM\SYSTEM\CurerntControlSet\Control\Session Manager\KnownDLLs</code>
<img src="https://hackmd.io/_uploads/rJsNWO5Axl.png" alt="image" /></p>
<pre><code>* `Appinit_DLLs` (historically): Tells `user32.dll` to load extra DLLs into every GUI process. This is mostly disabled by default now, as it allows malicious DLLs to be loaded into many processes automatically.
</code></pre>
</li>
</ul>
<h3 id="user-authentication-and-identification"><a class="header" href="#user-authentication-and-identification">User Authentication and Identification</a></h3>
<p>The Registry also contains data that plays a vital role in facilitating user authentication and identification processes. For example:</p>
<ul>
<li>
<p><strong>SAM Database</strong>: The <strong>Security Accounts Manager</strong> (SAM) database is loaded at <code>HKLM\SAM</code>.
<img src="https://hackmd.io/_uploads/HJBQfdqRgl.png" alt="image" /></p>
</li>
<li>
<p><strong>User Profiles and SIDs</strong>: The <code>HKEY_USERS</code> hive contains a subkey for each actively loaded user profile, identified by the user's SID. This is how the system stores user-specific settings, such as desktop appearance, application configuration, and network connections. When a user logs in, their profile hive is loaded into memory and linked to the <code>HKEY_CURRENT_USER</code> hive.
<img src="https://hackmd.io/_uploads/HkZFQO9Clx.png" alt="image" /></p>
</li>
</ul>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h3>
<p>The Windows Registry is used to facilitate certain functions of Memory Management on the system as well. For instance:</p>
<ul>
<li>
<p><strong>Paging File Configuration</strong>: The registry key <code>HKLM\SYSTEM\CurrentControlSet\Constrol\Session Manager\Memory Management</code> contains settings related to the virtual memory system, including the size and location of the paging file.
<img src="https://hackmd.io/_uploads/Byj8EdqAgl.png" alt="image" /></p>
</li>
<li>
<p><strong>System and Driver Information</strong>: The registry stores configuration information for device drivers under <code>HKLM\SYSTEM\CurrentControlSet\Services</code>. This information is accessed by the operating system's <strong>Plug and Play</strong> (PnP) manager during system startup and driver loading. It is an important connection to the memory management APIs, as it dictates how drivers are loaded into memory.
<img src="https://hackmd.io/_uploads/BJILSdqCex.png" alt="image" /></p>
</li>
</ul>
<h3 id="interacting-with-registry-values"><a class="header" href="#interacting-with-registry-values">Interacting with Registry Values</a></h3>
<p>You can <strong>set</strong> a registry value using the following command:</p>
<pre><code class="language-asm64">$ reg add "HKCU\Software\Test" /v Setting /t REG_SZ /d "Hello, World!"
</code></pre>
<p>Where:</p>
<ul>
<li><code>HKCU</code>: Shorthand for "HKEY_CURRENT_USER"</li>
<li><code>/v Setting</code>: Specifies the value name ("Setting")</li>
<li><code>/t REG_SZ</code>: Specifies the data type as a string</li>
<li><code>/d "Hello, World!"</code>: Specifies the data to be written</li>
</ul>
<p>You can <strong>get</strong> a registry value using the following command:</p>
<pre><code class="language-asm64">$ reg query "HKCU\Software\Test" /v "Setting"
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>HKEY_CURRENT_USER\Software\Test
    Setting    REG_SZ    Hello, World!
</code></pre>
<p>You can <strong>delete</strong> a registry value using the following command:</p>
<pre><code class="language-asm64">reg delete "HKCU\Software\Test" \v Setting /f
</code></pre>
<p><strong>Where</strong>:</p>
<ul>
<li><code>/f</code>: The force flag, which prevents an "Are you sure" prompt</li>
</ul>
<h2 id="enumerating-windows-systems"><a class="header" href="#enumerating-windows-systems">Enumerating Windows Systems</a></h2>
<p><strong>Enumeration</strong> is the process of gathering information about a system including the operating system and hardware, the users and groups, the security configuration, and the network configuration.</p>
<h3 id="os-and-hardware-enumeration"><a class="header" href="#os-and-hardware-enumeration">OS and Hardware Enumeration</a></h3>
<p>System enumeration on Windows is relatively simple. A few commands can expose a lot of information about the system, given the right permissions.</p>
<p><code>systeminfo</code> is a very useful, built-in command that uncovers a lot of details, including:</p>
<ul>
<li>The <strong>Operating System</strong>, its <strong>Version</strong>, and its <strong>Build</strong></li>
<li>The <strong>System Manufacturer</strong> and the <strong>CPUs</strong> installed</li>
<li>The <strong>Total Physical Memory</strong> and the <strong>Physical Memory Available</strong></li>
<li>The <strong>Virtual Memory In Use</strong> and the <strong>Virutal Memory Available</strong></li>
<li>The location of the <strong>Page File</strong></li>
<li>The <strong>Network Cards</strong> installed, their assigned <strong>IP Addresses</strong>, and their default <strong>DHCP Servers</strong></li>
</ul>
<p><img src="https://hackmd.io/_uploads/r1rsP0xyWx.png" alt="image" /></p>
<p>Clearly, <code>systeminfo</code> can be a very powerful tool. It becomes even more useful when used in combination with <code>findstr</code>:
<img src="https://hackmd.io/_uploads/SJN43Rx1Wx.png" alt="image" /></p>
<p>Where:</p>
<ul>
<li><code>findstr</code>: A Windows command-line utility, which can be used to identify strings within files and file streams, similar to <code>grep</code> on UNIX systems.</li>
<li><code>/I</code>: Case insensitive search</li>
<li><code>/C:[text]</code>: Exact string literal search</li>
<li><code>/B</code>: Search for string at the beginning of a line</li>
<li><code>/R</code>: Search string is a regular expression</li>
</ul>
<p><code>systeminfo</code> and <code>findstr</code> can be a great tool for identifying hotfixes that have been installed on the system. A <strong>Hotfix</strong> is a small, targeted system update that aims to solve a particular issue without requiring a full service pack or a major software release. Identifying hotfixes can inform decisions about establishing persistence, using techniques to escalate privileges, and evading malware detection systems:
<img src="https://hackmd.io/_uploads/HJ5gxy-1Wl.png" alt="image" /></p>
<p><strong>Hotfixes</strong> can also be identified using the <strong>Windows Management Instrumentation Command-line</strong> (WMIC) utility. WMIC is a build-in Windows command that allows users to query and manage various settings and system information from the command line:
<img src="https://hackmd.io/_uploads/Sya9HyW1be.png" alt="image" />
Where:</p>
<ul>
<li><code>WMIC</code>: Windows Management Instrumentation Command-line**</li>
<li><code>qfe</code>: Quick Fix Engineering (hotfixes)</li>
<li><code>get</code>: Retrieves a set of given properties from the records of the queried data set.</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="#admonition-warning"></a>
</div>
<div>
<p><code>wmic</code> <strong>has been deprecated on Windows 10+</strong> and is not included on clean installations of <strong>Windows 11 24H2+</strong>. This was primarily because it was old, and presented a security liability as it's operations were poorly documented. However, WMI still plays an important role in managing and querying the configuration and state of Windows Systems. It can now be interacted with using <strong>Common Information Model</strong> interfaces, which provide a standard, object-oriented way of querying WMI directly within PowerShell (rather than using the <code>wmic.exe</code> program).</p>
<p><img src="https://hackmd.io/_uploads/HkTg6nD-Wx.png" alt="image" /></p>
</div>
</div>
<p><code>wmic</code> is capable of identifying much of the same info as <code>systeminfo</code>, including information about the CPU, the hardware specifications, the BIOS, and the Operating System:
<img src="https://hackmd.io/_uploads/H1QES1-J-e.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_OperatingSystem \
| Select-Object BuildNumber, Name, InstallDate
</code></pre>
<p><code>wmic</code> can also be used to retrieve the environment variables that are stored on the system, similar to <code>printenv</code> on UNIX systems:
<img src="https://hackmd.io/_uploads/rkBuNkZ1Wg.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_Environment \
| Select-Object Name, VariableValue
</code></pre>
<p>Importantly, <code>wmic</code> can be used to list the running processes and related information:
<img src="https://hackmd.io/_uploads/rkLTElbk-x.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_Process \
| Select-Object ProcessID, ExecutablePath, WorkingSetSize
</code></pre>
<p>Although it is less verbose, the <code>tasklist</code> command can be used to achieve the same objective:
<img src="https://hackmd.io/_uploads/H1qA9JZy-g.png" alt="image" />
Where:</p>
<ul>
<li><code>tasklist</code>: A built-in Windows command that displays a list of processes currently active on the system.</li>
</ul>
<p>You can also list the services being run under a particular process, using the <code>/SVC</code> option:
<img src="https://hackmd.io/_uploads/SJUtUJbyZx.png" alt="image" /></p>
<p>As we can see, there are a number of tools we can use to find information about the system, built into the operating system.</p>
<h3 id="user-and-group-enumeration"><a class="header" href="#user-and-group-enumeration">User and Group Enumeration</a></h3>
<p>Previously, we discussed the <code>whoami</code> tool and its role in revealing information about principals, access tokens, and privileges on the system. This is a form enumeration. <code>whoami</code> has many capabilities, including the ability to list what groups the current account is a part of:
<img src="https://hackmd.io/_uploads/Hy-GnJ-ybg.png" alt="image" /></p>
<p><code>wmic</code> can also be used for user and group enumeration. We previously saw how <code>wmic</code> can be used to identify the <code>SID</code> of every principal on the system:
<img src="https://hackmd.io/_uploads/BkF7lxW1We.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_UserAccount \
| Select-Object Name, SID
</code></pre>
<p>Similarly, <code>wmic</code> can be used to list every group that can be found on the system:
<img src="https://hackmd.io/_uploads/B1FSkebkbg.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_OperatingSystem \
| Select-Object BuildNumber, Name, InstallDate
</code></pre>
<p>We can follow this up by using the <code>net</code> command to determine which users are a part of any given group:
<img src="https://hackmd.io/_uploads/r1ra1xZy-l.png" alt="image" /></p>
<p>To find credentials for user, system, and domain accounts, we need to enumerate systems and domains. For instance, <code>cmdkey</code> can be used to display all of the credentials currently saved by the operating system for automatic access to network resources, websites, and other secured locations:
<img src="https://hackmd.io/_uploads/ByjGu1qWbx.png" alt="image" /></p>
<p>We can also quickly search through various types of files for references to passwords, in order to learn more about password rules, properties, and (in some unique cases) cleartext password values using the <code>findstr</code> command:</p>
<pre><code class="language-PowerShell">PS C:\&gt; findstr /si password *.doc *.txt *.ini *.config
</code></pre>
<p>This can be expanded upon by searching for the <code>pass</code> phrase within configuration files for certain services:
<img src="https://hackmd.io/_uploads/BJ6m5E5bZl.png" alt="image" /></p>
<p>We may be able to find user credentials saved in certain registry keys, under both <code>HKLM</code> and <code>HKCU</code>:
<img src="https://hackmd.io/_uploads/BJG5q4qWZe.png" alt="image" /></p>
<p>Try looking for passwords at <code>C:\Users\&lt;username&gt;\AppData\Local\</code> as well. This directory contains data for locally installed apps. Certain applications, like web browsers keep track of user data and save it in their own private directory structure. Consider <code>Microsoft Edge</code>, a Chromium based web-browser that comes pre-installed on Windows. It keeps important data stored here: <code>C:\Users\&lt;username&gt;\AppData\Local\</code>, including things such as:</p>
<ul>
<li>User History</li>
<li>Autofill Web Data</li>
<li>Cookies</li>
<li>User Credentials</li>
</ul>
<p>Although much of this data is encrypted using DPAPI, capturing the encrypted data is the first step toward obtaining the unencrypted credentials.</p>
<p>User enumeration is extremely important, as it informs operators about their current context as a user, which other accounts exist on a system, and the levels of privilege they may be able to escalate to.</p>
<h3 id="network-enumeration"><a class="header" href="#network-enumeration">Network Enumeration</a></h3>
<p>The main command for network operations is <code>ipconfig</code>. Although it is capable of many things, for network enumeration there are two options to focus on.</p>
<p>First, to show the full details of every network, use the <code>/all</code> option:
<img src="https://hackmd.io/_uploads/rk_oIu-1be.png" alt="image" />
This provides important information about the connected network interfaces, including their DHCP connection details, default DNS servers, and assigned MAC addresses.</p>
<p><code>ifconfig</code> can also be used to gather information about the local DNS cache:
<img src="https://hackmd.io/_uploads/rkVa_u-1-e.png" alt="image" /></p>
<p><code>wmic</code> is also extremely useful for network enumeration. It can gather information about the network interfaces, available network protocols, and active network connections.
<img src="https://hackmd.io/_uploads/S18hMeWJZx.png" alt="image" />
<img src="https://hackmd.io/_uploads/S1UfjdW1be.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalents are:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_NetworkAdapter \
| Select-Object AdapterType, InterfaceIndex, MacAddress

PS&gt; Get-CimInstance -ClassName Win32_NetworkConnection \
| Select-Object Name, Status, ConnectionType
</code></pre>
<p>Finally, you can monitor active network connections using the <code>netstat</code> utility:
<img src="https://hackmd.io/_uploads/rJkuRO-1be.png" alt="image" /></p>
<p><code>netstat</code> can also be used to view the routing table on the system, showing you how the system decides where to send packets:
<img src="https://hackmd.io/_uploads/HJ3BJF-yWl.png" alt="image" /></p>
<p>Network enumeration is important because it shows how a single system is connected to other computer systems. It gives you an idea of how any given system can communicate, and to who with what privileges. As a red team operation continues to grow in scale, this becomes incredibly important as it gives context to what other systems may be available to compromise.</p>
<h3 id="enumerating-security-systems"><a class="header" href="#enumerating-security-systems">Enumerating Security Systems</a></h3>
<p>Windows Defender is an anti-virus software that comes pre-installed on Windows 10+ systems. We will take a more in depth look at how it works later. For now, we can check the status of the service using the <code>sc</code> command. There is one problem though. PowerShell has a cmdlet called <code>Set-Content</code>, which will write or replace the contents of a file. This cmdlet uses <code>sc</code> as a shorthand, so in order to run <code>sc.exe</code> you must either provide the entire executable name or run the command outside of PowerShell, in <code>cmd.exe</code>:
<img src="https://hackmd.io/_uploads/H1yeRpu-We.png" alt="image" /></p>
<blockquote>
<p>Using <code>sc.exe</code> to query the Service Control Manager about <code>WinDefend</code></p>
</blockquote>
<p><img src="https://hackmd.io/_uploads/SymSCT_-We.png" alt="image" /></p>
<blockquote>
<p>Using <code>cmd /c</code> to query the <strong>Service Control Manager</strong> (SCM) about <code>WinDefend</code></p>
</blockquote>
<p>Details about the configuration of a particular service can be queries using <code>sc qc &lt;servicename&gt;</code>:
<img src="https://hackmd.io/_uploads/rkL6TZyM-e.png" alt="image" /></p>
<p>More security services can be found by querying the SCM for any services that are running:</p>
<pre><code class="language-PowerShell">PS&gt; sc.exe queryex type=service
</code></pre>
<p>Some example services include:</p>
<ul>
<li>
<p><strong>Base Filtering Engine</strong> (<code>BFE</code>): A critical user-mode Windows Service, which implements and enforces all of the filtering policies for firewalls, antivirus products, and traffic inspection tools. It is an important part of the <strong>Windows Filtering Platform</strong> (WFP).
<img src="https://hackmd.io/_uploads/HyzPKAdWZx.png" alt="image" /></p>
</li>
<li>
<p><strong>Windows Event Log</strong> (<code>EventLog</code>): A Windows Service, which is responsible for accepting event log files from applications, the OS kernel, and drivers and aggregating them in a centralized, hierarchical location (<code>C:\Windows\System32\winevt\Logs</code>). Importantly, it records security related events, such as:</p>
<ul>
<li>Successful or failed user login/logoff attempts</li>
<li>Object Access</li>
<li>Changes to the Security Policy</li>
</ul>
<p><img src="https://hackmd.io/_uploads/Skx1iROWZx.png" alt="image" /></p>
</li>
<li>
<p><strong>Windows Defender Firewall</strong> (<code>mpssvc</code>): Also known as the <strong>Microsoft Protection Service</strong>, it is the main executable which runs the logic for the Windows Firewall. It creates low-level filter objects and passes them to the <strong>BFE</strong> using WFP APIs so they can be enforced.
<img src="https://hackmd.io/_uploads/BJnWa0dbZl.png" alt="image" /></p>
</li>
<li>
<p><strong>Security Accounts Manager</strong> (<code>SamSs</code>): The service which manages the <strong>SAM Database</strong> and is used by the <strong>Local Security Authority Subsystem Service</strong> to verify user credentials.
<img src="https://hackmd.io/_uploads/S1FQCAd-Wl.png" alt="image" /></p>
</li>
<li>
<p><strong>Windows Security Service</strong> (<code>SecurityHealthService</code>): The Windows Service responsible for managing the user interface for Windows Security, running all of the background processes that allow the Windows Security UI to interact with all underlying security providers, and aggregating security status information from these providers, including:</p>
<ul>
<li>Windows Defender Antivirus</li>
<li>Windows Firewall</li>
<li>User Account Control Settings</li>
<li>SmartScreen Status</li>
<li>Application and Browser Control Settings
When a user interacts with the UI, <code>SecurityHealthService</code> is responsible for relaying that command to the appropriate underlying service.
<img src="https://hackmd.io/_uploads/B1Vayyt-Zg.png" alt="image" /></li>
</ul>
</li>
</ul>
<p>Plenty of other security services can be found by inspecting the output of this command.</p>
<p><code>netsh</code> can be used to locally or remotely interact with network components, including network services. It is particularly useful for enumerating and managing firewall rules. The <code>netsh advfirewall show</code> command can be used to inspect the firewall properties of a given profile:
<img src="https://hackmd.io/_uploads/SkgXNJtZbx.png" alt="image" /></p>
<p>An <strong>Access Control List</strong> (ACL) can be enumerated to determine the permissions granted to a security principal for a dynamic, running object managed by the OS kernel.</p>
<p>Let's consider the <code>Windefend</code> service for a moment:
<img src="https://hackmd.io/_uploads/rk1jRP2WWe.png" alt="image" />
Here, we can see that it is running on the system, it has a <strong>PID</strong> of <code>3268</code> and it can receive commands for stopping and cleanly exiting before shutdown. An additional query will detail the permissions granted to manage the service for different security principals:
<img src="https://hackmd.io/_uploads/By1Fgd3-Wx.png" alt="image" /></p>
<p>The provided output is not exactly readable. It is called a <strong>Security Descriptor Definition Language</strong> (SDDL) <strong>String</strong>. It can be divided into two distinct parts: the Structure and the <strong>Access Control Entries</strong> (ACEs):
<img src="https://hackmd.io/_uploads/rk9DU_3b-g.png" alt="image" /></p>
<p>The Structure value indicates which ACL is being displayed: the <code>DACL</code> or the <code>SACL</code>:</p>
<ul>
<li><code>DACL</code>: <strong>Discretionary Access Control List</strong>. Defines who is allowed or denied certain permissions.</li>
<li><code>SACL</code>: <strong>System Access Control List</strong>. Defines which user actions should be logged to the <strong>Windows Security Event Log</strong>.</li>
</ul>
<p>The Access Control Entries show the actual permissions given to a particular set of security principals. Within each entry, there are 6 sections:
<img src="https://hackmd.io/_uploads/S1N1njTZbe.png" alt="image" /></p>
<ul>
<li>
<p><code>Type</code>: Indicates whether the rule grants access or is for auditing.</p>
<ul>
<li><code>A</code> (DACL): Grants permissions for the specified <code>&lt;Rights&gt;</code>.</li>
<li><code>D</code> (DACL): Blocks permissions for the given <code>&lt;Rights&gt;</code>.</li>
<li><code>AU</code> (SACL): Defines auditing rules. Logs access attempts (success, failure, or both) depending on flags (<code>SA</code> or <code>FA</code>)</li>
</ul>
</li>
<li>
<p><code>Flags</code>: Determines how the ACE should be inherited by child objects. Particularly relevant for folder permissions.</p>
<ul>
<li><code>OI</code>: <strong>Object Inherit</strong>. Child objects that are not containers (like files) inherit the ACE.</li>
<li><code>CI</code>: <strong>Container Inherit</strong>. Child objects that are containers (like folders) inherit the ACE.</li>
<li><code>NP</code>: <strong>No Propogate</strong>. The inheritance stops after the first generation of child objects.</li>
<li><code>IO</code>: <strong>Inherit Only</strong>. The ACE only applies to child objects, not the object it is set on.</li>
<li><code>SA</code>: <strong>Successful Access</strong>. Logs an event if an attempted action succeeds.</li>
<li><code>FA</code>: <strong>Failed Access</strong>: Logs an event if an attempted action fails.</li>
</ul>
</li>
<li>
<p><code>Rights</code>: The set of permissions, depending on what type of object is being protected (file, folder, registry key, process, or service). They can be represented by mnemonic codes (like <code>FA</code>) or raw, hexadecimal values (like <code>0x1F01FF</code>). There are quite a few, but here we will list some which are relevant to processes/services:</p>
<ul>
<li><strong>CC</strong> <code>0x0001</code>: <strong>Query Config</strong>. Permission to read the configuration state of a given service.</li>
<li><strong>LC</strong> <code>0x0004</code>: <strong>Query Status</strong>. Permission to request the current status of a service from the SCM.</li>
<li><strong>SW</strong> <code>0x0008</code>: <strong>Enumerate Dependents</strong>. Permission to retrieve a list of services that depend on a given service.</li>
<li><strong>RP</strong> <code>0x0010</code>: <strong>Start</strong>. Permission to start the service.</li>
<li><strong>WP</strong> <code>0x0020</code>: <strong>Stop</strong>. Permission to stop the service.</li>
<li><strong>DT</strong> <code>0x0040</code>: <strong>Pause/Continue</strong>. Permission to pause or continue a service.</li>
<li><strong>LO</strong> <code>0x0080</code>: <strong>Interrogate</strong>. Permission to update the SCM with the current status of the service.</li>
<li><strong>CR</strong> <code>0x0100</code>: <strong>User Defined Control</strong>. Permission to send developer defined control codes to the service.</li>
<li><strong>RC</strong> <code>0x20000</code>: <strong>Read Control</strong>. Permission to read the given service's ACL.</li>
</ul>
<div id="admonition-note-15" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-15-title">
<div class="admonition-title">
<div id="admonition-note-15-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-15"></a>
</div>
<div>
<p><strong>You may have noticed</strong> that the mnemonics for most of the Service Access Rights (i.e., <code>LO</code> for <strong>Interrogate</strong>). A simple explanation is that <strong>SDDL</strong> strings are applied to many different types of objects and the permissions themselves are interpreted by different Object Managers to mean different things. Many mnemonics are used in circumstances outside of their original intention, but their raw hexadecimal values still have specific meaning. This is why a mnemonic like <code>CC</code> (<strong>Create Child</strong>) with a raw value of <code>0x0001</code> will grant configuration access rights. <code>CCLCSWRPWPDTLOCRRC</code> is the standard access right for granting full permission over a service to a security principal.</p>
</div>
</div>
</li>
<li>
<p><code>Object GUID</code>: <strong>Only used for Object Specific ACEs</strong>. Defines a specific object property to protect. Typically empty for processes/services.</p>
</li>
<li>
<p><code>Inherit GUID</code>: <strong>Only used for Object Specific ACEs</strong>. Defines the type of object that inherits the ACE. Typically empty for processes/services.</p>
</li>
<li>
<p><code>SID</code>: The <strong>Security Identifier</strong> (SID) for a given security principal (user, group, service) the permissions apply to. This value can also be represented by constant values:</p>
<ul>
<li><code>SY</code>: Local System (<code>NT Authority\System</code>)</li>
<li><code>BA</code>: Built in Administrator (<code>BUILTIN\Administrators</code>)</li>
<li><code>IU</code>: Interactive Users (Any user logged into the console)</li>
<li><code>SU</code>: Service Users (Any user logged on as a service)</li>
<li><code>WD</code>: Everyone (World)</li>
</ul>
</li>
</ul>
<p>Documentation on <code>SDDL</code> strings can be found within the <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-definition-language">Microsoft SDK Documentation</a>. <code>SDDL</code> values specific to services can be found <a href="https://learn.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights">here</a>. In some instances, a 7th <code>(resource-attribute)</code> section is used to define the data type, though this does not apply here.</p>
<p>Permissions for static objects can be read using <code>icacls</code>:
<img src="https://hackmd.io/_uploads/SylUyApZZx.png" alt="image" /></p>
<p>For the current directory <code>.</code>, each security principal has the <strong>Inherit Only</strong> (<code>I</code>), <strong>Object Inherit</strong> (<code>OI</code>), and <strong>Container Inherit</strong> (<code>CI</code>) flags set and has been granted <strong>Full Control</strong> (<code>F</code>) over the directory's objects.</p>
<p><strong>Scheduled Tasks</strong> are useful because they automate the execution of certain actions based on different triggers. They can be enumerated using the <code>schtasks</code> command:
<img src="https://hackmd.io/_uploads/SJh7RR6Wbx.png" alt="image" /></p>
<p>This can produce a lot of output. To check the status of a single scheduled task, use the <code>tn</code> (task name) option:
<img src="https://hackmd.io/_uploads/BySdCRTbbg.png" alt="image" /></p>
<p>You can use the <code>Get-ScheduledTask</code> PowerShell cmdlet to get information about all of the scheduled tasks in a particular folder:
<img src="https://hackmd.io/_uploads/BJWdJJRbbx.png" alt="image" /></p>
<h2 id="windows-security"><a class="header" href="#windows-security">Windows Security</a></h2>
<p><strong>Windows Security</strong> is the unified hub that consolidates the status, settings, and controls for several core system defense components, including:</p>
<ul>
<li><strong>Virus &amp; Threat Protection</strong> (Microsoft Defender Antivirus)</li>
<li><strong>Firewall &amp; Network Protection</strong></li>
<li><strong>Account Protection</strong></li>
<li><strong>App &amp; Browser Control</strong></li>
<li><strong>Device Security</strong></li>
</ul>
<p>Windows Security is the interface used to manage the low-level security services running on the operating system. The various components work together in a layered fashion to process information and enforce security policies.</p>
<p>Users or system policy can set rules via the UI. The <code>SecurityHealthService</code> receives these rules as input and passes them to the <strong>Microsoft Defender Service</strong> (<code>MsMpEng.exe</code>). The Defender engine runs at a privileged level, using kernel callbacks and filters to intercept file system operations and network traffic. When a scripting engine is about to execute code, it uses the <strong>Anti-malware Scan Interface</strong> (AMSI) to send the script content to the Defender before execution begins. If the code is malicious, Defender blocks it, preventing <strong>fileless malware</strong> from running. If Defender detects a threat, it performs some pre-configured action (quarantine, clean, block) and immediately sends an alert to <code>SecurityHealthService</code>, which then updates the status displayed in the UI.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<p>Windows Security is the interface, which allows users to monitor and configure different security services that run on the system. These services can be divided into 4 general categories:</p>
<ul>
<li><strong>Core Antivirus &amp; File Protection</strong></li>
<li><strong>Network &amp; Web Defense Services</strong></li>
<li><strong>Health &amp; Management Services</strong></li>
<li><strong>Advanced Controls</strong></li>
</ul>
<h4 id="core-antivirus--file-protection"><a class="header" href="#core-antivirus--file-protection">Core Antivirus &amp; File Protection</a></h4>
<p>The <strong>Microsoft Defender Antivirus Service</strong> (shortname <code>WinDefend</code>) is the most critical component of Windows Security as it performs all the fundamental tasks required for endpoint protection, including system monitoring, updating malware definitions, and scanning accessed files. Its main executable, <code>MsMpEng.exe</code> can usually be found here:
<code>C:\ProgramData\Microsoft\Windows Defender\Platform\&lt;version&gt;\MsMpEng.exe</code>. This can be verified using <code>sc.exe qc WinDefend</code>. Its primary responsibilities include:</p>
<ul>
<li><strong>Real-Time Protection</strong>: Actively monitoring all file system activity. When a file is created, opened, or executed, <code>MsMpEng.exe</code> intercepts the operation to scan the file before the system can process it.</li>
<li><strong>Signature-Based Detection</strong>: Compares the content of files and memory against its database of known malware signatures.</li>
<li><strong>Heuristic and Behavioral Analysis</strong>: Watches for activities that don't match a known signature for a legitimate program.</li>
<li><strong>AMSI Integration</strong>: Handles requests from the <strong>Anti-malware Scan Interface</strong>. When a scripting host is about to execute code, it passes the script to <code>MsMpEng.exe</code> for scanning and blocking, even if the script is completely fileless.</li>
<li><strong>Tamper Protection</strong>: A Defense-Hardening feature that ensures critical security settings cannot be disabled by malware or scripts. Supported by <code>WdBoot.sys</code> and <code>WdFilter.sys</code> kernel drivers, which guarantee that <code>MsMpEng.exe</code> can initialize in a protected environment and provide resilience against user‑mode tampering by ensuring malicious activity is blocked before reaching kernel-mode.</li>
<li><strong>Malware Remediation</strong>: Handles the quarantine, deletion, or cleaning of infected files, registry keys, and system configurations when malware is discovered.</li>
<li><strong>SmartScreen Application Checks</strong>: A reputation-based protection system which is deeply integrated into Microsoft Edge and blocks or warns users before they access phishing sites, malicious downloads, or suspicious apps by checking them against Microsoft's Threat Intelligence.</li>
<li><strong>Exploit Guard</strong>: A collection of four components that provides defense-in-depth on Windows systems. <code>Windefend</code> plays a role in configuring/managing each of them:
<ul>
<li><code>Attack Surface Reduction</code> (ASR): Manages and enforces rules which target specific risky events to prevent actions and behaviors commonly used by malware to infect machines. <code>MsMpEng.exe</code> uses its high privileges and minifilter drivers (<code>WdFilter.sys</code>) to intercept system calls and block high risk behaviors (i.e., blocking Office Apps from spawning child processes) before they can execute.</li>
<li><code>Exploit Protection</code>: Applies process mitigation techniques, such as <strong>Address Space Layout Randomization</strong>, <strong>Data Execution Prevention</strong>, and <strong>Control Flow Guard</strong>, making it harder for attackers to exploit vulnerabilities. While the core mitigations are handled by the Windows Kernel and Memory Manager, <code>MsMpEng.exe</code> and its associated components manage the policy and configuration for applying these mitigations to individual processes.</li>
<li><code>Controlled Folder Access</code> (CFA): Protects important files and folders from unauthorized changes, especially from ransomware and other malicious software that attempts to encrypt, modify, or delete data. <code>MsMpEng.exe</code> intercepts attempts to write or modify files in protected folders and compares the attempting process against the list of approved applications, blocking unauthorized access.</li>
<li><code>Network Protection</code>: Blocks outbound connections to malicious IP addresses and domains. <code>MsMpEng.exe</code> contains the necessary intelligence and communicates with the Network Inspection Service (<code>WdNisSvc</code>) to ensure that malicious connections are blocked at the network stack.</li>
</ul>
</li>
</ul>
<p><code>MsMpEng.exe</code> typically runs with very high privileges (<code>LocalSystem</code> or <code>NetworkService</code>). This is because it needs to reliably detect, block, or remove malware that hides in protected areas of the OS. To provide system-wide protection, it must monitor and intercept activity across the entire system - files, processes, registry keys, services, and network traffic. To do this requires kernel-level visibility and the ability to act on behalf of any user. To intercept file operations and network traffic, <code>MsMpEng.exe</code> uses minifilter drivers (i.e., <code>WdFilter.sys</code>), which require user-mode applications to have high privileges to facilitate direct coordination. If malware is detected, WinDefend may need to kill processes owned by other users, delete or quarantine files in protected system directories, or modify registry keys or system configurations. These actions require <code>LocalSystem</code> or <code>NetworkService</code> permissions.</p>
<p>The integrity and operational status of <code>MsMpEng.exe</code> is of the utmost importance, as if an adversary is able to disable or bypass this service, they have essentially disarmed the system's primary defense.</p>
<p>The <strong>Microsoft Defender Antivirus Reliability Service</strong> (shortname <code>dsSvc</code>) is responsible for maintaining the integrity of the Microsoft Defender Antivirus and its security intelligence. <code>dsSvc</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). It's system configuration information can be found at <code>HKLM\SYSTEM\CurrentControlSet\Services\DsSvc</code> and the DLL itself is typically found at <code>C:\Windows\System32\dssvc.dll</code>.</p>
<p>While <code>MsMpEng.exe</code> runs the core scanning logic, <code>dsSvc</code> handles the necessary reliability maintenance (self-healing, stability checks), ensuring that <code>MsMpEng.exe</code> is always running and recoverable. It's core responsibilities are:</p>
<ol>
<li>Supporting the broader Defender infrastructure by coordinating with the Service Control Manager to keep protection active and reliable.</li>
<li>Maintain the operational health and integrity of the core anti-malware platform and other associated Defender components.</li>
<li>Responsible for quickly restarting <code>MsMpEng.exe</code> or attempting to restore its functionality in the event that the service crashes, hangs, or is successfully terminated.</li>
</ol>
<p><code>dssvc</code> is a redundant supervisor which serves to protect the main system from certain operational failures. By having a separate, lightweight and dedicated service, Windows ensures that having a failure in the main defense process does not lead to a permanent, unprotected state.</p>
<h4 id="network--web-protections"><a class="header" href="#network--web-protections">Network &amp; Web Protections</a></h4>
<p>The <strong>Windows Defender Antivirus Network Inspection Service</strong> (shortname <code>WdNisSvc</code>) is a critical component of Windows Security that provides network-level protection by inspecting incoming and outgoing network traffic. It is the primary engine for <strong>Web Defense</strong> and <strong>Network Protection</strong> within the Defender suite. <code>NisSrv.exe</code> is the main executable for the service and it is typically located at <code>C:\ProgramData\Microsoft\Windows Defender\Platform\&lt;version&gt;\NisSrv.exe</code>. This can be verified using <code>sc.exe qc WdNisSvc</code>. <code>WdNisSvc</code> is triggered when real-time protection or exploit protection features are enabled. It monitors network packets and application traffic for suspicious patterns and if malicious activity is detected, it can block the connection, alert the user, and log the event in Defender's security history.</p>
<p><code>WdNisSvc</code> has two main responsibilities:</p>
<ul>
<li><strong>Monitoring Network Traffic</strong>: It intercepts network packets using the Base Filtering Engine <code>BFE</code>, then examines the content of the data stream for malicious patterns.</li>
<li><strong>Intrusion Prevention</strong>: It functions as a <strong>Host-based Intrusion Prevention System</strong> (HIPS) by checking traffic against Microsoft's threat intelligence, identifying and blocking network exploits, known attack payloads, and suspicious protocol activity.</li>
</ul>
<p><code>WdNisSvc</code> is crucial for network defense. Its main function is to act as a security layer deep within the Windows network stack, protecting the system before malicious data reaches the application layer (i.e., web browsers and email clients)</p>
<p>The <strong>Windows Defender Firewall</strong> (shortname <code>MpsSvc</code>) is the core system service responsible for implementing and enforcing the host-based firewall functionality on Windows. It controls which network traffic is allowed to enter or leave the system based on a set of administrator defined rules. <code>MpsSvc</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). It's system configuration information can be found at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MpsSvc</code>and its main library file <code>mpssvc.dll</code> can be found at <code>C:\Windows\System32\mpssvc.dll</code>.</p>
<p><code>MsSvc</code> starts automatically with Windows to ensure security from boot. Firewall rules are applied by the user, system defaults, and enterprise policies. Packets are blocked at the Network layer to block suspicious or unauthorized traffic. Blocked traffic and firewall activity are recorded in the <strong>Windows Event Log</strong>.</p>
<p><code>MpsSvc</code> has a few different responsibilities. First and foremost, it monitors all incoming and outgoing network communications on the host and applies security policy rules to determine whether to allow or block specific traffic. It also maintains a record of active network connections. That way, if an application sends some outbound traffic on the network, the inbound reply is automatically let through. <code>MpsSvc</code> can also inspect which application or process is trying to communicate and apply certain rules based on that application's executable path, digital signature or service name. Finally, it is capable of enforcing different sets of rules dynamically, based on the current network environment applied to the host: <strong>Domain</strong>, <strong>Private</strong>, or <strong>Public</strong> networks.</p>
<p><code>MpsSvc</code> relies entirely on the <strong>Base Filtering Engine</strong> (BFE) to enfoce the rules that it manages. Essentially, both <code>MpsSvc</code> and <code>WdNisSvc</code> create policies for the type of traffic that is allowed to enter/exit the system, based on the trust level of the applications and processes that wish to communicate over the network and the actual content within the packets being transmitted, respectively.</p>
<p>The <strong>Base Filtering Engine</strong> is a critical, fundamental system service that manages firewall and <strong>Internet Protocol Security</strong> policies and implements user mode filtering. It serves as the core networking infrastructure for many security-related features in Windows. Without it, the Windows Defender Firewall and other filtering features can not function. <code>BFE</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). Its system configuration information can be found at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BFE</code> and its main library file can be found at <code>C:\Windows\System32\bfe.dll</code>.</p>
<p><code>BFE</code> starts automatically with Windows, as <code>MpsSvc</code> and other networking features rely on it to function and they too need to be available at start. It provides an interface for user-mode applications to interact with the <strong>Windows Filtering Platform</strong> (WFP). WFP API calls are exposed through <code>C:\Windows\System32\fwpuclnt.dll</code> to client applications, although they are implemented as <strong>Remote Procedure Calls</strong>, meaning the actual code for each API call is found within the <code>BFE</code> service. <code>BFE</code> then makes the transition from user-mode to kernel mode by calling <code>DeviceIoControl</code> to pass the processed filtering policies to the <code>fwpkclnt.sys</code> kernel driver. <code>C:\Windows\System32\drivers\fwpkclnt.sys</code> is then responsible for injecting the code hooks into the network stack's data path, enforcing the policy rules. The resulting value gets passed back up the stack to the client application.</p>
<h4 id="health-ui-and-management"><a class="header" href="#health-ui-and-management">Health, UI, and Management</a></h4>
<p>The <strong>Windows Security Center Service</strong> (shortname <code>wscsvc</code>) monitors and reports security health settings on the computer, including the state of the firewall, antivirus, antispyware, Windows Update, User Account Control, and Internet Settings. also provides <strong>Component Object Model</strong> (COM) APIs, so that third-party software vendors can also report the state of their services to the <code>wscsvc</code>. Essentially, it acts as the central hub to ensure users and administrators are notified when essential protections are disabled or missing. <code>wscsvc</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). Its system configuration settings are stored at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\wscsvc</code> and its main library file can be found at <code>C:\Windows\System32\wscsvc.dll</code>.</p>
<p><code>wscsvc</code> starts with Windows to ensure continuous monitoring. It queries Windows Defender Antivirus, Firewall (MpsSvc), and Windows Update. It aggregates status information and reports it to the Windows Security UI, through the <code>SecurityHealthService</code>. If something is disabled or requires attention, it generates alert notifications in Windows Security. It doesn't block threats, but it makes sure you are informed about the state of your Windows Security Services. It should not be disabled, as it will stop notifications about disabled or missing security services.</p>
<p><code>SecurityHealthService</code> is a core background service in Windows 10+ that monitors the overall security posture of your system, ensuring that antivirus, firewall, updates, and other protection features are active and functioning correctly. It works in concert with the Windows Security Center Service to collect and manage health information, ensuring that the user interface (<code>SecHealthUI.exe</code>) provides the most up-to-date information about the protection status of the endpoint. It starts automatically with Windows and is required for the Windows Security app to display accurate information. It provides an interface API that third-party security services can use to register their product's status, ensuring that the Windows Security interface provides a unified view of all protective layers. It's executable file is stored at <code>C:\Windows\system32\SecurityHealthService.exe</code>.</p>
<p><code>SecHealthUI</code> is the user-facing client application that displays the health status of the lower-level Windows Security services. It consumes data provided by <code>SecurityHealthService</code> and other system APIs to show whether protections are active in a unified graphical user interface. It is also responsible for command dispatch. User actions are translated into commands that are dispatched to the appropriate low-level security services. This gives users and administrators the ability to monitor and configure all Windows Security services installed on the system in a centralized location.</p>
<p><img src="https://hackmd.io/_uploads/BkEGYUNMbl.png" alt="image" /></p>
<h4 id="advanced-control"><a class="header" href="#advanced-control">Advanced Control</a></h4>
<p>While <code>UAC</code> is a core Operating System feature, and not a component of Windows Security, together they contribute to the defense-in-depth approach on modern Windows systems. Essentially, <strong>User Account Control</strong> (UAC) is a system that prompts users to approve or deny changes initiated by actions that require a <strong>High Integrity Level</strong> (more on this in <code>Malware Essentials</code>), reducing the risk of malware or accidental modification. When a user attempts to take an action, the OS detects the elevation request and launches <strong>Consent UI</strong> (<code>consent.exe</code>). If the user is admin, they must approve or deny. If the user is standard, they must provide admin credentials. Once approved, the operation is conducted with elevated privileges.
<img src="https://hackmd.io/_uploads/By_0R8NG-x.png" alt="image" /></p>
<p>Similarly, the <strong>Windows Updater</strong> is not a component of <strong>Windows Security</strong>, however the two components have an important role in maintaining the security of the system. Updater distributes operating system patches, feature upgrades, driver updates, and security fixes. This ensures that the OS and its components are current, closing vulnerabilities and improving stability. Vulnerabilities in Windows Security services are fixed through updates, along with malware definitions and engine updates. The service name is <code>wuauserv</code> and it is part of a shared service (<code>svchost.exe</code>). It is implemented as a few different libraries, saved in <code>C:\Windows\System32\</code>:</p>
<ul>
<li><code>wuaueng.dll</code>: Windows Update Agent Engine (Core Logic)</li>
<li><code>wuapi.dll</code>: Windows Update API Interface</li>
<li><code>wucltux.dll</code>: Windows Update Client UI</li>
<li><code>wups.dll</code>/<code>wups2.dll</code>: Windows Update client proxy stub</li>
<li><code>wuwebv.dll</code>: Web-Based Windows Update control</li>
</ul>
<p>Essentially, Windows Updater is the delivery mechanism, while Windows Security is the monitoring and enforcement hub. They cooperate to maintain the security of the system in an evolving threat landscape.</p>
<h3 id="interface"><a class="header" href="#interface">Interface</a></h3>
<p><code>SecHealthUI.exe</code> is the executable for the <strong>Windows Security UI</strong>. However, <code>MpCmdRun.exe</code> is a command-line utility which allows users to interact with <code>MsMpEng.exe</code> directly. It can be used for a variety of tasks, including updating system components, running antimalware scans on files, restoring system configurations, and testing network connection to available security services. Here, we will go over a few useful commands that can be used to interact with the service.</p>
<ul>
<li>
<p><code>MpCmdRun.exe -SignatureUpdate</code>: Forces Microsoft Defender to immediately check for and download the latest security intelligence updates.
<img src="https://hackmd.io/_uploads/rJcQMdEzWe.png" alt="image" /></p>
</li>
<li>
<p><code>MpCmdRun.exe -Scan -ScanType 1</code>: Runs a Quick Scan, checking common malware locations, memory, and startup files. This is the fastest and most common scan type.
<img src="https://hackmd.io/_uploads/BkzTm_NzZl.png" alt="image" /></p>
</li>
<li>
<p><code>MpCmdRun.exe -Scan -ScanType 2</code>: Runs a Full Scan, scanning all files and running processes on the local hard disk. It takes significantly more time than a Quick Scan, but is more thorough.
<img src="https://hackmd.io/_uploads/SkPCOOVz-e.png" alt="image" /></p>
</li>
<li>
<p><code>MpCmdRun.exe -Scan -ScanType 3 -File &lt;file_path&gt;</code>: Runs a scan against a specific file or directory. It is useful for targeted analysis of suspicious files.
<img src="https://hackmd.io/_uploads/B1uk6dEMbl.png" alt="image" /></p>
<ul>
<li>Use <code>-DisableRemediation</code> to prevent Defender from taking action if malware is found. This is useful for analysts who want to inspect the malware before it is removed.</li>
</ul>
</li>
<li>
<p><code>MpCmdRun.exe -Restore -All</code>: Restores all items that are currently in the quarantine folder back to their original locations.</p>
</li>
<li>
<p><code>MpCmdRun.exe -RemoveDefinitions -All</code>: Removes all downloaded security intelligence definitions.</p>
</li>
<li>
<p><code>MpCmdRun.exe -ValidateMapsConnection</code>: Tests connectivity to the <strong>Microsoft Active Protection Service</strong>, which provides cloud-delivered protection. It is essential for ensuring <strong>SmartScreen</strong> and real-time defense intelligence are functioning.</p>
</li>
</ul>
<p>There are also a number of PowerShell cmdlets that can be used to perform Windows Security operations as well.
For instance, <code>Get-MpComputerStatus</code> can be used to get the real-time operational status of Microsoft Defender:
<img src="https://hackmd.io/_uploads/HJvtQtNzbg.png" alt="image" /></p>
<p><code>Get-MpThreat</code> is another useful cmdlet, which shows the name, severity, and detection time of active threats:
<img src="https://hackmd.io/_uploads/SJhv4tNMZe.png" alt="image" />
Use <code>Remove-MpThreat</code> to remove any detected threats from the system.
You can also run <code>Start-MpScan</code> to run a quick scan on the system:
<img src="https://hackmd.io/_uploads/B1nwdKNzbl.png" alt="image" /></p>
<h3 id="red-team-considerations"><a class="header" href="#red-team-considerations">Red Team Considerations</a></h3>
<p>Red team operations dealing with Microsoft Defender Antivirus require balancing evasion with Operations Security (OpSec) to avoid prematurely alerting blue teams.</p>
<div id="admonition-warning-1" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-1-title">
<div class="admonition-title">
<div id="admonition-warning-1-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="#admonition-warning-1"></a>
</div>
<div>
<p><strong>We will discuss OpSec in greater detail in Chapter 6 <em>Introduction to C2 Frameworks and Operations Security</em></strong></p>
</div>
</div>
<p>A few key things to consider. First, Defender's effectiveness depends on configuration and whether it is standalone or integrated with Microsoft Defender for Endpoint (MDE) (This can be verified using <code>Get-Service -Name Sense</code>). You need to test potential payloads in isolated labs mirroring target setups. Defender uses many diferent techniques to identify malicious activity on a system (i.e., <code>Signature-based etection</code>, <code>Behaviroal Analysis</code>, <code>AMSI Integration</code>, <code>Exploit Guard/Windows Defender Application Control</code> (WDAC)). While custom payloads play a vital role in running a successful operation, introducing factors like jitter, custom beacons, and payload patching can help obfuscate payloads and circumvent detection methods. Microsoft Defender uses API hooks to intercept and monitor system calls at runtime. By hooking into critical Windows APIs (i.e., <code>NtCreateFile</code>, <code>NtCreateProces</code>, <code>NtWriteProcessMemory</code>), Defender can inspect, block, or modify potentially dangerous malicious behavior before it executes. Use techniques like Direct Syscalls + sRDI (Syscall Reflective DLL Injection), DLL Highjacking (Side-Loading), and Unhooking and Process Killing to circumvent these protections. (cred: <code>@5mukx</code> on X). Focus on layered evasion: initial access, execution, and persistence. Prioritize LotL to minimize custom binaries.</p>
<p>One more thing to consider. Microsoft Defender Antivirus provides core prevention features (i.e., <code>Real-Time Protection</code>, <code>Exploit Guard</code>, <code>SmartScreen</code>) and operates well as the first-line of defense, However, it is not a full Endpoint Detection and Response (EDR) solution. It works as a prevention solution for known threats and a reactive remediation system to quarantine or delete identified threats. However, it does not work for detection, investigation, or automated response for unknown/advanced threats. Integrate Microsoft Defender Antivirus with Microsoft Defender for Endpoint to form a full, host based EDR solution.</p>
<h2 id="additional-security-features-of-windows"><a class="header" href="#additional-security-features-of-windows">Additional Security Features of Windows</a></h2>
<h3 id="hvci"><a class="header" href="#hvci">HVCI</a></h3>
<p><strong>Hypervisor-Enforced Code Integrity</strong> (HVCI) (aka. <code>Memory Integrity</code>) is a virtualization based security feature that ensures that all code destined for the Windows Kernel has been digitally signed and has not been altered. It relies on <strong>Virtualization-based Security</strong> (VBS), utilizing the hardware's hypervisor to divide the system memory into two different <strong>Virtual Trust Levels</strong>:</p>
<ul>
<li><code>VTL 0</code>: The common area where applications, drivers, and even the OS itself are housed.</li>
<li><code>VTL 1</code>: The highly secure kernel environment that is hidden from VTL 0.</li>
</ul>
<p>During the boot-up process, <code>winload.exe</code> (or <code>winload.efi</code> on UEFI systems) will check the configuration of <strong>VBS</strong> via the <strong>Boot Configuration Data</strong> (BCD) and if it is enabled, it will load <code>hvloader.dll</code> and <code>hvix64.exe</code> or <code>hvax64.exe</code> into memory, initializing the hypervisor. Then, <code>winload.exe</code> loads <code>ntoskrnl.exe</code> into memory the <code>VTL 0</code> memory region under <code>Ring 0</code>. Finally, <code>winload.exe</code> loads <code>securekernel.exe</code> into the <code>VTL 1</code> memory region, under <code>Ring 0</code>. Once all three parts are loaded into memory by <code>winload.exe</code>, it transfers control to <code>hvix64.exe</code> (the hypervisor), which then executes the secure kernel. <code>securekernel.exe</code> sets up its own memory protection systems, and initializes its Code Integrity policices. At this point, the <code>VTL 0</code> environment is set up, so <code>securekernel.exe</code> signals to <code>hvix64.exe</code> that it is ready to monitor the system. Now, <code>hvix64.exe</code> will start <code>ntoskrnl.exe</code> starting up the Windows OS and subsequently, any request to modify the permissions of kernel-mode memory so that it can be executed will result in a <strong>hypercall</strong> being made to the hypervisor, requesting permission for the change to occur. Once this call is made, the hypervisor shifts control to the secure kernel, where <code>skci.dll</code> (Secure Kernel Code Integrity) inspects the region of <code>VTL 0</code> that the permissions change has been requested for and if the code in that region has not been signed by a trusted authority, the request is denied when control is reverted back to <code>VTL 0</code>.</p>
<h3 id="credential-guard"><a class="header" href="#credential-guard">Credential Guard</a></h3>
<p><strong>Credential Guard</strong> is another modern security feature that uses <strong>VBS</strong>. In traditional systems, <code>LSASS.exe</code> stores credentials/secrets in its own process memory, so in the event that attackers gain admin or kernel level permissions, they can dump the memory of <code>LSASS.exe</code> and steal credentials. When Credential Guard is active, the actual secrets and cryptographic keys are moved into a secure process called <code>LSAIso.exe</code>, which runs in <code>VTL 1</code>. This means that when an application needs to authenticate with <code>LSASS.exe</code>, it makes a hypercall and the hypervisor transfers control to <code>LSAIso.exe</code>, where the actual authentication process occurs. The results are then passed back to <code>LSASS.exe</code> for processing.</p>
<h3 id="ppl"><a class="header" href="#ppl">PPL</a></h3>
<p><strong>Protected Process Light</strong> provides kernel-enforced protections for critical system processes and approved third-party services making them highly resistant to tampering, even against processes with administrative privileges. The kernel provides a protection level to processes based on their digital signature, which often require special Microsoft certificates. Only processes with an equal or higher protection level can interact with a PPL process in a privileged way:</p>
<ol>
<li><strong>PsProtectedSignerWinTcb</strong>: The highest protection level. It is used for core <strong>Trusted Computing Base</strong> (TCB) components, such as <code>smss.exe</code>.</li>
<li><strong>PsProtectedSignerWindows</strong>: For standard Windows processes.</li>
<li><strong>PsProtectedSignerLsa</strong>: For LSASS</li>
<li><strong>PsProtectedSignerAntimalware</strong>: Also called <strong>Antimalware Protected Process Light</strong> (AM-PPL). Used for approved antimalware services, such as Microsoft Defender's <code>MsMpEng.exe</code>.</li>
<li><strong>PsProtectedSignerCodeGen</strong>: A reserved or internal signer class that Windows currently does not use for any major subsystem. There is no evidence of real‑world usage.</li>
<li><strong>PsProtectedSignerAuthenticode</strong>: The weakest level of PPL class that requires Microsoft-trusted Authenticode signing.</li>
<li><strong>PsProtectedSignerNone</strong>: The default for normal user an system processes. No protection provided.</li>
</ol>
<p>You can check the level of protection a given program has been assigned by querying <code>HKLM\SYSTEM\CurrentControlSet\Services\[ServiceName]</code> and checking the <code>LaunchProtected</code> value:
<img src="https://hackmd.io/_uploads/B1avj534be.png" alt="image" /></p>
<p>The <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_PS_PROTECTED_SIGNER">_PS_PROTECTED_SIGNER</a> structure contains definitions and names for all the protection levels that can be assigned to a PPL.</p>
<p>This value can give you a hint as to what the actual PPL protection level is for any service, although the actual value is different and is stored as part of a kernel object, <code>EPROCESS.Protection</code>. This is what each hexadecimal value means:</p>
<ul>
<li><code>SERVICE_LAUNCH_PROTECTED_NONE</code>: 0 - Not PPL</li>
<li><code>SERVICE_LAUNCH_PROTECTED_WINDOWS</code>: 1 - WinTcb/WinSystem depending on the signature</li>
<li><code>SERVICE_LAUNCH_PROTECTED_WINDOWS_LIGHT</code>: 2 - WinTcb-Light/WinSystem-Light</li>
<li><code>SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</code>: 3 - Antimalware-Light</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>As the largest PC operating system in the world, Windows is a frequent target for malicious actors to study and develop exploits for. As an OffSec professional, understanding how Windows works and how it is organized is the first step in being able to analyze, write exploits, and manage command and control servers for Windows systems and domains. As we move forward from here, use this chapter as reference. The subjects we covered here play an important role in successfully running a Red Team Operation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Laws.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Essentials.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Laws.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Essentials.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
